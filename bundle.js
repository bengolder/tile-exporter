!function(n){function e(n){var e=document.getElementsByTagName("head")[0],r=document.createElement("script");r.type="text/javascript",r.charset="utf-8",r.src=p.p+""+n+"."+_+".hot-update.js",e.appendChild(r)}function r(n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var e=new XMLHttpRequest,r=p.p+""+_+".hot-update.json";e.open("GET",r,!0),e.timeout=1e4,e.send(null)}catch(t){return n(t)}e.onreadystatechange=function(){if(4===e.readyState)if(0===e.status)n(new Error("Manifest request to "+r+" timed out."));else if(404===e.status)n();else if(200!==e.status&&304!==e.status)n(new Error("Manifest request to "+r+" failed."));else{try{var t=JSON.parse(e.responseText)}catch(a){return void n(a)}n(null,t)}}}function t(n){function e(n,e){"ready"===w&&i("prepare"),k++,p.e(n,function(){function r(){k--,"prepare"===w&&(S[n]||c(n),0===k&&0===R&&u())}try{e.call(null,t)}finally{r()}})}var r=A[n];if(!r)return p;var t=function(e){return r.hot.active?A[e]?(A[e].parents.indexOf(n)<0&&A[e].parents.push(n),r.children.indexOf(e)<0&&r.children.push(e)):x=[n]:(console.warn("[HMR] unexpected require("+e+") from disposed module "+n),x=[]),p(e)};for(var a in p)Object.prototype.hasOwnProperty.call(p,a)&&(m?Object.defineProperty(t,a,function(n){return{configurable:!0,enumerable:!0,get:function(){return p[n]},set:function(e){p[n]=e}}}(a)):t[a]=p[a]);return m?Object.defineProperty(t,"e",{enumerable:!0,value:e}):t.e=e,t}function a(n){var e={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],active:!0,accept:function(n,r){if("undefined"==typeof n)e._selfAccepted=!0;else if("function"==typeof n)e._selfAccepted=n;else if("object"==typeof n)for(var t=0;t<n.length;t++)e._acceptedDependencies[n[t]]=r;else e._acceptedDependencies[n]=r},decline:function(n){if("undefined"==typeof n)e._selfDeclined=!0;else if("number"==typeof n)e._declinedDependencies[n]=!0;else for(var r=0;r<n.length;r++)e._declinedDependencies[n[r]]=!0},dispose:function(n){e._disposeHandlers.push(n)},addDisposeHandler:function(n){e._disposeHandlers.push(n)},removeDisposeHandler:function(n){var r=e._disposeHandlers.indexOf(n);r>=0&&e._disposeHandlers.splice(r,1)},check:s,apply:d,status:function(n){return n?void T.push(n):w},addStatusHandler:function(n){T.push(n)},removeStatusHandler:function(n){var e=T.indexOf(n);e>=0&&T.splice(e,1)},data:E[n]};return e}function i(n){w=n;for(var e=0;e<T.length;e++)T[e].call(null,n)}function o(n){var e=+n+""===n;return e?+n:n}function s(n,e){if("idle"!==w)throw new Error("check() is only allowed in idle status");"function"==typeof n?(b=!1,e=n):(b=n,e=e||function(n){if(n)throw n}),i("check"),r(function(n,r){if(n)return e(n);if(!r)return i("idle"),void e(null,null);C={},M={},S={};for(var t=0;t<r.c.length;t++)M[r.c[t]]=!0;y=r.h,i("prepare"),g=e,v={};var a=0;c(a),"prepare"===w&&0===k&&0===R&&u()})}function l(n,e){if(M[n]&&C[n]){C[n]=!1;for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(v[r]=e[r]);0===--R&&0===k&&u()}}function c(n){M[n]?(C[n]=!0,R++,e(n)):S[n]=!0}function u(){i("ready");var n=g;if(g=null,n)if(b)d(b,n);else{var e=[];for(var r in v)Object.prototype.hasOwnProperty.call(v,r)&&e.push(o(r));n(null,e)}}function d(e,r){function t(n){for(var e=[n],r={},t=e.slice();t.length>0;){var i=t.pop(),n=A[i];if(n&&!n.hot._selfAccepted){if(n.hot._selfDeclined)return new Error("Aborted because of self decline: "+i);if(0===i)return;for(var o=0;o<n.parents.length;o++){var s=n.parents[o],l=A[s];if(l.hot._declinedDependencies[i])return new Error("Aborted because of declined dependency: "+i+" in "+s);e.indexOf(s)>=0||(l.hot._acceptedDependencies[i]?(r[s]||(r[s]=[]),a(r[s],[i])):(delete r[s],e.push(s),t.push(s)))}}}return[e,r]}function a(n,e){for(var r=0;r<e.length;r++){var t=e[r];n.indexOf(t)<0&&n.push(t)}}if("ready"!==w)throw new Error("apply() is only allowed in ready status");"function"==typeof e?(r=e,e={}):e&&"object"==typeof e?r=r||function(n){if(n)throw n}:(e={},r=r||function(n){if(n)throw n});var s={},l=[],c={};for(var u in v)if(Object.prototype.hasOwnProperty.call(v,u)){var d=o(u),h=t(d);if(!h){if(e.ignoreUnaccepted)continue;return i("abort"),r(new Error("Aborted because "+d+" is not accepted"))}if(h instanceof Error)return i("abort"),r(h);c[d]=v[d],a(l,h[0]);for(var d in h[1])Object.prototype.hasOwnProperty.call(h[1],d)&&(s[d]||(s[d]=[]),a(s[d],h[1][d]))}for(var m=[],f=0;f<l.length;f++){var d=l[f];A[d]&&A[d].hot._selfAccepted&&m.push({module:d,errorHandler:A[d].hot._selfAccepted})}i("dispose");for(var g=l.slice();g.length>0;){var d=g.pop(),b=A[d];if(b){for(var T={},R=b.hot._disposeHandlers,k=0;k<R.length;k++){var S=R[k];S(T)}E[d]=T,b.hot.active=!1,delete A[d];for(var k=0;k<b.children.length;k++){var C=A[b.children[k]];if(C){var M=C.parents.indexOf(d);M>=0&&C.parents.splice(M,1)}}}}for(var d in s)if(Object.prototype.hasOwnProperty.call(s,d))for(var b=A[d],I=s[d],k=0;k<I.length;k++){var j=I[k],M=b.children.indexOf(j);M>=0&&b.children.splice(M,1)}i("apply"),_=y;for(var d in c)Object.prototype.hasOwnProperty.call(c,d)&&(n[d]=c[d]);var N=null;for(var d in s)if(Object.prototype.hasOwnProperty.call(s,d)){for(var b=A[d],I=s[d],P=[],f=0;f<I.length;f++){var j=I[f],S=b.hot._acceptedDependencies[j];P.indexOf(S)>=0||P.push(S)}for(var f=0;f<P.length;f++){var S=P[f];try{S(s)}catch(O){N||(N=O)}}}for(var f=0;f<m.length;f++){var D=m[f],d=D.module;x=[d];try{p(d)}catch(O){if("function"==typeof D.errorHandler)try{D.errorHandler(O)}catch(O){N||(N=O)}else N||(N=O)}}return N?(i("fail"),r(N)):(i("idle"),void r(null,l))}function p(e){if(A[e])return A[e].exports;var r=A[e]={exports:{},id:e,loaded:!1,hot:a(e),parents:x,children:[]};return n[e].call(r.exports,r,r.exports,t(e)),r.loaded=!0,r.exports}var h=this.webpackHotUpdate;this.webpackHotUpdate=function(n,e){l(n,e),h&&h(n,e)};var m=!1;try{Object.defineProperty({},"x",{get:function(){}}),m=!0}catch(f){}var g,v,y,b=!0,_="731dfdf2dbe1b7aa1c38",E={},x=[],T=[],w="idle",R=0,k=0,S={},C={},M={},A={};return p.m=n,p.c=A,p.p="",p.h=function(){return _},t(0)(0)}([function(module,exports,__webpack_require__){eval("__webpack_require__(201);\nmodule.exports = __webpack_require__(105);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?")},function(module,exports){eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/invariant.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/invariant.js?")},function(module,exports){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\n'use strict';\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n}\n\nmodule.exports = assign;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Object.assign.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Object.assign.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n'use strict';\n\nvar emptyFunction = __webpack_require__(10);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // --- Welcome to debugging React ---\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch (x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/warning.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/warning.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n'use strict';\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/ExecutionEnvironment.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/ExecutionEnvironment.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactDOMFeatureFlags = __webpack_require__(75);\nvar ReactElement = __webpack_require__(7);\nvar ReactEmptyComponentRegistry = __webpack_require__(82);\nvar ReactInstanceHandles = __webpack_require__(19);\nvar ReactInstanceMap = __webpack_require__(23);\nvar ReactMarkupChecksum = __webpack_require__(85);\nvar ReactPerf = __webpack_require__(8);\nvar ReactReconciler = __webpack_require__(16);\nvar ReactUpdateQueue = __webpack_require__(47);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar emptyObject = __webpack_require__(20);\nvar containsNode = __webpack_require__(62);\nvar instantiateReactComponent = __webpack_require__(54);\nvar invariant = __webpack_require__(2);\nvar setInnerHTML = __webpack_require__(33);\nvar shouldUpdateReactComponent = __webpack_require__(57);\nvar validateDOMNesting = __webpack_require__(59);\nvar warning = __webpack_require__(4);\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\nvar ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n * a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {\n  if (ReactDOMFeatureFlags.useCreateElement) {\n    context = assign({}, context);\n    if (container.nodeType === DOC_NODE_TYPE) {\n      context[ownerDocumentContextKey] = container;\n    } else {\n      context[ownerDocumentContextKey] = container.ownerDocument;\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (context === emptyObject) {\n      context = {};\n    }\n    var tag = container.nodeName.toLowerCase();\n    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);\n  }\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);\n  componentInstance._renderedComponent._topLevelWrapper = componentInstance;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n  /* forceHTML */shouldReuseMarkup);\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Unmounts a component and removes it from the DOM.\n *\n * @param {ReactComponent} instance React component instance.\n * @param {DOMElement} container DOM element to unmount from.\n * @final\n * @internal\n * @see {ReactMount.unmountComponentAtNode}\n */\nfunction unmountComponentFromNode(instance, container) {\n  ReactReconciler.unmountComponent(instance);\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    container = container.documentElement;\n  }\n\n  // http://jsperf.com/emptying-a-node\n  while (container.lastChild) {\n    container.removeChild(container.lastChild);\n  }\n}\n\n/**\n * True if the supplied DOM node has a direct React-rendered child that is\n * not a React root element. Useful for warning in `render`,\n * `unmountComponentAtNode`, etc.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM element contains a direct child that was\n * rendered by React but is not a root element.\n * @internal\n */\nfunction hasNonRootReactChild(node) {\n  var reactRootID = getReactRootID(node);\n  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;\n}\n\n/**\n * Returns the first (deepest) ancestor of a node which is rendered by this copy\n * of React.\n */\nfunction findFirstReactDOMImpl(node) {\n  // This node might be from another React instance, so we make sure not to\n  // examine the node cache here\n  for (; node && node.parentNode !== node; node = node.parentNode) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      continue;\n    }\n    var nodeID = internalGetID(node);\n    if (!nodeID) {\n      continue;\n    }\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n\n    // If containersByReactRootID contains the container we find by crawling up\n    // the tree, we know that this instance of React rendered the node.\n    // nb. isValid's strategy (with containsNode) does not work because render\n    // trees may be nested and we don't want a false positive in that case.\n    var current = node;\n    var lastID;\n    do {\n      lastID = internalGetID(current);\n      current = current.parentNode;\n      if (current == null) {\n        // The passed-in node has been detached from the container it was\n        // originally rendered into.\n        return null;\n      }\n    } while (lastID !== reactRootID);\n\n    if (current === containersByReactRootID[reactRootID]) {\n      return node;\n    }\n  }\n  return null;\n}\n\n/**\n * Temporary (?) hack so that we can store all top-level pending updates on\n * composites instead of having to worry about different types of components\n * here.\n */\nvar TopLevelWrapper = function () {};\nTopLevelWrapper.prototype.isReactComponent = {};\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\nTopLevelWrapper.prototype.render = function () {\n  // this.props is actually a ReactElement\n  return this.props;\n};\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n\n  TopLevelWrapper: TopLevelWrapper,\n\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(componentInstance, container);\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  },\n\n  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {\n    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :\n    // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;\n\n    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;\n\n    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevWrappedElement = prevComponent._currentElement;\n      var prevElement = prevWrappedElement.props;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        var publicInst = prevComponent._renderedComponent.getPublicInstance();\n        var updatedCallback = callback && function () {\n          callback.call(publicInst);\n        };\n        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);\n        return publicInst;\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);\n    var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;\n\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (internalGetID(rootElementSibling)) {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;\n            break;\n          }\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;\n    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;\n\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      // Check if the node being unmounted was rendered by React, but isn't a\n      // root node.\n      var containerHasNonRootReactChild = hasNonRootReactChild(container);\n\n      // Check if the container itself is a React root node.\n      var containerID = internalGetID(container);\n      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;\n      }\n\n      return false;\n    }\n    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (process.env.NODE_ENV !== 'production') {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (process.env.NODE_ENV !== 'production') {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        process.env.NODE_ENV !== 'production' ? warning(\n        // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;\n        var containerChild = container.firstChild;\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component rendered by this copy of React.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    return findFirstReactDOMImpl(node);\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw on the next line; give an early warning\n      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\\'t find the root component node for data-reactid value ' + '`%s`. If you\\'re seeing this message, it probably means that ' + 'you\\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;\n    }\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;\n  },\n\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {\n    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n\n        var normalizedMarkup = markup;\n        if (process.env.NODE_ENV !== 'production') {\n          // because rootMarkup is retrieved from the DOM, various normalizations\n          // will have occurred which will not be present in `markup`. Here,\n          // insert markup into a <div> or <iframe> depending on the container\n          // type to perform the same normalizations before comparing.\n          var normalizer;\n          if (container.nodeType === ELEMENT_NODE_TYPE) {\n            normalizer = document.createElement('div');\n            normalizer.innerHTML = markup;\n            normalizedMarkup = normalizer.innerHTML;\n          } else {\n            normalizer = document.createElement('iframe');\n            document.body.appendChild(normalizer);\n            normalizer.contentDocument.write(markup);\n            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;\n            document.body.removeChild(normalizer);\n          }\n        }\n\n        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);\n        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(false) : undefined;\n\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : undefined;\n        }\n      }\n    }\n\n    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n\n    if (transaction.useCreateElement) {\n      while (container.lastChild) {\n        container.removeChild(container.lastChild);\n      }\n      container.appendChild(markup);\n    } else {\n      setInnerHTML(container, markup);\n    }\n  },\n\n  ownerDocumentContextKey: ownerDocumentContextKey,\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  isValid: isValid,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMount.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMount.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElement\n */\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(12);\n\nvar assign = __webpack_require__(3);\nvar canDefineProperty = __webpack_require__(31);\n\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\n/**\n * Base constructor for all React elements. This is only used to make this\n * work with a dynamic instanceof check. Nothing should live on this prototype.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allow us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    if (canDefineProperty) {\n      Object.defineProperty(element._store, 'validated', {\n        configurable: false,\n        enumerable: false,\n        writable: true,\n        value: false\n      });\n      // self and source are DEV only properties.\n      Object.defineProperty(element, '_self', {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: self\n      });\n      // Two elements created in two different places should be considered\n      // equal for testing purposes and therefore we hide it from enumeration.\n      Object.defineProperty(element, '_source', {\n        configurable: false,\n        enumerable: false,\n        writable: false,\n        value: source\n      });\n    } else {\n      element._store.validated = false;\n      element._self = self;\n      element._source = source;\n    }\n    Object.freeze(element.props);\n    Object.freeze(element);\n  }\n\n  return element;\n};\n\nReactElement.createElement = function (type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref;\n    key = config.key === undefined ? null : '' + config.key;\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (typeof props[propName] === 'undefined') {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n};\n\nReactElement.createFactory = function (type) {\n  var factory = ReactElement.createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook TODO: Warn if this is accessed\n  factory.type = type;\n  return factory;\n};\n\nReactElement.cloneAndReplaceKey = function (oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n};\n\nReactElement.cloneAndReplaceProps = function (oldElement, newProps) {\n  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // If the key on the original is valid, then the clone is valid\n    newElement._store.validated = oldElement._store.validated;\n  }\n\n  return newElement;\n};\n\nReactElement.cloneElement = function (element, config, children) {\n  var propName;\n\n  // Original props are copied\n  var props = assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (config.ref !== undefined) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (config.key !== undefined) {\n      key = '' + config.key;\n    }\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n};\n\n/**\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nReactElement.isValidElement = function (object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n};\n\nmodule.exports = ReactElement;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElement.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElement.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPerf\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * ReactPerf is a general AOP system designed to measure performance. This\n * module only has the hooks: see ReactDefaultPerf for the analysis tool.\n */\nvar ReactPerf = {\n  /**\n   * Boolean to enable/disable measurement. Set to false by default to prevent\n   * accidental logging and perf loss.\n   */\n  enableMeasure: false,\n\n  /**\n   * Holds onto the measure function in use. By default, don't measure\n   * anything, but we'll override this if we inject a measure function.\n   */\n  storedMeasure: _noMeasure,\n\n  /**\n   * @param {object} object\n   * @param {string} objectName\n   * @param {object<string>} methodNames\n   */\n  measureMethods: function (object, objectName, methodNames) {\n    if (process.env.NODE_ENV !== 'production') {\n      for (var key in methodNames) {\n        if (!methodNames.hasOwnProperty(key)) {\n          continue;\n        }\n        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);\n      }\n    }\n  },\n\n  /**\n   * Use this to wrap methods you want to measure. Zero overhead in production.\n   *\n   * @param {string} objName\n   * @param {string} fnName\n   * @param {function} func\n   * @return {function}\n   */\n  measure: function (objName, fnName, func) {\n    if (process.env.NODE_ENV !== 'production') {\n      var measuredFunc = null;\n      var wrapper = function () {\n        if (ReactPerf.enableMeasure) {\n          if (!measuredFunc) {\n            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);\n          }\n          return measuredFunc.apply(this, arguments);\n        }\n        return func.apply(this, arguments);\n      };\n      wrapper.displayName = objName + '_' + fnName;\n      return wrapper;\n    }\n    return func;\n  },\n\n  injection: {\n    /**\n     * @param {function} measure\n     */\n    injectMeasure: function (measure) {\n      ReactPerf.storedMeasure = measure;\n    }\n  }\n};\n\n/**\n * Simply passes through the measured function, without measuring it.\n *\n * @param {string} objName\n * @param {string} fnName\n * @param {function} func\n * @return {function}\n */\nfunction _noMeasure(objName, fnName, func) {\n  return func;\n}\n\nmodule.exports = ReactPerf;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPerf.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPerf.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = __webpack_require__(41);\nvar PooledClass = __webpack_require__(14);\nvar ReactPerf = __webpack_require__(8);\nvar ReactReconciler = __webpack_require__(16);\nvar Transaction = __webpack_require__(30);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactUpdates.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactUpdates.js?")},function(module,exports){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\n"use strict";\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/emptyFunction.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/emptyFunction.js?')},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventConstants\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(25);\n\nvar PropagationPhases = keyMirror({ bubbled: null, captured: null });\n\n/**\n * Types of raw signals from the browser caught at the top level.\n */\nvar topLevelTypes = keyMirror({\n  topAbort: null,\n  topBlur: null,\n  topCanPlay: null,\n  topCanPlayThrough: null,\n  topChange: null,\n  topClick: null,\n  topCompositionEnd: null,\n  topCompositionStart: null,\n  topCompositionUpdate: null,\n  topContextMenu: null,\n  topCopy: null,\n  topCut: null,\n  topDoubleClick: null,\n  topDrag: null,\n  topDragEnd: null,\n  topDragEnter: null,\n  topDragExit: null,\n  topDragLeave: null,\n  topDragOver: null,\n  topDragStart: null,\n  topDrop: null,\n  topDurationChange: null,\n  topEmptied: null,\n  topEncrypted: null,\n  topEnded: null,\n  topError: null,\n  topFocus: null,\n  topInput: null,\n  topKeyDown: null,\n  topKeyPress: null,\n  topKeyUp: null,\n  topLoad: null,\n  topLoadedData: null,\n  topLoadedMetadata: null,\n  topLoadStart: null,\n  topMouseDown: null,\n  topMouseMove: null,\n  topMouseOut: null,\n  topMouseOver: null,\n  topMouseUp: null,\n  topPaste: null,\n  topPause: null,\n  topPlay: null,\n  topPlaying: null,\n  topProgress: null,\n  topRateChange: null,\n  topReset: null,\n  topScroll: null,\n  topSeeked: null,\n  topSeeking: null,\n  topSelectionChange: null,\n  topStalled: null,\n  topSubmit: null,\n  topSuspend: null,\n  topTextInput: null,\n  topTimeUpdate: null,\n  topTouchCancel: null,\n  topTouchEnd: null,\n  topTouchMove: null,\n  topTouchStart: null,\n  topVolumeChange: null,\n  topWaiting: null,\n  topWheel: null\n});\n\nvar EventConstants = {\n  topLevelTypes: topLevelTypes,\n  PropagationPhases: PropagationPhases\n};\n\nmodule.exports = EventConstants;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventConstants.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventConstants.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCurrentOwner\n */\n\n'use strict';\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n\n};\n\nmodule.exports = ReactCurrentOwner;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCurrentOwner.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCurrentOwner.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyOf\n */\n\n/**\n * Allows extraction of a minified key. Let's the build system minify keys\n * without losing the ability to dynamically use key strings as values\n * themselves. Pass in an object with a single key/val pair and it will return\n * you the string key of that single record. Suppose you want to grab the\n * value for a key 'className' inside of an object. Key/val minification may\n * have aliased that key to be 'xa12'. keyOf({className: null}) will return\n * 'xa12' in that case. Resolve keys you want to use once at startup time, then\n * reuse those resolutions.\n */\n\"use strict\";\n\nvar keyOf = function (oneKeyObj) {\n  var key;\n  for (key in oneKeyObj) {\n    if (!oneKeyObj.hasOwnProperty(key)) {\n      continue;\n    }\n    return key;\n  }\n  return null;\n};\n\nmodule.exports = keyOf;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/keyOf.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/keyOf.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PooledClass\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Static poolers. Several custom versions for each potential number of\n * arguments. A completely generic pooler is easy to implement, but would\n * require accessing the `arguments` object. In each of these, `this` refers to\n * the Class itself, not an instance. If any others are needed, simply add them\n * here, or in their own files.\n */\nvar oneArgumentPooler = function (copyFieldsFrom) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, copyFieldsFrom);\n    return instance;\n  } else {\n    return new Klass(copyFieldsFrom);\n  }\n};\n\nvar twoArgumentPooler = function (a1, a2) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2);\n    return instance;\n  } else {\n    return new Klass(a1, a2);\n  }\n};\n\nvar threeArgumentPooler = function (a1, a2, a3) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3);\n  }\n};\n\nvar fourArgumentPooler = function (a1, a2, a3, a4) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3, a4);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3, a4);\n  }\n};\n\nvar fiveArgumentPooler = function (a1, a2, a3, a4, a5) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3, a4, a5);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3, a4, a5);\n  }\n};\n\nvar standardReleaser = function (instance) {\n  var Klass = this;\n  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;\n  instance.destructor();\n  if (Klass.instancePool.length < Klass.poolSize) {\n    Klass.instancePool.push(instance);\n  }\n};\n\nvar DEFAULT_POOL_SIZE = 10;\nvar DEFAULT_POOLER = oneArgumentPooler;\n\n/**\n * Augments `CopyConstructor` to be a poolable class, augmenting only the class\n * itself (statically) not adding any prototypical fields. Any CopyConstructor\n * you give this may have a `poolSize` property, and will look for a\n * prototypical `destructor` on instances (optional).\n *\n * @param {Function} CopyConstructor Constructor that can be used to reset.\n * @param {Function} pooler Customizable pooler.\n */\nvar addPoolingTo = function (CopyConstructor, pooler) {\n  var NewKlass = CopyConstructor;\n  NewKlass.instancePool = [];\n  NewKlass.getPooled = pooler || DEFAULT_POOLER;\n  if (!NewKlass.poolSize) {\n    NewKlass.poolSize = DEFAULT_POOL_SIZE;\n  }\n  NewKlass.release = standardReleaser;\n  return NewKlass;\n};\n\nvar PooledClass = {\n  addPoolingTo: addPoolingTo,\n  oneArgumentPooler: oneArgumentPooler,\n  twoArgumentPooler: twoArgumentPooler,\n  threeArgumentPooler: threeArgumentPooler,\n  fourArgumentPooler: fourArgumentPooler,\n  fiveArgumentPooler: fiveArgumentPooler\n};\n\nmodule.exports = PooledClass;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/PooledClass.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/PooledClass.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMProperty\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_ATTRIBUTE: 0x1,\n  MUST_USE_PROPERTY: 0x2,\n  HAS_SIDE_EFFECTS: 0x4,\n  HAS_BOOLEAN_VALUE: 0x8,\n  HAS_NUMERIC_VALUE: 0x10,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * isCustomAttribute: function that given an attribute name will return true\n   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*\n   * attributes where it's impossible to enumerate all of the possible\n   * attribute names,\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n   * attribute namespace URL. (Attribute names not specified use no namespace.)\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function (domPropertyConfig) {\n    var Injection = DOMPropertyInjection;\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    if (domPropertyConfig.isCustomAttribute) {\n      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);\n    }\n\n    for (var propName in Properties) {\n      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\\'re trying to inject DOM property ' + '\\'%s\\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;\n\n      var lowerCased = propName.toLowerCase();\n      var propConfig = Properties[propName];\n\n      var propertyInfo = {\n        attributeName: lowerCased,\n        attributeNamespace: null,\n        propertyName: propName,\n        mutationMethod: null,\n\n        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),\n        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),\n        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)\n      };\n\n      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;\n      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;\n      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;\n\n      if (process.env.NODE_ENV !== 'production') {\n        DOMProperty.getPossibleStandardName[lowerCased] = propName;\n      }\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n        propertyInfo.attributeName = attributeName;\n        if (process.env.NODE_ENV !== 'production') {\n          DOMProperty.getPossibleStandardName[attributeName] = propName;\n        }\n      }\n\n      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n      }\n\n      if (DOMPropertyNames.hasOwnProperty(propName)) {\n        propertyInfo.propertyName = DOMPropertyNames[propName];\n      }\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        propertyInfo.mutationMethod = DOMMutationMethods[propName];\n      }\n\n      DOMProperty.properties[propName] = propertyInfo;\n    }\n  }\n};\nvar defaultValueCache = {};\n\n/**\n * DOMProperty exports lookup objects that can be used like functions:\n *\n *   > DOMProperty.isValid['id']\n *   true\n *   > DOMProperty.isValid['foobar']\n *   undefined\n *\n * Although this may be confusing, it performs better in general.\n *\n * @see http://jsperf.com/key-exists\n * @see http://jsperf.com/key-missing\n */\nvar DOMProperty = {\n\n  ID_ATTRIBUTE_NAME: 'data-reactid',\n\n  /**\n   * Map from property \"standard name\" to an object with info about how to set\n   * the property in the DOM. Each object contains:\n   *\n   * attributeName:\n   *   Used when rendering markup or with `*Attribute()`.\n   * attributeNamespace\n   * propertyName:\n   *   Used on DOM node instances. (This includes properties that mutate due to\n   *   external factors.)\n   * mutationMethod:\n   *   If non-null, used instead of the property or `setAttribute()` after\n   *   initial render.\n   * mustUseAttribute:\n   *   Whether the property must be accessed and mutated using `*Attribute()`.\n   *   (This includes anything that fails `<propName> in <element>`.)\n   * mustUseProperty:\n   *   Whether the property must be accessed and mutated as an object property.\n   * hasSideEffects:\n   *   Whether or not setting a value causes side effects such as triggering\n   *   resources to be loaded or text selection changes. If true, we read from\n   *   the DOM before updating to ensure that the value is only set if it has\n   *   changed.\n   * hasBooleanValue:\n   *   Whether the property should be removed when set to a falsey value.\n   * hasNumericValue:\n   *   Whether the property must be numeric or parse as a numeric and should be\n   *   removed when set to a falsey value.\n   * hasPositiveNumericValue:\n   *   Whether the property must be positive numeric or parse as a positive\n   *   numeric and should be removed when set to a falsey value.\n   * hasOverloadedBooleanValue:\n   *   Whether the property can be used as a flag as well as with a value.\n   *   Removed when strictly equal to false; present without a value when\n   *   strictly equal to true; present with a value otherwise.\n   */\n  properties: {},\n\n  /**\n   * Mapping from lowercase property names to the properly cased version, used\n   * to warn in the case of missing properties. Available only in __DEV__.\n   * @type {Object}\n   */\n  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,\n\n  /**\n   * All of the isCustomAttribute() functions that have been injected.\n   */\n  _isCustomAttributeFunctions: [],\n\n  /**\n   * Checks whether a property name is a custom attribute.\n   * @method\n   */\n  isCustomAttribute: function (attributeName) {\n    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {\n      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];\n      if (isCustomAttributeFn(attributeName)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns the default property value for a DOM property (i.e., not an\n   * attribute). Most default values are '' or false, but not all. Worse yet,\n   * some (in particular, `type`) vary depending on the type of element.\n   *\n   * TODO: Is it better to grab all the possible properties when creating an\n   * element to avoid having to create the same element twice?\n   */\n  getDefaultValueForProperty: function (nodeName, prop) {\n    var nodeDefaults = defaultValueCache[nodeName];\n    var testElement;\n    if (!nodeDefaults) {\n      defaultValueCache[nodeName] = nodeDefaults = {};\n    }\n    if (!(prop in nodeDefaults)) {\n      testElement = document.createElement(nodeName);\n      nodeDefaults[prop] = testElement[prop];\n    }\n    return nodeDefaults[prop];\n  },\n\n  injection: DOMPropertyInjection\n};\n\nmodule.exports = DOMProperty;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMProperty.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMProperty.js?");
},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconciler\n */\n\n'use strict';\n\nvar ReactRef = __webpack_require__(168);\n\n/**\n * Helper to call ReactRef.attachRefs with this composite component, split out\n * to avoid allocations in the transaction mount-ready queue.\n */\nfunction attachRefs() {\n  ReactRef.attachRefs(this, this._currentElement);\n}\n\nvar ReactReconciler = {\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (internalInstance, rootID, transaction, context) {\n    var markup = internalInstance.mountComponent(rootID, transaction, context);\n    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function (internalInstance) {\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\n    internalInstance.unmountComponent();\n  },\n\n  /**\n   * Update a component using a new element.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @internal\n   */\n  receiveComponent: function (internalInstance, nextElement, transaction, context) {\n    var prevElement = internalInstance._currentElement;\n\n    if (nextElement === prevElement && context === internalInstance._context) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for an element created outside a composite to be\n      // deeply mutated and reused.\n\n      // TODO: Bailing out early is just a perf optimization right?\n      // TODO: Removing the return statement should affect correctness?\n      return;\n    }\n\n    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);\n\n    if (refsChanged) {\n      ReactRef.detachRefs(internalInstance, prevElement);\n    }\n\n    internalInstance.receiveComponent(nextElement, transaction, context);\n\n    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n  },\n\n  /**\n   * Flush any dirty changes in a component.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (internalInstance, transaction) {\n    internalInstance.performUpdateIfNecessary(transaction);\n  }\n\n};\n\nmodule.exports = ReactReconciler;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactReconciler.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactReconciler.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(14);\n\nvar assign = __webpack_require__(3);\nvar emptyFunction = __webpack_require__(10);\nvar warning = __webpack_require__(4);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n */\nfunction SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  this.dispatchConfig = dispatchConfig;\n  this.dispatchMarker = dispatchMarker;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n}\n\nassign(SyntheticEvent.prototype, {\n\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\\'re ' + 'seeing this, you\\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;\n    }\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\\'re ' + 'seeing this, you\\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;\n    }\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      this[propName] = null;\n    }\n    this.dispatchConfig = null;\n    this.dispatchMarker = null;\n    this.nativeEvent = null;\n  }\n\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var prototype = Object.create(Super.prototype);\n  assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n\n  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);\n};\n\nPooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);\n\nmodule.exports = SyntheticEvent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticEvent.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticEvent.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(147);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/react.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/react.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactRootIndex = __webpack_require__(90);\n\nvar invariant = __webpack_require__(2);\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 10000;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;\n  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {*} arg Argument to invoke the callback with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;\n  var traverseUp = isAncestorIDOf(stop, start);\n  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start;; /* until break */id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function () {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function (rootID, name) {\n    return rootID + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function (id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Same as `traverseTwoPhase` but skips the `targetID`.\n   */\n  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, true);\n      traverseParentPath(targetID, '', cb, arg, true, true);\n    }\n  },\n\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function (targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n\n  getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInstanceHandles.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInstanceHandles.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyObject\n */\n\n'use strict';\n\nvar emptyObject = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/emptyObject.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/emptyObject.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginHub\n */\n\n'use strict';\n\nvar EventPluginRegistry = __webpack_require__(70);\nvar EventPluginUtils = __webpack_require__(144);\nvar ReactErrorUtils = __webpack_require__(83);\n\nvar accumulateInto = __webpack_require__(92);\nvar forEachAccumulated = __webpack_require__(93);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\n/**\n * Internal store for event listeners\n */\nvar listenerBank = {};\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    EventPluginUtils.executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\n/**\n * - `InstanceHandle`: [required] Module that performs logical traversals of DOM\n *   hierarchy given ids of the logical DOM elements involved.\n */\nvar InstanceHandle = null;\n\nfunction validateInstanceHandle() {\n  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;\n  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n\n    /**\n     * @param {object} InjectedMount\n     * @public\n     */\n    injectMount: EventPluginUtils.injection.injectMount,\n\n    /**\n     * @param {object} InjectedInstanceHandle\n     * @public\n     */\n    injectInstanceHandle: function (InjectedInstanceHandle) {\n      InstanceHandle = InjectedInstanceHandle;\n      if (process.env.NODE_ENV !== 'production') {\n        validateInstanceHandle();\n      }\n    },\n\n    getInstanceHandle: function () {\n      if (process.env.NODE_ENV !== 'production') {\n        validateInstanceHandle();\n      }\n      return InstanceHandle;\n    },\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n\n  },\n\n  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginRegistry.registrationNameModules,\n\n  /**\n   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {?function} listener The callback to store.\n   */\n  putListener: function (id, registrationName, listener) {\n    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;\n\n    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});\n    bankForRegistrationName[id] = listener;\n\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n    if (PluginModule && PluginModule.didPutListener) {\n      PluginModule.didPutListener(id, registrationName, listener);\n    }\n  },\n\n  /**\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n  getListener: function (id, registrationName) {\n    var bankForRegistrationName = listenerBank[registrationName];\n    return bankForRegistrationName && bankForRegistrationName[id];\n  },\n\n  /**\n   * Deletes a listener from the registration bank.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   */\n  deleteListener: function (id, registrationName) {\n    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n    if (PluginModule && PluginModule.willDeleteListener) {\n      PluginModule.willDeleteListener(id, registrationName);\n    }\n\n    var bankForRegistrationName = listenerBank[registrationName];\n    // TODO: This should never be null -- when is it?\n    if (bankForRegistrationName) {\n      delete bankForRegistrationName[id];\n    }\n  },\n\n  /**\n   * Deletes all listeners for the DOM element with the supplied ID.\n   *\n   * @param {string} id ID of the DOM element.\n   */\n  deleteAllListeners: function (id) {\n    for (var registrationName in listenerBank) {\n      if (!listenerBank[registrationName][id]) {\n        continue;\n      }\n\n      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];\n      if (PluginModule && PluginModule.willDeleteListener) {\n        PluginModule.willDeleteListener(id, registrationName);\n      }\n\n      delete listenerBank[registrationName][id];\n    }\n  },\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n    for (var i = 0; i < plugins.length; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);\n        if (extractedEvents) {\n          events = accumulateInto(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function (events) {\n    if (events) {\n      eventQueue = accumulateInto(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function (simulated) {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    if (simulated) {\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n    } else {\n      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n    }\n    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;\n    // This would be a good time to rethrow if any of the event handlers threw.\n    ReactErrorUtils.rethrowCaughtError();\n  },\n\n  /**\n   * These are needed for tests only. Do not use!\n   */\n  __purge: function () {\n    listenerBank = {};\n  },\n\n  __getListenerBank: function () {\n    return listenerBank;\n  }\n\n};\n\nmodule.exports = EventPluginHub;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginHub.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginHub.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPluginHub = __webpack_require__(21);\n\nvar warning = __webpack_require__(4);\n\nvar accumulateInto = __webpack_require__(92);\nvar forEachAccumulated = __webpack_require__(93);\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPropagators.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPropagators.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceMap\n */\n\n'use strict';\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n */\n\n// TODO: Replace this with ES6: var ReactInstanceMap = new Map();\nvar ReactInstanceMap = {\n\n  /**\n   * This API should be called `delete` but we'd have to make sure to always\n   * transform these to strings for IE support. When this transform is fully\n   * supported we can rename it.\n   */\n  remove: function (key) {\n    key._reactInternalInstance = undefined;\n  },\n\n  get: function (key) {\n    return key._reactInternalInstance;\n  },\n\n  has: function (key) {\n    return key._reactInternalInstance !== undefined;\n  },\n\n  set: function (key, value) {\n    key._reactInternalInstance = value;\n  }\n\n};\n\nmodule.exports = ReactInstanceMap;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInstanceMap.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInstanceMap.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticUIEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(17);\n\nvar getEventTarget = __webpack_require__(52);\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: function (event) {\n    if (event.view) {\n      return event.view;\n    }\n\n    var target = getEventTarget(event);\n    if (target != null && target.window === target) {\n      // target is a window object\n      return target;\n    }\n\n    var doc = target.ownerDocument;\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    if (doc) {\n      return doc.defaultView || doc.parentWindow;\n    } else {\n      return window;\n    }\n  },\n  detail: function (event) {\n    return event.detail || 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);\n\nmodule.exports = SyntheticUIEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticUIEvent.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticUIEvent.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyMirror\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Constructs an enumeration with keys equal to their value.\n *\n * For example:\n *\n *   var COLORS = keyMirror({blue: null, red: null});\n *   var myColor = COLORS.blue;\n *   var isColorValid = !!COLORS[myColor];\n *\n * The last line could not be performed if the values of the generated enum were\n * not equal to their keys.\n *\n *   Input:  {key1: val1, key2: val2}\n *   Output: {key1: key1, key2: key2}\n *\n * @param {object} obj\n * @return {object}\n */\nvar keyMirror = function (obj) {\n  var ret = {};\n  var key;\n  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    }\n    ret[key] = key;\n  }\n  return ret;\n};\n\nmodule.exports = keyMirror;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/keyMirror.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/keyMirror.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserEventEmitter\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPluginHub = __webpack_require__(21);\nvar EventPluginRegistry = __webpack_require__(70);\nvar ReactEventEmitterMixin = __webpack_require__(161);\nvar ReactPerf = __webpack_require__(8);\nvar ViewportMetrics = __webpack_require__(91);\n\nvar assign = __webpack_require__(3);\nvar isEventSupported = __webpack_require__(55);\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactEventListener, which is injected and can therefore support pluggable\n *    event sources. This is the only work that occurs in the main thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar isMonitoringScrollValue = false;\nvar reactTopListenersCounter = 0;\n\n// For events like 'submit' which don't consistently bubble (which we trap at a\n// lower node than `document`), binding at `document` would cause duplicate\n// events so we don't include them here\nvar topEventMapping = {\n  topAbort: 'abort',\n  topBlur: 'blur',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topChange: 'change',\n  topClick: 'click',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topScroll: 'scroll',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topSelectionChange: 'selectionchange',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTextInput: 'textInput',\n  topTimeUpdate: 'timeupdate',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting',\n  topWheel: 'wheel'\n};\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For\n * example:\n *\n *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);\n *\n * This would allocate a \"registration\" of `('onClick', myFunction)` on 'myID'.\n *\n * @internal\n */\nvar ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {\n\n  /**\n   * Injectable event backend\n   */\n  ReactEventListener: null,\n\n  injection: {\n    /**\n     * @param {object} ReactEventListener\n     */\n    injectReactEventListener: function (ReactEventListener) {\n      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);\n      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;\n    }\n  },\n\n  /**\n   * Sets whether or not any created callbacks should be enabled.\n   *\n   * @param {boolean} enabled True if callbacks should be enabled.\n   */\n  setEnabled: function (enabled) {\n    if (ReactBrowserEventEmitter.ReactEventListener) {\n      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);\n    }\n  },\n\n  /**\n   * @return {boolean} True if callbacks are enabled.\n   */\n  isEnabled: function () {\n    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());\n  },\n\n  /**\n   * We listen for bubbled touch events on the document object.\n   *\n   * Firefox v8.01 (and possibly others) exhibited strange behavior when\n   * mounting `onmousemove` events at some node that was not the document\n   * element. The symptoms were that if your mouse is not moving over something\n   * contained within that mount point (for example on the background) the\n   * top-level listeners for `onmousemove` won't be called. However, if you\n   * register the `mousemove` on the document object, then it will of course\n   * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n   * top-level listeners to the document object only, at least for these\n   * movement types of events and possibly all events.\n   *\n   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   *\n   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n   * they bubble to document.\n   *\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {object} contentDocumentHandle Document which owns the container\n   */\n  listenTo: function (registrationName, contentDocumentHandle) {\n    var mountAt = contentDocumentHandle;\n    var isListening = getListeningForDocument(mountAt);\n    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];\n\n    var topLevelTypes = EventConstants.topLevelTypes;\n    for (var i = 0; i < dependencies.length; i++) {\n      var dependency = dependencies[i];\n      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n        if (dependency === topLevelTypes.topWheel) {\n          if (isEventSupported('wheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);\n          } else if (isEventSupported('mousewheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);\n          } else {\n            // Firefox needs to capture a different mouse scroll event.\n            // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);\n          }\n        } else if (dependency === topLevelTypes.topScroll) {\n\n          if (isEventSupported('scroll', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);\n          } else {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);\n          }\n        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {\n\n          if (isEventSupported('focus', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);\n          } else if (isEventSupported('focusin')) {\n            // IE has `focusin` and `focusout` events which bubble.\n            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);\n          }\n\n          // to make sure blur and focus event listeners are only attached once\n          isListening[topLevelTypes.topBlur] = true;\n          isListening[topLevelTypes.topFocus] = true;\n        } else if (topEventMapping.hasOwnProperty(dependency)) {\n          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);\n        }\n\n        isListening[dependency] = true;\n      }\n    }\n  },\n\n  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);\n  },\n\n  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);\n  },\n\n  /**\n   * Listens to window scroll and resize events. We cache scroll values so that\n   * application code can access them without triggering reflows.\n   *\n   * NOTE: Scroll events do not bubble.\n   *\n   * @see http://www.quirksmode.org/dom/events/scroll.html\n   */\n  ensureScrollValueMonitoring: function () {\n    if (!isMonitoringScrollValue) {\n      var refresh = ViewportMetrics.refreshScrollValues;\n      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);\n      isMonitoringScrollValue = true;\n    }\n  },\n\n  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginHub.registrationNameModules,\n\n  putListener: EventPluginHub.putListener,\n\n  getListener: EventPluginHub.getListener,\n\n  deleteListener: EventPluginHub.deleteListener,\n\n  deleteAllListeners: EventPluginHub.deleteAllListeners\n\n});\n\nReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {\n  putListener: 'putListener',\n  deleteListener: 'deleteListener'\n});\n\nmodule.exports = ReactBrowserEventEmitter;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserEventEmitter.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserEventEmitter.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocationNames\n */\n\n'use strict';\n\nvar ReactPropTypeLocationNames = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  ReactPropTypeLocationNames = {\n    prop: 'prop',\n    context: 'context',\n    childContext: 'child context'\n  };\n}\n\nmodule.exports = ReactPropTypeLocationNames;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocationNames.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocationNames.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocations\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(25);\n\nvar ReactPropTypeLocations = keyMirror({\n  prop: null,\n  context: null,\n  childContext: null\n});\n\nmodule.exports = ReactPropTypeLocations;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocations.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocations.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticMouseEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(24);\nvar ViewportMetrics = __webpack_require__(91);\n\nvar getEventModifierState = __webpack_require__(51);\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: function (event) {\n    // Webkit, Firefox, IE9+\n    // which:  1 2 3\n    // button: 0 1 2 (standard)\n    var button = event.button;\n    if ('which' in event) {\n      return button;\n    }\n    // IE<9\n    // which:  undefined\n    // button: 0 0 0\n    // button: 1 4 2 (onmouseup)\n    return button === 2 ? 2 : button === 4 ? 1 : 0;\n  },\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  },\n  // \"Proprietary\" Interface.\n  pageX: function (event) {\n    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;\n  },\n  pageY: function (event) {\n    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nmodule.exports = SyntheticMouseEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticMouseEvent.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticMouseEvent.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Transaction\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * `Transaction` creates a black box that is able to wrap any method such that\n * certain invariants are maintained before and after the method is invoked\n * (Even if an exception is thrown while invoking the wrapped method). Whoever\n * instantiates a transaction can provide enforcers of the invariants at\n * creation time. The `Transaction` class itself will supply one additional\n * automatic invariant for you - the invariant that any transaction instance\n * should not be run while it is already being run. You would typically create a\n * single instance of a `Transaction` for reuse multiple times, that potentially\n * is used to wrap several different methods. Wrappers are extremely simple -\n * they only require implementing two methods.\n *\n * <pre>\n *                       wrappers (injected at creation time)\n *                                      +        +\n *                                      |        |\n *                    +-----------------|--------|--------------+\n *                    |                 v        |              |\n *                    |      +---------------+   |              |\n *                    |   +--|    wrapper1   |---|----+         |\n *                    |   |  +---------------+   v    |         |\n *                    |   |          +-------------+  |         |\n *                    |   |     +----|   wrapper2  |--------+   |\n *                    |   |     |    +-------------+  |     |   |\n *                    |   |     |                     |     |   |\n *                    |   v     v                     v     v   | wrapper\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | +---+ +---+   +---------+   +---+ +---+ |\n *                    |  initialize                    close    |\n *                    +-----------------------------------------+\n * </pre>\n *\n * Use cases:\n * - Preserving the input selection ranges before/after reconciliation.\n *   Restoring selection even in the event of an unexpected error.\n * - Deactivating events while rearranging the DOM, preventing blurs/focuses,\n *   while guaranteeing that afterwards, the event system is reactivated.\n * - Flushing a queue of collected DOM mutations to the main UI thread after a\n *   reconciliation takes place in a worker thread.\n * - Invoking any collected `componentDidUpdate` callbacks after rendering new\n *   content.\n * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue\n *   to preserve the `scrollTop` (an automatic scroll aware DOM).\n * - (Future use case): Layout calculations before and after DOM updates.\n *\n * Transactional plugin API:\n * - A module that has an `initialize` method that returns any precomputation.\n * - and a `close` method that accepts the precomputation. `close` is invoked\n *   when the wrapped process is completed, or has failed.\n *\n * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules\n * that implement `initialize` and `close`.\n * @return {Transaction} Single transaction for reuse in thread.\n *\n * @class Transaction\n */\nvar Mixin = {\n  /**\n   * Sets up this instance so that it is prepared for collecting metrics. Does\n   * so such that this setup method may be used on an instance that is already\n   * initialized, in a way that does not consume additional memory upon reuse.\n   * That can be useful if you decide to make your subclass of this mixin a\n   * \"PooledClass\".\n   */\n  reinitializeTransaction: function () {\n    this.transactionWrappers = this.getTransactionWrappers();\n    if (this.wrapperInitData) {\n      this.wrapperInitData.length = 0;\n    } else {\n      this.wrapperInitData = [];\n    }\n    this._isInTransaction = false;\n  },\n\n  _isInTransaction: false,\n\n  /**\n   * @abstract\n   * @return {Array<TransactionWrapper>} Array of transaction wrappers.\n   */\n  getTransactionWrappers: null,\n\n  isInTransaction: function () {\n    return !!this._isInTransaction;\n  },\n\n  /**\n   * Executes the function within a safety window. Use this for the top level\n   * methods that result in large amounts of computation/mutations that would\n   * need to be safety checked. The optional arguments helps prevent the need\n   * to bind in many cases.\n   *\n   * @param {function} method Member of scope to call.\n   * @param {Object} scope Scope to invoke from.\n   * @param {Object?=} a Argument to pass to the method.\n   * @param {Object?=} b Argument to pass to the method.\n   * @param {Object?=} c Argument to pass to the method.\n   * @param {Object?=} d Argument to pass to the method.\n   * @param {Object?=} e Argument to pass to the method.\n   * @param {Object?=} f Argument to pass to the method.\n   *\n   * @return {*} Return value from `method`.\n   */\n  perform: function (method, scope, a, b, c, d, e, f) {\n    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;\n    var errorThrown;\n    var ret;\n    try {\n      this._isInTransaction = true;\n      // Catching errors makes debugging more difficult, so we start with\n      // errorThrown set to true before setting it to false after calling\n      // close -- if it's still set to true in the finally block, it means\n      // one of these calls threw.\n      errorThrown = true;\n      this.initializeAll(0);\n      ret = method.call(scope, a, b, c, d, e, f);\n      errorThrown = false;\n    } finally {\n      try {\n        if (errorThrown) {\n          // If `method` throws, prefer to show that stack trace over any thrown\n          // by invoking `closeAll`.\n          try {\n            this.closeAll(0);\n          } catch (err) {}\n        } else {\n          // Since `method` didn't throw, we don't want to silence the exception\n          // here.\n          this.closeAll(0);\n        }\n      } finally {\n        this._isInTransaction = false;\n      }\n    }\n    return ret;\n  },\n\n  initializeAll: function (startIndex) {\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      try {\n        // Catching errors makes debugging more difficult, so we start with the\n        // OBSERVED_ERROR state before overwriting it with the real return value\n        // of initialize -- if it's still set to OBSERVED_ERROR in the finally\n        // block, it means wrapper.initialize threw.\n        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;\n        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;\n      } finally {\n        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {\n          // The initializer for wrapper i threw an error; initialize the\n          // remaining wrappers but silence any exceptions from them to ensure\n          // that the first error is the one to bubble up.\n          try {\n            this.initializeAll(i + 1);\n          } catch (err) {}\n        }\n      }\n    }\n  },\n\n  /**\n   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into\n   * them the respective return values of `this.transactionWrappers.init[i]`\n   * (`close`rs that correspond to initializers that failed will not be\n   * invoked).\n   */\n  closeAll: function (startIndex) {\n    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      var initData = this.wrapperInitData[i];\n      var errorThrown;\n      try {\n        // Catching errors makes debugging more difficult, so we start with\n        // errorThrown set to true before setting it to false after calling\n        // close -- if it's still set to true in the finally block, it means\n        // wrapper.close threw.\n        errorThrown = true;\n        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {\n          wrapper.close.call(this, initData);\n        }\n        errorThrown = false;\n      } finally {\n        if (errorThrown) {\n          // The closer for wrapper i threw an error; close the remaining\n          // wrappers but silence any exceptions from them to ensure that the\n          // first error is the one to bubble up.\n          try {\n            this.closeAll(i + 1);\n          } catch (e) {}\n        }\n      }\n    }\n    this.wrapperInitData.length = 0;\n  }\n};\n\nvar Transaction = {\n\n  Mixin: Mixin,\n\n  /**\n   * Token to look for to determine if an error occurred.\n   */\n  OBSERVED_ERROR: {}\n\n};\n\nmodule.exports = Transaction;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Transaction.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Transaction.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule canDefineProperty\n */\n\n'use strict';\n\nvar canDefineProperty = false;\nif (process.env.NODE_ENV !== 'production') {\n  try {\n    Object.defineProperty({}, 'x', { get: function () {} });\n    canDefineProperty = true;\n  } catch (x) {\n    // IE will fail on defineProperty\n  }\n}\n\nmodule.exports = canDefineProperty;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/canDefineProperty.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/canDefineProperty.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule escapeTextContentForBrowser\n */\n\n'use strict';\n\nvar ESCAPE_LOOKUP = {\n  '&': '&amp;',\n  '>': '&gt;',\n  '<': '&lt;',\n  '\"': '&quot;',\n  '\\'': '&#x27;'\n};\n\nvar ESCAPE_REGEX = /[&><\"']/g;\n\nfunction escaper(match) {\n  return ESCAPE_LOOKUP[match];\n}\n\n/**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */\nfunction escapeTextContentForBrowser(text) {\n  return ('' + text).replace(ESCAPE_REGEX, escaper);\n}\n\nmodule.exports = escapeTextContentForBrowser;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/escapeTextContentForBrowser.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/escapeTextContentForBrowser.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setInnerHTML\n */\n\n/* globals MSApp */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = function (node, html) {\n  node.innerHTML = html;\n};\n\n// Win8 apps: Allow all html to be inserted\nif (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n  setInnerHTML = function (node, html) {\n    MSApp.execUnsafeLocalFunction(function () {\n      node.innerHTML = html;\n    });\n  };\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function (node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode\n        // in hopes that this is preserved even if \"\\uFEFF\" is transformed to\n        // the actual Unicode character (by Babel, for example).\n        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216\n        node.innerHTML = String.fromCharCode(0xFEFF) + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n}\n\nmodule.exports = setInnerHTML;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/setInnerHTML.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/setInnerHTML.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '74' };\r\n\r\n//\r\n\r\nif ( true ) {\r\n\r\n	!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\r\n	module.exports = THREE;\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Number.EPSILON === undefined ) {\r\n\r\n	Number.EPSILON = Math.pow( 2, - 52 );\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n	Math.sign = function ( x ) {\r\n\r\n		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\r\n	};\r\n\r\n}\r\n\r\nif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\r\n	// Missing in IE9-11.\r\n	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\r\n	Object.defineProperty( Function.prototype, 'name', {\r\n\r\n		get: function () {\r\n\r\n			return this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\r\n		}\r\n\r\n	} );\r\n\r\n}\r\n\r\nif ( Object.assign === undefined ) {\r\n\r\n	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\r\n	Object.defineProperty( Object, 'assign', {\r\n\r\n		writable: true,\r\n		configurable: true,\r\n\r\n		value: function ( target ) {\r\n\r\n			'use strict';\r\n\r\n			if ( target === undefined || target === null ) {\r\n\r\n				throw new TypeError( \"Cannot convert first argument to object\" );\r\n\r\n			}\r\n\r\n			var to = Object( target );\r\n\r\n			for ( var i = 1, n = arguments.length; i !== n; ++ i ) {\r\n\r\n				var nextSource = arguments[ i ];\r\n\r\n				if ( nextSource === undefined || nextSource === null ) continue;\r\n\r\n				nextSource = Object( nextSource );\r\n\r\n				var keysArray = Object.keys( nextSource );\r\n\r\n				for ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {\r\n\r\n					var nextKey = keysArray[ nextIndex ];\r\n					var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n\r\n					if ( desc !== undefined && desc.enumerable ) {\r\n\r\n						to[ nextKey ] = nextSource[ nextKey ];\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return to;\r\n\r\n		}\r\n\r\n	} );\r\n\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n// mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n// depth modes\r\n\r\nTHREE.NeverDepth = 0;\r\nTHREE.AlwaysDepth = 1;\r\nTHREE.LessDepth = 2;\r\nTHREE.LessEqualDepth = 3;\r\nTHREE.EqualDepth = 4;\r\nTHREE.GreaterEqualDepth = 5;\r\nTHREE.GreaterDepth = 6;\r\nTHREE.NotEqualDepth = 7;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n// ETC compressed texture formats\r\n\r\nTHREE.RGB_ETC1_Format = 2151;\r\n\r\n// Loop styles for AnimationAction\r\n\r\nTHREE.LoopOnce = 2200;\r\nTHREE.LoopRepeat = 2201;\r\nTHREE.LoopPingPong = 2202;\r\n\r\n// Interpolation\r\n\r\nTHREE.InterpolateDiscrete = 2300;\r\nTHREE.InterpolateLinear = 2301;\r\nTHREE.InterpolateSmooth = 2302;\r\n\r\n// Interpolant ending modes\r\n\r\nTHREE.ZeroCurvatureEnding = 2400;\r\nTHREE.ZeroSlopeEnding = 2401;\r\nTHREE.WrapAroundEnding = 2402;\r\n\r\n// Triangle Draw modes\r\n\r\nTHREE.TrianglesDrawMode = 0;\r\nTHREE.TriangleStripDrawMode = 1;\r\nTHREE.TriangleFanDrawMode = 2;\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n	if ( arguments.length === 3 ) {\r\n\r\n		return this.fromArray( arguments );\r\n\r\n	}\r\n\r\n	return this.set( color );\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n	constructor: THREE.Color,\r\n\r\n	r: 1, g: 1, b: 1,\r\n\r\n	set: function ( value ) {\r\n\r\n		if ( value instanceof THREE.Color ) {\r\n\r\n			this.copy( value );\r\n\r\n		} else if ( typeof value === 'number' ) {\r\n\r\n			this.setHex( value );\r\n\r\n		} else if ( typeof value === 'string' ) {\r\n\r\n			this.setStyle( value );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setScalar: function ( scalar ) {\r\n\r\n		this.r = scalar;\r\n		this.g = scalar;\r\n		this.b = scalar;\r\n\r\n	},\r\n\r\n	setHex: function ( hex ) {\r\n\r\n		hex = Math.floor( hex );\r\n\r\n		this.r = ( hex >> 16 & 255 ) / 255;\r\n		this.g = ( hex >> 8 & 255 ) / 255;\r\n		this.b = ( hex & 255 ) / 255;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setRGB: function ( r, g, b ) {\r\n\r\n		this.r = r;\r\n		this.g = g;\r\n		this.b = b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setHSL: function () {\r\n\r\n		function hue2rgb( p, q, t ) {\r\n\r\n			if ( t < 0 ) t += 1;\r\n			if ( t > 1 ) t -= 1;\r\n			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n			if ( t < 1 / 2 ) return q;\r\n			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n			return p;\r\n\r\n		}\r\n\r\n		return function ( h, s, l ) {\r\n\r\n			// h,s,l ranges are in 0.0 - 1.0\r\n			h = THREE.Math.euclideanModulo( h, 1 );\r\n			s = THREE.Math.clamp( s, 0, 1 );\r\n			l = THREE.Math.clamp( l, 0, 1 );\r\n\r\n			if ( s === 0 ) {\r\n\r\n				this.r = this.g = this.b = l;\r\n\r\n			} else {\r\n\r\n				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n				var q = ( 2 * l ) - p;\r\n\r\n				this.r = hue2rgb( q, p, h + 1 / 3 );\r\n				this.g = hue2rgb( q, p, h );\r\n				this.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n			}\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setStyle: function ( style ) {\r\n\r\n		function handleAlpha( string ) {\r\n\r\n			if ( string === undefined ) return;\r\n\r\n			if ( parseFloat( string ) < 1 ) {\r\n\r\n				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		var m;\r\n\r\n		if ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n			// rgb / hsl\r\n\r\n			var color;\r\n			var name = m[ 1 ];\r\n			var components = m[ 2 ];\r\n\r\n			switch ( name ) {\r\n\r\n				case 'rgb':\r\n				case 'rgba':\r\n\r\n					if ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n						// rgb(255,0,0) rgba(255,0,0,0.5)\r\n						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n						handleAlpha( color[ 5 ] );\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					if ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n						handleAlpha( color[ 5 ] );\r\n\r\n						return this;\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'hsl':\r\n				case 'hsla':\r\n\r\n					if ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n						var h = parseFloat( color[ 1 ] ) / 360;\r\n						var s = parseInt( color[ 2 ], 10 ) / 100;\r\n						var l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n						handleAlpha( color[ 5 ] );\r\n\r\n						return this.setHSL( h, s, l );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n			}\r\n\r\n		} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n			// hex color\r\n\r\n			var hex = m[ 1 ];\r\n			var size = hex.length;\r\n\r\n			if ( size === 3 ) {\r\n\r\n				// #ff0\r\n				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n				return this;\r\n\r\n			} else if ( size === 6 ) {\r\n\r\n				// #ff0000\r\n				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n				return this;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( style && style.length > 0 ) {\r\n\r\n			// color keywords\r\n			var hex = THREE.ColorKeywords[ style ];\r\n\r\n			if ( hex !== undefined ) {\r\n\r\n				// red\r\n				this.setHex( hex );\r\n\r\n			} else {\r\n\r\n				// unknown color\r\n				console.warn( 'THREE.Color: Unknown color ' + style );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.r, this.g, this.b );\r\n\r\n	},\r\n\r\n	copy: function ( color ) {\r\n\r\n		this.r = color.r;\r\n		this.g = color.g;\r\n		this.b = color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n		if ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n		this.r = Math.pow( color.r, gammaFactor );\r\n		this.g = Math.pow( color.g, gammaFactor );\r\n		this.b = Math.pow( color.b, gammaFactor );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n		if ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n		this.r = Math.pow( color.r, safeInverse );\r\n		this.g = Math.pow( color.g, safeInverse );\r\n		this.b = Math.pow( color.b, safeInverse );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertGammaToLinear: function () {\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		this.r = r * r;\r\n		this.g = g * g;\r\n		this.b = b * b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertLinearToGamma: function () {\r\n\r\n		this.r = Math.sqrt( this.r );\r\n		this.g = Math.sqrt( this.g );\r\n		this.b = Math.sqrt( this.b );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getHex: function () {\r\n\r\n		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n	},\r\n\r\n	getHexString: function () {\r\n\r\n		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n	},\r\n\r\n	getHSL: function ( optionalTarget ) {\r\n\r\n		// h,s,l ranges are in 0.0 - 1.0\r\n\r\n		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		var max = Math.max( r, g, b );\r\n		var min = Math.min( r, g, b );\r\n\r\n		var hue, saturation;\r\n		var lightness = ( min + max ) / 2.0;\r\n\r\n		if ( min === max ) {\r\n\r\n			hue = 0;\r\n			saturation = 0;\r\n\r\n		} else {\r\n\r\n			var delta = max - min;\r\n\r\n			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n			switch ( max ) {\r\n\r\n				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n				case g: hue = ( b - r ) / delta + 2; break;\r\n				case b: hue = ( r - g ) / delta + 4; break;\r\n\r\n			}\r\n\r\n			hue /= 6;\r\n\r\n		}\r\n\r\n		hsl.h = hue;\r\n		hsl.s = saturation;\r\n		hsl.l = lightness;\r\n\r\n		return hsl;\r\n\r\n	},\r\n\r\n	getStyle: function () {\r\n\r\n		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n	},\r\n\r\n	offsetHSL: function ( h, s, l ) {\r\n\r\n		var hsl = this.getHSL();\r\n\r\n		hsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n		this.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( color ) {\r\n\r\n		this.r += color.r;\r\n		this.g += color.g;\r\n		this.b += color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addColors: function ( color1, color2 ) {\r\n\r\n		this.r = color1.r + color2.r;\r\n		this.g = color1.g + color2.g;\r\n		this.b = color1.b + color2.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.r += s;\r\n		this.g += s;\r\n		this.b += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( color ) {\r\n\r\n		this.r *= color.r;\r\n		this.g *= color.g;\r\n		this.b *= color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		this.r *= s;\r\n		this.g *= s;\r\n		this.b *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( color, alpha ) {\r\n\r\n		this.r += ( color.r - this.r ) * alpha;\r\n		this.g += ( color.g - this.g ) * alpha;\r\n		this.b += ( color.b - this.b ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( c ) {\r\n\r\n		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.r = array[ offset ];\r\n		this.g = array[ offset + 1 ];\r\n		this.b = array[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.r;\r\n		array[ offset + 1 ] = this.g;\r\n		array[ offset + 2 ] = this.b;\r\n\r\n		return array;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n	constructor: THREE.Quaternion,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get w () {\r\n\r\n		return this._w;\r\n\r\n	},\r\n\r\n	set w ( value ) {\r\n\r\n		this._w = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._w = w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n	},\r\n\r\n	copy: function ( quaternion ) {\r\n\r\n		this._x = quaternion.x;\r\n		this._y = quaternion.y;\r\n		this._z = quaternion.z;\r\n		this._w = quaternion.w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromEuler: function ( euler, update ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n		}\r\n\r\n		// http://www.mathworks.com/matlabcentral/fileexchange/\r\n		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n		//	content/SpinCalc.m\r\n\r\n		var c1 = Math.cos( euler._x / 2 );\r\n		var c2 = Math.cos( euler._y / 2 );\r\n		var c3 = Math.cos( euler._z / 2 );\r\n		var s1 = Math.sin( euler._x / 2 );\r\n		var s2 = Math.sin( euler._y / 2 );\r\n		var s3 = Math.sin( euler._z / 2 );\r\n\r\n		var order = euler.order;\r\n\r\n		if ( order === 'XYZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'YXZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( order === 'ZXY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'ZYX' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( order === 'YZX' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( order === 'XZY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		}\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n		// assumes axis is normalized\r\n\r\n		var halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n		this._x = axis.x * s;\r\n		this._y = axis.y * s;\r\n		this._z = axis.z * s;\r\n		this._w = Math.cos( halfAngle );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n			trace = m11 + m22 + m33,\r\n			s;\r\n\r\n		if ( trace > 0 ) {\r\n\r\n			s = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n			this._w = 0.25 / s;\r\n			this._x = ( m32 - m23 ) * s;\r\n			this._y = ( m13 - m31 ) * s;\r\n			this._z = ( m21 - m12 ) * s;\r\n\r\n		} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n			this._w = ( m32 - m23 ) / s;\r\n			this._x = 0.25 * s;\r\n			this._y = ( m12 + m21 ) / s;\r\n			this._z = ( m13 + m31 ) / s;\r\n\r\n		} else if ( m22 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n			this._w = ( m13 - m31 ) / s;\r\n			this._x = ( m12 + m21 ) / s;\r\n			this._y = 0.25 * s;\r\n			this._z = ( m23 + m32 ) / s;\r\n\r\n		} else {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n			this._w = ( m21 - m12 ) / s;\r\n			this._x = ( m13 + m31 ) / s;\r\n			this._y = ( m23 + m32 ) / s;\r\n			this._z = 0.25 * s;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromUnitVectors: function () {\r\n\r\n		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n		// assumes direction vectors vFrom and vTo are normalized\r\n\r\n		var v1, r;\r\n\r\n		var EPS = 0.000001;\r\n\r\n		return function ( vFrom, vTo ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			r = vFrom.dot( vTo ) + 1;\r\n\r\n			if ( r < EPS ) {\r\n\r\n				r = 0;\r\n\r\n				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n					v1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n				} else {\r\n\r\n					v1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				v1.crossVectors( vFrom, vTo );\r\n\r\n			}\r\n\r\n			this._x = v1.x;\r\n			this._y = v1.y;\r\n			this._z = v1.z;\r\n			this._w = r;\r\n\r\n			this.normalize();\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	inverse: function () {\r\n\r\n		this.conjugate().normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	conjugate: function () {\r\n\r\n		this._x *= - 1;\r\n		this._y *= - 1;\r\n		this._z *= - 1;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		var l = this.length();\r\n\r\n		if ( l === 0 ) {\r\n\r\n			this._x = 0;\r\n			this._y = 0;\r\n			this._z = 0;\r\n			this._w = 1;\r\n\r\n		} else {\r\n\r\n			l = 1 / l;\r\n\r\n			this._x = this._x * l;\r\n			this._y = this._y * l;\r\n			this._z = this._z * l;\r\n			this._w = this._w * l;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( q, p ) {\r\n\r\n		if ( p !== undefined ) {\r\n\r\n			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n			return this.multiplyQuaternions( q, p );\r\n\r\n		}\r\n\r\n		return this.multiplyQuaternions( this, q );\r\n\r\n	},\r\n\r\n	multiplyQuaternions: function ( a, b ) {\r\n\r\n		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	slerp: function ( qb, t ) {\r\n\r\n		if ( t === 0 ) return this;\r\n		if ( t === 1 ) return this.copy( qb );\r\n\r\n		var x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n		if ( cosHalfTheta < 0 ) {\r\n\r\n			this._w = - qb._w;\r\n			this._x = - qb._x;\r\n			this._y = - qb._y;\r\n			this._z = - qb._z;\r\n\r\n			cosHalfTheta = - cosHalfTheta;\r\n\r\n		} else {\r\n\r\n			this.copy( qb );\r\n\r\n		}\r\n\r\n		if ( cosHalfTheta >= 1.0 ) {\r\n\r\n			this._w = w;\r\n			this._x = x;\r\n			this._y = y;\r\n			this._z = z;\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n		if ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n			this._w = 0.5 * ( w + this._w );\r\n			this._x = 0.5 * ( x + this._x );\r\n			this._y = 0.5 * ( y + this._y );\r\n			this._z = 0.5 * ( z + this._z );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n		this._w = ( w * ratioA + this._w * ratioB );\r\n		this._x = ( x * ratioA + this._x * ratioB );\r\n		this._y = ( y * ratioA + this._y * ratioB );\r\n		this._z = ( z * ratioA + this._z * ratioB );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( quaternion ) {\r\n\r\n		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this._x = array[ offset ];\r\n		this._y = array[ offset + 1 ];\r\n		this._z = array[ offset + 2 ];\r\n		this._w = array[ offset + 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this._x;\r\n		array[ offset + 1 ] = this._y;\r\n		array[ offset + 2 ] = this._z;\r\n		array[ offset + 3 ] = this._w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {}\r\n\r\n};\r\n\r\nObject.assign( THREE.Quaternion, {\r\n\r\n	slerp: function( qa, qb, qm, t ) {\r\n\r\n		return qm.copy( qa ).slerp( qb, t );\r\n\r\n	},\r\n\r\n	slerpFlat: function(\r\n			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n		// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n		var x0 = src0[ srcOffset0 + 0 ],\r\n			y0 = src0[ srcOffset0 + 1 ],\r\n			z0 = src0[ srcOffset0 + 2 ],\r\n			w0 = src0[ srcOffset0 + 3 ],\r\n\r\n			x1 = src1[ srcOffset1 + 0 ],\r\n			y1 = src1[ srcOffset1 + 1 ],\r\n			z1 = src1[ srcOffset1 + 2 ],\r\n			w1 = src1[ srcOffset1 + 3 ];\r\n\r\n		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n			var s = 1 - t,\r\n\r\n				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n				dir = ( cos >= 0 ? 1 : - 1 ),\r\n				sqrSin = 1 - cos * cos;\r\n\r\n			// Skip the Slerp for tiny steps to avoid numeric problems:\r\n			if ( sqrSin > Number.EPSILON ) {\r\n\r\n				var sin = Math.sqrt( sqrSin ),\r\n					len = Math.atan2( sin, cos * dir );\r\n\r\n				s = Math.sin( s * len ) / sin;\r\n				t = Math.sin( t * len ) / sin;\r\n\r\n			}\r\n\r\n			var tDir = t * dir;\r\n\r\n			x0 = x0 * s + x1 * tDir;\r\n			y0 = y0 * s + y1 * tDir;\r\n			z0 = z0 * s + z1 * tDir;\r\n			w0 = w0 * s + w1 * tDir;\r\n\r\n			// Normalize in case we just did a lerp:\r\n			if ( s === 1 - t ) {\r\n\r\n				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n				x0 *= f;\r\n				y0 *= f;\r\n				z0 *= f;\r\n				w0 *= f;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		dst[ dstOffset ] = x0;\r\n		dst[ dstOffset + 1 ] = y0;\r\n		dst[ dstOffset + 2 ] = z0;\r\n		dst[ dstOffset + 3 ] = w0;\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n	constructor: THREE.Vector2,\r\n\r\n	get width() {\r\n\r\n		return this.x;\r\n\r\n	},\r\n\r\n	set width( value ) {\r\n\r\n		this.x = value;\r\n\r\n	},\r\n\r\n	get height() {\r\n\r\n		return this.y;\r\n\r\n	},\r\n\r\n	set height( value ) {\r\n\r\n		this.y = value;\r\n\r\n	},\r\n\r\n	//\r\n\r\n	set: function ( x, y ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setScalar: function ( scalar ) {\r\n\r\n		this.x = scalar;\r\n		this.y = scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v ) {\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		if ( isFinite( scalar ) ) {\r\n\r\n			this.x *= scalar;\r\n			this.y *= scalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		return this.multiplyScalar( 1 / scalar );\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		this.x = Math.min( this.x, v.x );\r\n		this.y = Math.min( this.y, v.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		this.x = Math.max( this.x, v.x );\r\n		this.y = Math.max( this.y, v.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		this.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n		this.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector2();\r\n				max = new THREE.Vector2();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal );\r\n			max.set( maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clampLength: function ( min, max ) {\r\n\r\n		var length = this.length();\r\n\r\n		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n	},\r\n\r\n	lengthManhattan: function() {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	angle: function () {\r\n\r\n		// computes the angle in radians with respect to the positive x-axis\r\n\r\n		var angle = Math.atan2( this.y, this.x );\r\n\r\n		if ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n		return angle;\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x, dy = this.y - v.y;\r\n		return dx * dx + dy * dy;\r\n\r\n	},\r\n\r\n	setLength: function ( length ) {\r\n\r\n		return this.multiplyScalar( length / this.length() );\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	rotateAround: function ( center, angle ) {\r\n\r\n		var c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n		var x = this.x - center.x;\r\n		var y = this.y - center.y;\r\n\r\n		this.x = x * c - y * s + center.x;\r\n		this.y = x * s + y * c + center.y;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n	constructor: THREE.Vector3,\r\n\r\n	set: function ( x, y, z ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setScalar: function ( scalar ) {\r\n\r\n		this.x = scalar;\r\n		this.y = scalar;\r\n		this.z = scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y, this.z );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n		this.z += v.z * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n		this.z -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n			return this.multiplyVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n		this.z *= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		if ( isFinite( scalar ) ) {\r\n\r\n			this.x *= scalar;\r\n			this.y *= scalar;\r\n			this.z *= scalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVectors: function ( a, b ) {\r\n\r\n		this.x = a.x * b.x;\r\n		this.y = a.y * b.y;\r\n		this.z = a.z * b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyEuler: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function applyEuler( euler ) {\r\n\r\n			if ( euler instanceof THREE.Euler === false ) {\r\n\r\n				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n			}\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyAxisAngle: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function applyAxisAngle( axis, angle ) {\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix3: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyProjection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 projection matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyQuaternion: function ( q ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var qx = q.x;\r\n		var qy = q.y;\r\n		var qz = q.z;\r\n		var qw = q.w;\r\n\r\n		// calculate quat * vector\r\n\r\n		var ix =  qw * x + qy * z - qz * y;\r\n		var iy =  qw * y + qz * x - qx * z;\r\n		var iz =  qw * z + qx * y - qy * x;\r\n		var iw = - qx * x - qy * y - qz * z;\r\n\r\n		// calculate result * inverse quat\r\n\r\n		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	project: function () {\r\n\r\n		var matrix;\r\n\r\n		return function project( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	unproject: function () {\r\n\r\n		var matrix;\r\n\r\n		return function unproject( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	transformDirection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n		// vector interpreted as a direction\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n		this.normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n		this.z /= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		return this.multiplyScalar( 1 / scalar );\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		this.x = Math.min( this.x, v.x );\r\n		this.y = Math.min( this.y, v.y );\r\n		this.z = Math.min( this.z, v.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		this.x = Math.max( this.x, v.x );\r\n		this.y = Math.max( this.y, v.y );\r\n		this.z = Math.max( this.z, v.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		this.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n		this.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n		this.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector3();\r\n				max = new THREE.Vector3();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clampLength: function ( min, max ) {\r\n\r\n		var length = this.length();\r\n\r\n		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n		this.z = Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n		this.z = Math.ceil( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n		this.z = Math.round( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( length ) {\r\n\r\n		return this.multiplyScalar( length / this.length() );\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	cross: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n			return this.crossVectors( v, w );\r\n\r\n		}\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		this.x = y * v.z - z * v.y;\r\n		this.y = z * v.x - x * v.z;\r\n		this.z = x * v.y - y * v.x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	crossVectors: function ( a, b ) {\r\n\r\n		var ax = a.x, ay = a.y, az = a.z;\r\n		var bx = b.x, by = b.y, bz = b.z;\r\n\r\n		this.x = ay * bz - az * by;\r\n		this.y = az * bx - ax * bz;\r\n		this.z = ax * by - ay * bx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	projectOnVector: function () {\r\n\r\n		var v1, dot;\r\n\r\n		return function projectOnVector( vector ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( vector ).normalize();\r\n\r\n			dot = this.dot( v1 );\r\n\r\n			return this.copy( v1 ).multiplyScalar( dot );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	projectOnPlane: function () {\r\n\r\n		var v1;\r\n\r\n		return function projectOnPlane( planeNormal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( this ).projectOnVector( planeNormal );\r\n\r\n			return this.sub( v1 );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	reflect: function () {\r\n\r\n		// reflect incident vector off plane orthogonal to normal\r\n		// normal is assumed to have unit length\r\n\r\n		var v1;\r\n\r\n		return function reflect( normal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	angleTo: function ( v ) {\r\n\r\n		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n		// clamp, to handle numerical problems\r\n\r\n		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x;\r\n		var dy = this.y - v.y;\r\n		var dz = this.z - v.z;\r\n\r\n		return dx * dx + dy * dy + dz * dz;\r\n\r\n	},\r\n\r\n	setFromMatrixPosition: function ( m ) {\r\n\r\n		this.x = m.elements[ 12 ];\r\n		this.y = m.elements[ 13 ];\r\n		this.z = m.elements[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrixScale: function ( m ) {\r\n\r\n		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();\r\n		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();\r\n		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n		this.x = sx;\r\n		this.y = sy;\r\n		this.z = sz;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrixColumn: function ( index, matrix ) {\r\n\r\n		var offset = index * 4;\r\n\r\n		var me = matrix.elements;\r\n\r\n		this.x = me[ offset ];\r\n		this.y = me[ offset + 1 ];\r\n		this.z = me[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n		this.z = attribute.array[ index + 2 ];\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n	this.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n	constructor: THREE.Vector4,\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setScalar: function ( scalar ) {\r\n\r\n		this.x = scalar;\r\n		this.y = scalar;\r\n		this.z = scalar;\r\n		this.w = scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setW: function ( w ) {\r\n\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			case 3: this.w = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			case 3: return this.w;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n		this.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n		this.w += v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n		this.w += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n		this.w = a.w + b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScaledVector: function ( v, s ) {\r\n\r\n		this.x += v.x * s;\r\n		this.y += v.y * s;\r\n		this.z += v.z * s;\r\n		this.w += v.w * s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n		this.w -= v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subScalar: function ( s ) {\r\n\r\n		this.x -= s;\r\n		this.y -= s;\r\n		this.z -= s;\r\n		this.w -= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n		this.w = a.w - b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		if ( isFinite( scalar ) ) {\r\n\r\n			this.x *= scalar;\r\n			this.y *= scalar;\r\n			this.z *= scalar;\r\n			this.w *= scalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n			this.w = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n		var w = this.w;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		return this.multiplyScalar( 1 / scalar );\r\n\r\n	},\r\n\r\n	setAxisAngleFromQuaternion: function ( q ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n		// q is assumed to be normalized\r\n\r\n		this.w = 2 * Math.acos( q.w );\r\n\r\n		var s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n		if ( s < 0.0001 ) {\r\n\r\n			 this.x = 1;\r\n			 this.y = 0;\r\n			 this.z = 0;\r\n\r\n		} else {\r\n\r\n			 this.x = q.x / s;\r\n			 this.y = q.y / s;\r\n			 this.z = q.z / s;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var angle, x, y, z,		// variables for result\r\n			epsilon = 0.01,		// margin to allow for rounding errors\r\n			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees\r\n\r\n			te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		if ( ( Math.abs( m12 - m21 ) < epsilon )\r\n		   && ( Math.abs( m13 - m31 ) < epsilon )\r\n		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n			// singularity found\r\n			// first check for identity matrix which must have +1 for all terms\r\n			// in leading diagonal and zero in other terms\r\n\r\n			if ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n			   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n			   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n				// this singularity is identity matrix so angle = 0\r\n\r\n				this.set( 1, 0, 0, 0 );\r\n\r\n				return this; // zero angle, arbitrary axis\r\n\r\n			}\r\n\r\n			// otherwise this singularity is angle = 180\r\n\r\n			angle = Math.PI;\r\n\r\n			var xx = ( m11 + 1 ) / 2;\r\n			var yy = ( m22 + 1 ) / 2;\r\n			var zz = ( m33 + 1 ) / 2;\r\n			var xy = ( m12 + m21 ) / 4;\r\n			var xz = ( m13 + m31 ) / 4;\r\n			var yz = ( m23 + m32 ) / 4;\r\n\r\n			if ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n				// m11 is the largest diagonal term\r\n\r\n				if ( xx < epsilon ) {\r\n\r\n					x = 0;\r\n					y = 0.707106781;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					x = Math.sqrt( xx );\r\n					y = xy / x;\r\n					z = xz / x;\r\n\r\n				}\r\n\r\n			} else if ( yy > zz ) {\r\n\r\n				// m22 is the largest diagonal term\r\n\r\n				if ( yy < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					y = Math.sqrt( yy );\r\n					x = xy / y;\r\n					z = yz / y;\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// m33 is the largest diagonal term so base result on this\r\n\r\n				if ( zz < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0.707106781;\r\n					z = 0;\r\n\r\n				} else {\r\n\r\n					z = Math.sqrt( zz );\r\n					x = xz / z;\r\n					y = yz / z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.set( x, y, z, angle );\r\n\r\n			return this; // return 180 deg rotation\r\n\r\n		}\r\n\r\n		// as we have reached here there are no singularities so we can handle normally\r\n\r\n		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n						  + ( m13 - m31 ) * ( m13 - m31 )\r\n						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n		if ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n		// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n		// caught by singularity test above, but I've left it in just in case\r\n\r\n		this.x = ( m32 - m23 ) / s;\r\n		this.y = ( m13 - m31 ) / s;\r\n		this.z = ( m21 - m12 ) / s;\r\n		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		this.x = Math.min( this.x, v.x );\r\n		this.y = Math.min( this.y, v.y );\r\n		this.z = Math.min( this.z, v.z );\r\n		this.w = Math.min( this.w, v.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		this.x = Math.max( this.x, v.x );\r\n		this.y = Math.max( this.y, v.y );\r\n		this.z = Math.max( this.z, v.z );\r\n		this.w = Math.max( this.w, v.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		this.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n		this.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n		this.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n		this.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: function () {\r\n\r\n		var min, max;\r\n\r\n		return function clampScalar( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector4();\r\n				max = new THREE.Vector4();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n		this.z = Math.floor( this.z );\r\n		this.w = Math.floor( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n		this.z = Math.ceil( this.z );\r\n		this.w = Math.ceil( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n		this.z = Math.round( this.z );\r\n		this.w = Math.round( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n		this.w = - this.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( length ) {\r\n\r\n		return this.multiplyScalar( length / this.length() );\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n		this.w += ( v.w - this.w ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerpVectors: function ( v1, v2, alpha ) {\r\n\r\n		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n		this.w = array[ offset + 3 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n		array[ offset + 3 ] = this.w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		index = index * attribute.itemSize + offset;\r\n\r\n		this.x = attribute.array[ index ];\r\n		this.y = attribute.array[ index + 1 ];\r\n		this.z = attribute.array[ index + 2 ];\r\n		this.w = attribute.array[ index + 3 ];\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n	constructor: THREE.Euler,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get order () {\r\n\r\n		return this._order;\r\n\r\n	},\r\n\r\n	set order ( value ) {\r\n\r\n		this._order = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, order ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._order = order || this._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n	},\r\n\r\n	copy: function ( euler ) {\r\n\r\n		this._x = euler._x;\r\n		this._y = euler._y;\r\n		this._z = euler._z;\r\n		this._order = euler._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m, order, update ) {\r\n\r\n		var clamp = THREE.Math.clamp;\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements;\r\n		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		order = order || this._order;\r\n\r\n		if ( order === 'XYZ' ) {\r\n\r\n			this._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._z = Math.atan2( - m12, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'YXZ' ) {\r\n\r\n			this._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( m13, m33 );\r\n				this._z = Math.atan2( m21, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = Math.atan2( - m31, m11 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZXY' ) {\r\n\r\n			this._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( - m31, m33 );\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = 0;\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZYX' ) {\r\n\r\n			this._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m33 );\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'YZX' ) {\r\n\r\n			this._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m22 );\r\n				this._y = Math.atan2( - m31, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._y = Math.atan2( m13, m33 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'XZY' ) {\r\n\r\n			this._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._y = Math.atan2( m13, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._y = 0;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n		}\r\n\r\n		this._order = order;\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromQuaternion: function () {\r\n\r\n		var matrix;\r\n\r\n		return function ( q, order, update ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n			matrix.makeRotationFromQuaternion( q );\r\n			this.setFromRotationMatrix( matrix, order, update );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromVector3: function ( v, order ) {\r\n\r\n		return this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n	},\r\n\r\n	reorder: function () {\r\n\r\n		// WARNING: this discards revolution information -bhouston\r\n\r\n		var q = new THREE.Quaternion();\r\n\r\n		return function ( newOrder ) {\r\n\r\n			q.setFromEuler( this );\r\n			this.setFromQuaternion( q, newOrder );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	equals: function ( euler ) {\r\n\r\n		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this._x = array[ 0 ];\r\n		this._y = array[ 1 ];\r\n		this._z = array[ 2 ];\r\n		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this._x;\r\n		array[ offset + 1 ] = this._y;\r\n		array[ offset + 2 ] = this._z;\r\n		array[ offset + 3 ] = this._order;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	toVector3: function ( optionalResult ) {\r\n\r\n		if ( optionalResult ) {\r\n\r\n			return optionalResult.set( this._x, this._y, this._z );\r\n\r\n		} else {\r\n\r\n			return new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n	this.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n	this.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n	constructor: THREE.Line3,\r\n\r\n	set: function ( start, end ) {\r\n\r\n		this.start.copy( start );\r\n		this.end.copy( end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( line ) {\r\n\r\n		this.start.copy( line.start );\r\n		this.end.copy( line.end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	delta: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.end, this.start );\r\n\r\n	},\r\n\r\n	distanceSq: function () {\r\n\r\n		return this.start.distanceToSquared( this.end );\r\n\r\n	},\r\n\r\n	distance: function () {\r\n\r\n		return this.start.distanceTo( this.end );\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	closestPointToPointParameter: function () {\r\n\r\n		var startP = new THREE.Vector3();\r\n		var startEnd = new THREE.Vector3();\r\n\r\n		return function ( point, clampToLine ) {\r\n\r\n			startP.subVectors( point, this.start );\r\n			startEnd.subVectors( this.end, this.start );\r\n\r\n			var startEnd2 = startEnd.dot( startEnd );\r\n			var startEnd_startP = startEnd.dot( startP );\r\n\r\n			var t = startEnd_startP / startEnd2;\r\n\r\n			if ( clampToLine ) {\r\n\r\n				t = THREE.Math.clamp( t, 0, 1 );\r\n\r\n			}\r\n\r\n			return t;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n		var t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.start.applyMatrix4( matrix );\r\n		this.end.applyMatrix4( matrix );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( line ) {\r\n\r\n		return line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n	constructor: THREE.Box2,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = + Infinity;\r\n		this.max.x = this.max.y = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	isEmpty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n		     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n		);\r\n\r\n	},\r\n\r\n	intersectsBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n		     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n	constructor: THREE.Box3,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromArray: function ( array ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		var minX = + Infinity;\r\n		var minY = + Infinity;\r\n		var minZ = + Infinity;\r\n\r\n		var maxX = - Infinity;\r\n		var maxY = - Infinity;\r\n		var maxZ = - Infinity;\r\n\r\n		for ( var i = 0, il = array.length; i < il; i += 3 ) {\r\n\r\n			var x = array[ i ];\r\n			var y = array[ i + 1 ];\r\n			var z = array[ i + 2 ];\r\n\r\n			if ( x < minX ) minX = x;\r\n			if ( y < minY ) minY = y;\r\n			if ( z < minZ ) minZ = z;\r\n\r\n			if ( x > maxX ) maxX = x;\r\n			if ( y > maxY ) maxY = y;\r\n			if ( z > maxZ ) maxZ = z;\r\n\r\n		}\r\n\r\n		this.min.set( minX, minY, minZ );\r\n		this.max.set( maxX, maxY, maxZ );\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromObject: function () {\r\n\r\n		// Computes the world-axis-aligned bounding box of an object (including its children),\r\n		// accounting for both the object's, and children's, world transforms\r\n\r\n		var box;\r\n\r\n		return function ( object ) {\r\n\r\n			if ( box === undefined ) box = new THREE.Box3();\r\n\r\n			var scope = this;\r\n\r\n			this.makeEmpty();\r\n\r\n			object.updateMatrixWorld( true );\r\n\r\n			object.traverse( function ( node ) {\r\n\r\n				var geometry = node.geometry;\r\n\r\n				if ( geometry !== undefined ) {\r\n\r\n					if ( geometry.boundingBox === null ) {\r\n\r\n						geometry.computeBoundingBox();\r\n\r\n					}\r\n\r\n					box.copy( geometry.boundingBox );\r\n					box.applyMatrix4( node.matrixWorld );\r\n					scope.union( box );\r\n\r\n				}\r\n\r\n			} );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = this.min.z = + Infinity;\r\n		this.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	isEmpty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n				 point.y < this.min.y || point.y > this.max.y ||\r\n				 point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n			( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n		);\r\n\r\n	},\r\n\r\n	intersectsBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n				 box.max.y < this.min.y || box.min.y > this.max.y ||\r\n				 box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	intersectsSphere: ( function () {\r\n\r\n		var closestPoint;\r\n\r\n		return function intersectsSphere( sphere ) {\r\n\r\n			if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\r\n			// Find the point on the AABB closest to the sphere center.\r\n			this.clampPoint( sphere.center, closestPoint );\r\n\r\n			// If that point is inside the sphere, the AABB and sphere intersect.\r\n			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	intersectsPlane: function ( plane ) {\r\n\r\n		// We compute the minimum and maximum dot product values. If those values\r\n		// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n		var min, max;\r\n\r\n		if ( plane.normal.x > 0 ) {\r\n\r\n			min = plane.normal.x * this.min.x;\r\n			max = plane.normal.x * this.max.x;\r\n\r\n		} else {\r\n\r\n			min = plane.normal.x * this.max.x;\r\n			max = plane.normal.x * this.min.x;\r\n\r\n		}\r\n\r\n		if ( plane.normal.y > 0 ) {\r\n\r\n			min += plane.normal.y * this.min.y;\r\n			max += plane.normal.y * this.max.y;\r\n\r\n		} else {\r\n\r\n			min += plane.normal.y * this.max.y;\r\n			max += plane.normal.y * this.min.y;\r\n\r\n		}\r\n\r\n		if ( plane.normal.z > 0 ) {\r\n\r\n			min += plane.normal.z * this.min.z;\r\n			max += plane.normal.z * this.max.z;\r\n\r\n		} else {\r\n\r\n			min += plane.normal.z * this.max.z;\r\n			max += plane.normal.z * this.min.z;\r\n\r\n		}\r\n\r\n		return ( min <= plane.constant && max >= plane.constant );\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getBoundingSphere: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Sphere();\r\n\r\n			result.center = this.center();\r\n			result.radius = this.size( v1 ).length() * 0.5;\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var points = [\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3()\r\n		];\r\n\r\n		return function ( matrix ) {\r\n\r\n			// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111\r\n\r\n			this.makeEmpty();\r\n			this.setFromPoints( points );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0,\r\n		0, 1, 0,\r\n		0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n	constructor: THREE.Matrix3,\r\n\r\n	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0,\r\n			0, 1, 0,\r\n			0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().fromArray( this.elements );\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		var me = m.elements;\r\n\r\n		this.set(\r\n\r\n			me[ 0 ], me[ 3 ], me[ 6 ],\r\n			me[ 1 ], me[ 4 ], me[ 7 ],\r\n			me[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.fromArray( array, j );\r\n				v1.applyMatrix3( this );\r\n				v1.toArray( array, j );\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyToBuffer: function () {\r\n\r\n		var v1;\r\n\r\n		return function applyToBuffer( buffer, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n				v1.x = buffer.getX( j );\r\n				v1.y = buffer.getY( j );\r\n				v1.z = buffer.getZ( j );\r\n\r\n				v1.applyMatrix3( this );\r\n\r\n				buffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n			}\r\n\r\n			return buffer;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n	},\r\n\r\n	getInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n		// input: THREE.Matrix4\r\n		// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n		var me = matrix.elements;\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\r\n		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n		// no inverse\r\n\r\n		if ( det === 0 ) {\r\n\r\n			var msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnDegenerate || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		this.multiplyScalar( 1.0 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var tmp, m = this.elements;\r\n\r\n		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n\r\n		array[ offset + 3 ] = te[ 3 ];\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getNormalMatrix: function ( m ) {\r\n\r\n		// input: THREE.Matrix4\r\n\r\n		this.getInverse( m ).transpose();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transposeIntoArray: function ( r ) {\r\n\r\n		var m = this.elements;\r\n\r\n		r[ 0 ] = m[ 0 ];\r\n		r[ 1 ] = m[ 3 ];\r\n		r[ 2 ] = m[ 6 ];\r\n		r[ 3 ] = m[ 1 ];\r\n		r[ 4 ] = m[ 4 ];\r\n		r[ 5 ] = m[ 7 ];\r\n		r[ 6 ] = m[ 2 ];\r\n		r[ 7 ] = m[ 5 ];\r\n		r[ 8 ] = m[ 8 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ],\r\n			te[ 3 ], te[ 4 ], te[ 5 ],\r\n			te[ 6 ], te[ 7 ], te[ 8 ]\r\n		];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0, 0,\r\n		0, 1, 0, 0,\r\n		0, 0, 1, 0,\r\n		0, 0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n	constructor: THREE.Matrix4,\r\n\r\n	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, 0,\r\n			0, 1, 0, 0,\r\n			0, 0, 1, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Matrix4().fromArray( this.elements );\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		this.elements.set( m.elements );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyPosition: function ( m ) {\r\n\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		te[ 12 ] = me[ 12 ];\r\n		te[ 13 ] = me[ 13 ];\r\n		te[ 14 ] = me[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n		var te = this.elements;\r\n\r\n		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n		this.set(\r\n			xAxis.x, yAxis.x, zAxis.x, 0,\r\n			xAxis.y, yAxis.y, zAxis.y, 0,\r\n			xAxis.z, yAxis.z, zAxis.z, 0,\r\n			0,       0,       0,       1\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractRotation: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( m ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			var te = this.elements;\r\n			var me = m.elements;\r\n\r\n			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\r\n			te[ 0 ] = me[ 0 ] * scaleX;\r\n			te[ 1 ] = me[ 1 ] * scaleX;\r\n			te[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n			te[ 4 ] = me[ 4 ] * scaleY;\r\n			te[ 5 ] = me[ 5 ] * scaleY;\r\n			te[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n			te[ 8 ] = me[ 8 ] * scaleZ;\r\n			te[ 9 ] = me[ 9 ] * scaleZ;\r\n			te[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeRotationFromEuler: function ( euler ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n		}\r\n\r\n		var te = this.elements;\r\n\r\n		var x = euler.x, y = euler.y, z = euler.z;\r\n		var a = Math.cos( x ), b = Math.sin( x );\r\n		var c = Math.cos( y ), d = Math.sin( y );\r\n		var e = Math.cos( z ), f = Math.sin( z );\r\n\r\n		if ( euler.order === 'XYZ' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - c * f;\r\n			te[ 8 ] = d;\r\n\r\n			te[ 1 ] = af + be * d;\r\n			te[ 5 ] = ae - bf * d;\r\n			te[ 9 ] = - b * c;\r\n\r\n			te[ 2 ] = bf - ae * d;\r\n			te[ 6 ] = be + af * d;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YXZ' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce + df * b;\r\n			te[ 4 ] = de * b - cf;\r\n			te[ 8 ] = a * d;\r\n\r\n			te[ 1 ] = a * f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b;\r\n\r\n			te[ 2 ] = cf * b - de;\r\n			te[ 6 ] = df + ce * b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZXY' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce - df * b;\r\n			te[ 4 ] = - a * f;\r\n			te[ 8 ] = de + cf * b;\r\n\r\n			te[ 1 ] = cf + de * b;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = df - ce * b;\r\n\r\n			te[ 2 ] = - a * d;\r\n			te[ 6 ] = b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZYX' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = be * d - af;\r\n			te[ 8 ] = ae * d + bf;\r\n\r\n			te[ 1 ] = c * f;\r\n			te[ 5 ] = bf * d + ae;\r\n			te[ 9 ] = af * d - be;\r\n\r\n			te[ 2 ] = - d;\r\n			te[ 6 ] = b * c;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YZX' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = bd - ac * f;\r\n			te[ 8 ] = bc * f + ad;\r\n\r\n			te[ 1 ] = f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b * e;\r\n\r\n			te[ 2 ] = - d * e;\r\n			te[ 6 ] = ad * f + bc;\r\n			te[ 10 ] = ac - bd * f;\r\n\r\n		} else if ( euler.order === 'XZY' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - f;\r\n			te[ 8 ] = d * e;\r\n\r\n			te[ 1 ] = ac * f + bd;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = ad * f - bc;\r\n\r\n			te[ 2 ] = bc * f - ad;\r\n			te[ 6 ] = b * e;\r\n			te[ 10 ] = bd * f + ac;\r\n\r\n		}\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationFromQuaternion: function ( q ) {\r\n\r\n		var te = this.elements;\r\n\r\n		var x = q.x, y = q.y, z = q.z, w = q.w;\r\n		var x2 = x + x, y2 = y + y, z2 = z + z;\r\n		var xx = x * x2, xy = x * y2, xz = x * z2;\r\n		var yy = y * y2, yz = y * z2, zz = z * z2;\r\n		var wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n		te[ 0 ] = 1 - ( yy + zz );\r\n		te[ 4 ] = xy - wz;\r\n		te[ 8 ] = xz + wy;\r\n\r\n		te[ 1 ] = xy + wz;\r\n		te[ 5 ] = 1 - ( xx + zz );\r\n		te[ 9 ] = yz - wx;\r\n\r\n		te[ 2 ] = xz - wy;\r\n		te[ 6 ] = yz + wx;\r\n		te[ 10 ] = 1 - ( xx + yy );\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lookAt: function () {\r\n\r\n		var x, y, z;\r\n\r\n		return function ( eye, target, up ) {\r\n\r\n			if ( x === undefined ) x = new THREE.Vector3();\r\n			if ( y === undefined ) y = new THREE.Vector3();\r\n			if ( z === undefined ) z = new THREE.Vector3();\r\n\r\n			var te = this.elements;\r\n\r\n			z.subVectors( eye, target ).normalize();\r\n\r\n			if ( z.lengthSq() === 0 ) {\r\n\r\n				z.z = 1;\r\n\r\n			}\r\n\r\n			x.crossVectors( up, z ).normalize();\r\n\r\n			if ( x.lengthSq() === 0 ) {\r\n\r\n				z.x += 0.0001;\r\n				x.crossVectors( up, z ).normalize();\r\n\r\n			}\r\n\r\n			y.crossVectors( z, x );\r\n\r\n\r\n			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiply: function ( m, n ) {\r\n\r\n		if ( n !== undefined ) {\r\n\r\n			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n			return this.multiplyMatrices( m, n );\r\n\r\n		}\r\n\r\n		return this.multiplyMatrices( this, m );\r\n\r\n	},\r\n\r\n	multiplyMatrices: function ( a, b ) {\r\n\r\n		var ae = a.elements;\r\n		var be = b.elements;\r\n		var te = this.elements;\r\n\r\n		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyToArray: function ( a, b, r ) {\r\n\r\n		var te = this.elements;\r\n\r\n		this.multiplyMatrices( a, b );\r\n\r\n		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.fromArray( array, j );\r\n				v1.applyMatrix4( this );\r\n				v1.toArray( array, j );\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyToBuffer: function () {\r\n\r\n		var v1;\r\n\r\n		return function applyToBuffer( buffer, offset, length ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n				v1.x = buffer.getX( j );\r\n				v1.y = buffer.getY( j );\r\n				v1.z = buffer.getZ( j );\r\n\r\n				v1.applyMatrix4( this );\r\n\r\n				buffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n			}\r\n\r\n			return buffer;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n		//TODO: make this more efficient\r\n		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n		return (\r\n			n41 * (\r\n				+ n14 * n23 * n32\r\n				 - n13 * n24 * n32\r\n				 - n14 * n22 * n33\r\n				 + n12 * n24 * n33\r\n				 + n13 * n22 * n34\r\n				 - n12 * n23 * n34\r\n			) +\r\n			n42 * (\r\n				+ n11 * n23 * n34\r\n				 - n11 * n24 * n33\r\n				 + n14 * n21 * n33\r\n				 - n13 * n21 * n34\r\n				 + n13 * n24 * n31\r\n				 - n14 * n23 * n31\r\n			) +\r\n			n43 * (\r\n				+ n11 * n24 * n32\r\n				 - n11 * n22 * n34\r\n				 - n14 * n21 * n32\r\n				 + n12 * n21 * n34\r\n				 + n14 * n22 * n31\r\n				 - n12 * n24 * n31\r\n			) +\r\n			n44 * (\r\n				- n13 * n22 * n31\r\n				 - n11 * n23 * n32\r\n				 + n11 * n22 * n33\r\n				 + n13 * n21 * n32\r\n				 - n12 * n21 * n33\r\n				 + n12 * n23 * n31\r\n			)\r\n\r\n		);\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var te = this.elements;\r\n		var tmp;\r\n\r\n		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n		array[ offset + 3 ] = te[ 3 ];\r\n\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n		array[ offset + 9 ]  = te[ 9 ];\r\n		array[ offset + 10 ] = te[ 10 ];\r\n		array[ offset + 11 ] = te[ 11 ];\r\n\r\n		array[ offset + 12 ] = te[ 12 ];\r\n		array[ offset + 13 ] = te[ 13 ];\r\n		array[ offset + 14 ] = te[ 14 ];\r\n		array[ offset + 15 ] = te[ 15 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getPosition: function () {\r\n\r\n		var v1;\r\n\r\n		return function () {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n			var te = this.elements;\r\n			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setPosition: function ( v ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 12 ] = v.x;\r\n		te[ 13 ] = v.y;\r\n		te[ 14 ] = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getInverse: function ( m, throwOnInvertible ) {\r\n\r\n		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\r\n		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n		if ( det === 0 ) {\r\n\r\n			var msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnInvertible || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		this.multiplyScalar( 1 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	scale: function ( v ) {\r\n\r\n		var te = this.elements;\r\n		var x = v.x, y = v.y, z = v.z;\r\n\r\n		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getMaxScaleOnAxis: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n	},\r\n\r\n	makeTranslation: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, x,\r\n			0, 1, 0, y,\r\n			0, 0, 1, z,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationX: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			1, 0,  0, 0,\r\n			0, c, - s, 0,\r\n			0, s,  c, 0,\r\n			0, 0,  0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationY: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			 c, 0, s, 0,\r\n			 0, 1, 0, 0,\r\n			- s, 0, c, 0,\r\n			 0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationZ: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			c, - s, 0, 0,\r\n			s,  c, 0, 0,\r\n			0,  0, 1, 0,\r\n			0,  0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationAxis: function ( axis, angle ) {\r\n\r\n		// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n		var c = Math.cos( angle );\r\n		var s = Math.sin( angle );\r\n		var t = 1 - c;\r\n		var x = axis.x, y = axis.y, z = axis.z;\r\n		var tx = t * x, ty = t * y;\r\n\r\n		this.set(\r\n\r\n			tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n			tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		 return this;\r\n\r\n	},\r\n\r\n	makeScale: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			x, 0, 0, 0,\r\n			0, y, 0, 0,\r\n			0, 0, z, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	compose: function ( position, quaternion, scale ) {\r\n\r\n		this.makeRotationFromQuaternion( quaternion );\r\n		this.scale( scale );\r\n		this.setPosition( position );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	decompose: function () {\r\n\r\n		var vector, matrix;\r\n\r\n		return function ( position, quaternion, scale ) {\r\n\r\n			if ( vector === undefined ) vector = new THREE.Vector3();\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			var te = this.elements;\r\n\r\n			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n			// if determine is negative, we need to invert one scale\r\n			var det = this.determinant();\r\n			if ( det < 0 ) {\r\n\r\n				sx = - sx;\r\n\r\n			}\r\n\r\n			position.x = te[ 12 ];\r\n			position.y = te[ 13 ];\r\n			position.z = te[ 14 ];\r\n\r\n			// scale the rotation part\r\n\r\n			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n			var invSX = 1 / sx;\r\n			var invSY = 1 / sy;\r\n			var invSZ = 1 / sz;\r\n\r\n			matrix.elements[ 0 ] *= invSX;\r\n			matrix.elements[ 1 ] *= invSX;\r\n			matrix.elements[ 2 ] *= invSX;\r\n\r\n			matrix.elements[ 4 ] *= invSY;\r\n			matrix.elements[ 5 ] *= invSY;\r\n			matrix.elements[ 6 ] *= invSY;\r\n\r\n			matrix.elements[ 8 ] *= invSZ;\r\n			matrix.elements[ 9 ] *= invSZ;\r\n			matrix.elements[ 10 ] *= invSZ;\r\n\r\n			quaternion.setFromRotationMatrix( matrix );\r\n\r\n			scale.x = sx;\r\n			scale.y = sy;\r\n			scale.z = sz;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var x = 2 * near / ( right - left );\r\n		var y = 2 * near / ( top - bottom );\r\n\r\n		var a = ( right + left ) / ( right - left );\r\n		var b = ( top + bottom ) / ( top - bottom );\r\n		var c = - ( far + near ) / ( far - near );\r\n		var d = - 2 * far * near / ( far - near );\r\n\r\n		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;\r\n		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makePerspective: function ( fov, aspect, near, far ) {\r\n\r\n		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n		var ymin = - ymax;\r\n		var xmin = ymin * aspect;\r\n		var xmax = ymax * aspect;\r\n\r\n		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n	},\r\n\r\n	makeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var w = right - left;\r\n		var h = top - bottom;\r\n		var p = far - near;\r\n\r\n		var x = ( right + left ) / w;\r\n		var y = ( top + bottom ) / h;\r\n		var z = ( far + near ) / p;\r\n\r\n		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;\r\n		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( matrix ) {\r\n\r\n		var te = this.elements;\r\n		var me = matrix.elements;\r\n\r\n		for ( var i = 0; i < 16; i ++ ) {\r\n\r\n			if ( te[ i ] !== me[ i ] ) return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n		];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n	constructor: THREE.Ray,\r\n\r\n	set: function ( origin, direction ) {\r\n\r\n		this.origin.copy( origin );\r\n		this.direction.copy( direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( ray ) {\r\n\r\n		this.origin.copy( ray.origin );\r\n		this.direction.copy( ray.direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n	},\r\n\r\n	lookAt: function ( v ) {\r\n\r\n		this.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n	},\r\n\r\n	recast: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( t ) {\r\n\r\n			this.origin.copy( this.at( t, v1 ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		result.subVectors( point, this.origin );\r\n		var directionDistance = result.dot( this.direction );\r\n\r\n		if ( directionDistance < 0 ) {\r\n\r\n			return result.copy( this.origin );\r\n\r\n		}\r\n\r\n		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n	},\r\n\r\n	distanceSqToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n			// point behind the ray\r\n\r\n			if ( directionDistance < 0 ) {\r\n\r\n				return this.origin.distanceToSquared( point );\r\n\r\n			}\r\n\r\n			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n			return v1.distanceToSquared( point );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	distanceSqToSegment: function () {\r\n\r\n		var segCenter = new THREE.Vector3();\r\n		var segDir = new THREE.Vector3();\r\n		var diff = new THREE.Vector3();\r\n\r\n		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n			// It returns the min distance between the ray and the segment\r\n			// defined by v0 and v1\r\n			// It can also set two optional targets :\r\n			// - The closest point on the ray\r\n			// - The closest point on the segment\r\n\r\n			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n			segDir.copy( v1 ).sub( v0 ).normalize();\r\n			diff.copy( this.origin ).sub( segCenter );\r\n\r\n			var segExtent = v0.distanceTo( v1 ) * 0.5;\r\n			var a01 = - this.direction.dot( segDir );\r\n			var b0 = diff.dot( this.direction );\r\n			var b1 = - diff.dot( segDir );\r\n			var c = diff.lengthSq();\r\n			var det = Math.abs( 1 - a01 * a01 );\r\n			var s0, s1, sqrDist, extDet;\r\n\r\n			if ( det > 0 ) {\r\n\r\n				// The ray and segment are not parallel.\r\n\r\n				s0 = a01 * b1 - b0;\r\n				s1 = a01 * b0 - b1;\r\n				extDet = segExtent * det;\r\n\r\n				if ( s0 >= 0 ) {\r\n\r\n					if ( s1 >= - extDet ) {\r\n\r\n						if ( s1 <= extDet ) {\r\n\r\n							// region 0\r\n							// Minimum at interior points of ray and segment.\r\n\r\n							var invDet = 1 / det;\r\n							s0 *= invDet;\r\n							s1 *= invDet;\r\n							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n						} else {\r\n\r\n							// region 1\r\n\r\n							s1 = segExtent;\r\n							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						// region 5\r\n\r\n						s1 = - segExtent;\r\n						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					if ( s1 <= - extDet ) {\r\n\r\n						// region 4\r\n\r\n						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else if ( s1 <= extDet ) {\r\n\r\n						// region 3\r\n\r\n						s0 = 0;\r\n						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else {\r\n\r\n						// region 2\r\n\r\n						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// Ray and segment are parallel.\r\n\r\n				s1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n			}\r\n\r\n			if ( optionalPointOnRay ) {\r\n\r\n				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n			}\r\n\r\n			if ( optionalPointOnSegment ) {\r\n\r\n				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n			}\r\n\r\n			return sqrDist;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectSphere: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( sphere, optionalTarget ) {\r\n\r\n			v1.subVectors( sphere.center, this.origin );\r\n			var tca = v1.dot( this.direction );\r\n			var d2 = v1.dot( v1 ) - tca * tca;\r\n			var radius2 = sphere.radius * sphere.radius;\r\n\r\n			if ( d2 > radius2 ) return null;\r\n\r\n			var thc = Math.sqrt( radius2 - d2 );\r\n\r\n			// t0 = first intersect point - entrance on front of sphere\r\n			var t0 = tca - thc;\r\n\r\n			// t1 = second intersect point - exit point on back of sphere\r\n			var t1 = tca + thc;\r\n\r\n			// test to see if both t0 and t1 are behind the ray - if so, return null\r\n			if ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n			// test to see if t0 is behind the ray:\r\n			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n			// in order to always return an intersect point that is in front of the ray.\r\n			if ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n			// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n			return this.at( t0, optionalTarget );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n	},\r\n\r\n	distanceToPlane: function ( plane ) {\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n\r\n		if ( denominator === 0 ) {\r\n\r\n			// line is coplanar, return origin\r\n			if ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n				return 0;\r\n\r\n			}\r\n\r\n			// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n		// Return if the ray never intersects the plane\r\n\r\n		return t >= 0 ? t :  null;\r\n\r\n	},\r\n\r\n	intersectPlane: function ( plane, optionalTarget ) {\r\n\r\n		var t = this.distanceToPlane( plane );\r\n\r\n		if ( t === null ) {\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		return this.at( t, optionalTarget );\r\n\r\n	},\r\n\r\n\r\n\r\n	intersectsPlane: function ( plane ) {\r\n\r\n		// check if the ray lies on the plane first\r\n\r\n		var distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n		if ( distToPoint === 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n\r\n		if ( denominator * distToPoint < 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		// ray origin is behind the plane (and is pointing behind it)\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	intersectBox: function ( box, optionalTarget ) {\r\n\r\n		var tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n		var invdirx = 1 / this.direction.x,\r\n			invdiry = 1 / this.direction.y,\r\n			invdirz = 1 / this.direction.z;\r\n\r\n		var origin = this.origin;\r\n\r\n		if ( invdirx >= 0 ) {\r\n\r\n			tmin = ( box.min.x - origin.x ) * invdirx;\r\n			tmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n		} else {\r\n\r\n			tmin = ( box.max.x - origin.x ) * invdirx;\r\n			tmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n		}\r\n\r\n		if ( invdiry >= 0 ) {\r\n\r\n			tymin = ( box.min.y - origin.y ) * invdiry;\r\n			tymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n		} else {\r\n\r\n			tymin = ( box.max.y - origin.y ) * invdiry;\r\n			tymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n		}\r\n\r\n		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n		// These lines also handle the case where tmin or tmax is NaN\r\n		// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n		if ( invdirz >= 0 ) {\r\n\r\n			tzmin = ( box.min.z - origin.z ) * invdirz;\r\n			tzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n		} else {\r\n\r\n			tzmin = ( box.max.z - origin.z ) * invdirz;\r\n			tzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n		}\r\n\r\n		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n		//return point closest to the ray (positive side)\r\n\r\n		if ( tmax < 0 ) return null;\r\n\r\n		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n	},\r\n\r\n	intersectsBox: ( function () {\r\n\r\n		var v = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			return this.intersectBox( box, v ) !== null;\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	intersectTriangle: function () {\r\n\r\n		// Compute the offset origin, edges, and normal.\r\n		var diff = new THREE.Vector3();\r\n		var edge1 = new THREE.Vector3();\r\n		var edge2 = new THREE.Vector3();\r\n		var normal = new THREE.Vector3();\r\n\r\n		return function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n			edge1.subVectors( b, a );\r\n			edge2.subVectors( c, a );\r\n			normal.crossVectors( edge1, edge2 );\r\n\r\n			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n			var DdN = this.direction.dot( normal );\r\n			var sign;\r\n\r\n			if ( DdN > 0 ) {\r\n\r\n				if ( backfaceCulling ) return null;\r\n				sign = 1;\r\n\r\n			} else if ( DdN < 0 ) {\r\n\r\n				sign = - 1;\r\n				DdN = - DdN;\r\n\r\n			} else {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			diff.subVectors( this.origin, a );\r\n			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n			// b1 < 0, no intersection\r\n			if ( DdQxE2 < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n			// b2 < 0, no intersection\r\n			if ( DdE1xQ < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// b1+b2 > 1, no intersection\r\n			if ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Line intersects triangle, check if ray does.\r\n			var QdN = - sign * diff.dot( normal );\r\n\r\n			// t < 0, no intersection\r\n			if ( QdN < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Ray intersects triangle.\r\n			return this.at( QdN / DdN, optionalTarget );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix4: function ( matrix4 ) {\r\n\r\n		this.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n		this.origin.applyMatrix4( matrix4 );\r\n		this.direction.sub( this.origin );\r\n		this.direction.normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( ray ) {\r\n\r\n		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n	this.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n	this.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n	constructor: THREE.Sphere,\r\n\r\n	set: function ( center, radius ) {\r\n\r\n		this.center.copy( center );\r\n		this.radius = radius;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function () {\r\n\r\n		var box = new THREE.Box3();\r\n\r\n		return function ( points, optionalCenter ) {\r\n\r\n			var center = this.center;\r\n\r\n			if ( optionalCenter !== undefined ) {\r\n\r\n				center.copy( optionalCenter );\r\n\r\n			} else {\r\n\r\n				box.setFromPoints( points ).center( center );\r\n\r\n			}\r\n\r\n			var maxRadiusSq = 0;\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n			}\r\n\r\n			this.radius = Math.sqrt( maxRadiusSq );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( sphere ) {\r\n\r\n		this.center.copy( sphere.center );\r\n		this.radius = sphere.radius;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		return ( this.radius <= 0 );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return ( point.distanceTo( this.center ) - this.radius );\r\n\r\n	},\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var radiusSum = this.radius + sphere.radius;\r\n\r\n		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n	},\r\n\r\n	intersectsBox: function ( box ) {\r\n\r\n		return box.intersectsSphere( this );\r\n\r\n	},\r\n\r\n	intersectsPlane: function ( plane ) {\r\n\r\n		// We use the following equation to compute the signed distance from\r\n		// the center of the sphere to the plane.\r\n		//\r\n		// distance = q * n - d\r\n		//\r\n		// If this distance is greater than the radius of the sphere,\r\n		// then there is no intersection.\r\n\r\n		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		result.copy( point );\r\n\r\n		if ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n			result.sub( this.center ).normalize();\r\n			result.multiplyScalar( this.radius ).add( this.center );\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	getBoundingBox: function ( optionalTarget ) {\r\n\r\n		var box = optionalTarget || new THREE.Box3();\r\n\r\n		box.set( this.center, this.center );\r\n		box.expandByScalar( this.radius );\r\n\r\n		return box;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.center.applyMatrix4( matrix );\r\n		this.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.center.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( sphere ) {\r\n\r\n		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n	this.planes = [\r\n\r\n		( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n		( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n		( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n		( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n		( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n		( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n	];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n	constructor: THREE.Frustum,\r\n\r\n	set: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		planes[ 0 ].copy( p0 );\r\n		planes[ 1 ].copy( p1 );\r\n		planes[ 2 ].copy( p2 );\r\n		planes[ 3 ].copy( p3 );\r\n		planes[ 4 ].copy( p4 );\r\n		planes[ 5 ].copy( p5 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( frustum ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			planes[ i ].copy( frustum.planes[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrix: function ( m ) {\r\n\r\n		var planes = this.planes;\r\n		var me = m.elements;\r\n		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	intersectsObject: function () {\r\n\r\n		var sphere = new THREE.Sphere();\r\n\r\n		return function ( object ) {\r\n\r\n			var geometry = object.geometry;\r\n\r\n			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n			sphere.copy( geometry.boundingSphere );\r\n			sphere.applyMatrix4( object.matrixWorld );\r\n\r\n			return this.intersectsSphere( sphere );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var planes = this.planes;\r\n		var center = sphere.center;\r\n		var negRadius = - sphere.radius;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			var distance = planes[ i ].distanceToPoint( center );\r\n\r\n			if ( distance < negRadius ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	intersectsBox: function () {\r\n\r\n		var p1 = new THREE.Vector3(),\r\n			p2 = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			var planes = this.planes;\r\n\r\n			for ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n				var plane = planes[ i ];\r\n\r\n				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n				var d1 = plane.distanceToPoint( p1 );\r\n				var d2 = plane.distanceToPoint( p2 );\r\n\r\n				// if both outside plane, no intersection\r\n\r\n				if ( d1 < 0 && d2 < 0 ) {\r\n\r\n					return false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return true;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			if ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n	this.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n	constructor: THREE.Plane,\r\n\r\n	set: function ( normal, constant ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponents: function ( x, y, z, w ) {\r\n\r\n		this.normal.set( x, y, z );\r\n		this.constant = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCoplanarPoints: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n\r\n		return function ( a, b, c ) {\r\n\r\n			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n			this.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( plane ) {\r\n\r\n		this.normal.copy( plane.normal );\r\n		this.constant = plane.constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n		var inverseNormalLength = 1.0 / this.normal.length();\r\n		this.normal.multiplyScalar( inverseNormalLength );\r\n		this.constant *= inverseNormalLength;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.constant *= - 1;\r\n		this.normal.negate();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return this.normal.dot( point ) + this.constant;\r\n\r\n	},\r\n\r\n	distanceToSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n	},\r\n\r\n	projectPoint: function ( point, optionalTarget ) {\r\n\r\n		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n	},\r\n\r\n	orthoPoint: function ( point, optionalTarget ) {\r\n\r\n		var perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n	},\r\n\r\n	intersectLine: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( line, optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			var direction = line.delta( v1 );\r\n\r\n			var denominator = this.normal.dot( direction );\r\n\r\n			if ( denominator === 0 ) {\r\n\r\n				// line is coplanar, return origin\r\n				if ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n					return result.copy( line.start );\r\n\r\n				}\r\n\r\n				// Unsure if this is the correct method to handle this case.\r\n				return undefined;\r\n\r\n			}\r\n\r\n			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n			if ( t < 0 || t > 1 ) {\r\n\r\n				return undefined;\r\n\r\n			}\r\n\r\n			return result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectsLine: function ( line ) {\r\n\r\n		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n		var startSign = this.distanceToPoint( line.start );\r\n		var endSign = this.distanceToPoint( line.end );\r\n\r\n		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n	},\r\n\r\n	intersectsBox: function ( box ) {\r\n\r\n		return box.intersectsPlane( this );\r\n\r\n	},\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		return sphere.intersectsPlane( this );\r\n\r\n	},\r\n\r\n	coplanarPoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n		var m1 = new THREE.Matrix3();\r\n\r\n		return function ( matrix, optionalNormalMatrix ) {\r\n\r\n			// compute new normal based on theory here:\r\n			// http://www.songho.ca/opengl/gl_normaltransform.html\r\n			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n			var newCoplanarPoint = this.coplanarPoint( v2 );\r\n			newCoplanarPoint.applyMatrix4( matrix );\r\n\r\n			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.constant = this.constant - offset.dot( this.normal );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( plane ) {\r\n\r\n		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n	generateUUID: function () {\r\n\r\n		// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n		var uuid = new Array( 36 );\r\n		var rnd = 0, r;\r\n\r\n		return function () {\r\n\r\n			for ( var i = 0; i < 36; i ++ ) {\r\n\r\n				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\r\n					uuid[ i ] = '-';\r\n\r\n				} else if ( i === 14 ) {\r\n\r\n					uuid[ i ] = '4';\r\n\r\n				} else {\r\n\r\n					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n					r = rnd & 0xf;\r\n					rnd = rnd >> 4;\r\n					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return uuid.join( '' );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	clamp: function ( value, min, max ) {\r\n\r\n		return Math.max( min, Math.min( max, value ) );\r\n\r\n	},\r\n\r\n	// compute euclidian modulo of m % n\r\n	// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n	euclideanModulo: function ( n, m ) {\r\n\r\n		return ( ( n % m ) + m ) % m;\r\n\r\n	},\r\n\r\n	// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n	mapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n	},\r\n\r\n	// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n	smoothstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * ( 3 - 2 * x );\r\n\r\n	},\r\n\r\n	smootherstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n	},\r\n\r\n	random16: function () {\r\n\r\n		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n		return Math.random();\r\n\r\n	},\r\n\r\n	// Random integer from <low, high> interval\r\n\r\n	randInt: function ( low, high ) {\r\n\r\n		return low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n	},\r\n\r\n	// Random float from <low, high> interval\r\n\r\n	randFloat: function ( low, high ) {\r\n\r\n		return low + Math.random() * ( high - low );\r\n\r\n	},\r\n\r\n	// Random float from <-range/2, range/2> interval\r\n\r\n	randFloatSpread: function ( range ) {\r\n\r\n		return range * ( 0.5 - Math.random() );\r\n\r\n	},\r\n\r\n	degToRad: function () {\r\n\r\n		var degreeToRadiansFactor = Math.PI / 180;\r\n\r\n		return function ( degrees ) {\r\n\r\n			return degrees * degreeToRadiansFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	radToDeg: function () {\r\n\r\n		var radianToDegreesFactor = 180 / Math.PI;\r\n\r\n		return function ( radians ) {\r\n\r\n			return radians * radianToDegreesFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	isPowerOfTwo: function ( value ) {\r\n\r\n		return ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n	},\r\n\r\n	nearestPowerOfTwo: function ( value ) {\r\n\r\n		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\r\n	},\r\n\r\n	nextPowerOfTwo: function ( value ) {\r\n\r\n		value --;\r\n		value |= value >> 1;\r\n		value |= value >> 2;\r\n		value |= value >> 4;\r\n		value |= value >> 8;\r\n		value |= value >> 16;\r\n		value ++;\r\n\r\n		return value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n	this.points = points;\r\n\r\n	var c = [], v3 = { x: 0, y: 0, z: 0 },\r\n	point, intPoint, weight, w2, w3,\r\n	pa, pb, pc, pd;\r\n\r\n	this.initFromArray = function ( a ) {\r\n\r\n		this.points = [];\r\n\r\n		for ( var i = 0; i < a.length; i ++ ) {\r\n\r\n			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getPoint = function ( k ) {\r\n\r\n		point = ( this.points.length - 1 ) * k;\r\n		intPoint = Math.floor( point );\r\n		weight = point - intPoint;\r\n\r\n		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n		c[ 1 ] = intPoint;\r\n		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n		pa = this.points[ c[ 0 ] ];\r\n		pb = this.points[ c[ 1 ] ];\r\n		pc = this.points[ c[ 2 ] ];\r\n		pd = this.points[ c[ 3 ] ];\r\n\r\n		w2 = weight * weight;\r\n		w3 = weight * w2;\r\n\r\n		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n		return v3;\r\n\r\n	};\r\n\r\n	this.getControlPointsArray = function () {\r\n\r\n		var i, p, l = this.points.length,\r\n			coords = [];\r\n\r\n		for ( i = 0; i < l; i ++ ) {\r\n\r\n			p = this.points[ i ];\r\n			coords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n		}\r\n\r\n		return coords;\r\n\r\n	};\r\n\r\n	// approximate length by summing linear segments\r\n\r\n	this.getLength = function ( nSubDivisions ) {\r\n\r\n		var i, index, nSamples, position,\r\n			point = 0, intPoint = 0, oldIntPoint = 0,\r\n			oldPosition = new THREE.Vector3(),\r\n			tmpVec = new THREE.Vector3(),\r\n			chunkLengths = [],\r\n			totalLength = 0;\r\n\r\n		// first point has 0 length\r\n\r\n		chunkLengths[ 0 ] = 0;\r\n\r\n		if ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n		nSamples = this.points.length * nSubDivisions;\r\n\r\n		oldPosition.copy( this.points[ 0 ] );\r\n\r\n		for ( i = 1; i < nSamples; i ++ ) {\r\n\r\n			index = i / nSamples;\r\n\r\n			position = this.getPoint( index );\r\n			tmpVec.copy( position );\r\n\r\n			totalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n			oldPosition.copy( position );\r\n\r\n			point = ( this.points.length - 1 ) * index;\r\n			intPoint = Math.floor( point );\r\n\r\n			if ( intPoint !== oldIntPoint ) {\r\n\r\n				chunkLengths[ intPoint ] = totalLength;\r\n				oldIntPoint = intPoint;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// last point ends with total length\r\n\r\n		chunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n		return { chunks: chunkLengths, total: totalLength };\r\n\r\n	};\r\n\r\n	this.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n		var i, j,\r\n			index, indexCurrent, indexNext,\r\n			realDistance,\r\n			sampling, position,\r\n			newpoints = [],\r\n			tmpVec = new THREE.Vector3(),\r\n			sl = this.getLength();\r\n\r\n		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n		for ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n			//tmpVec.copy( this.points[ i - 1 ] );\r\n			//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n			sampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n			indexNext = i / ( this.points.length - 1 );\r\n\r\n			for ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n				position = this.getPoint( index );\r\n				newpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n			}\r\n\r\n			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n		}\r\n\r\n		this.points = newpoints;\r\n\r\n	};\r\n\r\n	// Catmull-Rom\r\n\r\n	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5,\r\n			v1 = ( p3 - p1 ) * 0.5;\r\n\r\n		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n	this.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n	this.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n	this.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n\r\n	return function ( a, b, c, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		result.subVectors( c, b );\r\n		v0.subVectors( a, b );\r\n		result.cross( v0 );\r\n\r\n		var resultLengthSq = result.lengthSq();\r\n		if ( resultLengthSq > 0 ) {\r\n\r\n			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n		}\r\n\r\n		return result.set( 0, 0, 0 );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycentric coordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c, optionalTarget ) {\r\n\r\n		v0.subVectors( c, a );\r\n		v1.subVectors( b, a );\r\n		v2.subVectors( point, a );\r\n\r\n		var dot00 = v0.dot( v0 );\r\n		var dot01 = v0.dot( v1 );\r\n		var dot02 = v0.dot( v2 );\r\n		var dot11 = v1.dot( v1 );\r\n		var dot12 = v1.dot( v2 );\r\n\r\n		var denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		// collinear or singular triangle\r\n		if ( denom === 0 ) {\r\n\r\n			// arbitrary location outside of triangle?\r\n			// not sure if this is the best idea, maybe should be returning undefined\r\n			return result.set( - 2, - 1, - 1 );\r\n\r\n		}\r\n\r\n		var invDenom = 1 / denom;\r\n		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n		// barycentric coordinates must always sum to 1\r\n		return result.set( 1 - u - v, v, u );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c ) {\r\n\r\n		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n	constructor: THREE.Triangle,\r\n\r\n	set: function ( a, b, c ) {\r\n\r\n		this.a.copy( a );\r\n		this.b.copy( b );\r\n		this.c.copy( c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n		this.a.copy( points[ i0 ] );\r\n		this.b.copy( points[ i1 ] );\r\n		this.c.copy( points[ i2 ] );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( triangle ) {\r\n\r\n		this.a.copy( triangle.a );\r\n		this.b.copy( triangle.b );\r\n		this.c.copy( triangle.c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	area: function () {\r\n\r\n		var v0 = new THREE.Vector3();\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			v0.subVectors( this.c, this.b );\r\n			v1.subVectors( this.a, this.b );\r\n\r\n			return v0.cross( v1 ).length() * 0.5;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	midpoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n	},\r\n\r\n	normal: function ( optionalTarget ) {\r\n\r\n		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	plane: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Plane();\r\n\r\n		return result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	barycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	equals: function ( triangle ) {\r\n\r\n		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Interpolant.js\r\n\r\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * 		http://www.oodesign.com/template-method-pattern.html\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.Interpolant = function(\r\n		parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n	this.parameterPositions = parameterPositions;\r\n	this._cachedIndex = 0;\r\n\r\n	this.resultBuffer = resultBuffer !== undefined ?\r\n			resultBuffer : new sampleValues.constructor( sampleSize );\r\n	this.sampleValues = sampleValues;\r\n	this.valueSize = sampleSize;\r\n\r\n};\r\n\r\nTHREE.Interpolant.prototype = {\r\n\r\n	constructor: THREE.Interpolant,\r\n\r\n	evaluate: function( t ) {\r\n\r\n		var pp = this.parameterPositions,\r\n			i1 = this._cachedIndex,\r\n\r\n			t1 = pp[   i1   ],\r\n			t0 = pp[ i1 - 1 ];\r\n\r\n		validate_interval: {\r\n\r\n			seek: {\r\n\r\n				var right;\r\n\r\n				linear_scan: {\r\n//- See http://jsperf.com/comparison-to-undefined/3\r\n//- slower code:\r\n//-\r\n//- 				if ( t >= t1 || t1 === undefined ) {\r\n					forward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n						for ( var giveUpAt = i1 + 2; ;) {\r\n\r\n							if ( t1 === undefined ) {\r\n\r\n								if ( t < t0 ) break forward_scan;\r\n\r\n								// after end\r\n\r\n								i1 = pp.length;\r\n								this._cachedIndex = i1;\r\n								return this.afterEnd_( i1 - 1, t, t0 );\r\n\r\n							}\r\n\r\n							if ( i1 === giveUpAt ) break; // this loop\r\n\r\n							t0 = t1;\r\n							t1 = pp[ ++ i1 ];\r\n\r\n							if ( t < t1 ) {\r\n\r\n								// we have arrived at the sought interval\r\n								break seek;\r\n\r\n							}\r\n\r\n						}\r\n\r\n						// prepare binary search on the right side of the index\r\n						right = pp.length;\r\n						break linear_scan;\r\n\r\n					}\r\n\r\n//- slower code:\r\n//-					if ( t < t0 || t0 === undefined ) {\r\n					if ( ! ( t >= t0 ) ) {\r\n\r\n						// looping?\r\n\r\n						var t1global = pp[ 1 ];\r\n\r\n						if ( t < t1global ) {\r\n\r\n							i1 = 2; // + 1, using the scan for the details\r\n							t0 = t1global;\r\n\r\n						}\r\n\r\n						// linear reverse scan\r\n\r\n						for ( var giveUpAt = i1 - 2; ;) {\r\n\r\n							if ( t0 === undefined ) {\r\n\r\n								// before start\r\n\r\n								this._cachedIndex = 0;\r\n								return this.beforeStart_( 0, t, t1 );\r\n\r\n							}\r\n\r\n							if ( i1 === giveUpAt ) break; // this loop\r\n\r\n							t1 = t0;\r\n							t0 = pp[ -- i1 - 1 ];\r\n\r\n							if ( t >= t0 ) {\r\n\r\n								// we have arrived at the sought interval\r\n								break seek;\r\n\r\n							}\r\n\r\n						}\r\n\r\n						// prepare binary search on the left side of the index\r\n						right = i1;\r\n						i1 = 0;\r\n						break linear_scan;\r\n\r\n					}\r\n\r\n					// the interval is valid\r\n\r\n					break validate_interval;\r\n\r\n				} // linear scan\r\n\r\n				// binary search\r\n\r\n				while ( i1 < right ) {\r\n\r\n					var mid = ( i1 + right ) >>> 1;\r\n\r\n					if ( t < pp[ mid ] ) {\r\n\r\n						right = mid;\r\n\r\n					} else {\r\n\r\n						i1 = mid + 1;\r\n\r\n					}\r\n\r\n				}\r\n\r\n				t1 = pp[   i1   ];\r\n				t0 = pp[ i1 - 1 ];\r\n\r\n				// check boundary cases, again\r\n\r\n				if ( t0 === undefined ) {\r\n\r\n					this._cachedIndex = 0;\r\n					return this.beforeStart_( 0, t, t1 );\r\n\r\n				}\r\n\r\n				if ( t1 === undefined ) {\r\n\r\n					i1 = pp.length;\r\n					this._cachedIndex = i1;\r\n					return this.afterEnd_( i1 - 1, t0, t );\r\n\r\n				}\r\n\r\n			} // seek\r\n\r\n			this._cachedIndex = i1;\r\n\r\n			this.intervalChanged_( i1, t0, t1 );\r\n\r\n		} // validate_interval\r\n\r\n		return this.interpolate_( i1, t0, t, t1 );\r\n\r\n	},\r\n\r\n	settings: null, // optional, subclass-specific settings structure\r\n	// Note: The indirection allows central control of many interpolants.\r\n\r\n	// --- Protected interface\r\n\r\n	DefaultSettings_: {},\r\n\r\n	getSettings_: function() {\r\n\r\n		return this.settings || this.DefaultSettings_;\r\n\r\n	},\r\n\r\n	copySampleValue_: function( index ) {\r\n\r\n		// copies a sample value to the result buffer\r\n\r\n		var result = this.resultBuffer,\r\n			values = this.sampleValues,\r\n			stride = this.valueSize,\r\n			offset = index * stride;\r\n\r\n		for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n			result[ i ] = values[ offset + i ];\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	// Template methods for derived classes:\r\n\r\n	interpolate_: function( i1, t0, t, t1 ) {\r\n\r\n		throw new Error( \"call to abstract method\" );\r\n		// implementations shall return this.resultBuffer\r\n\r\n	},\r\n\r\n	intervalChanged_: function( i1, t0, t1 ) {\r\n\r\n		// empty\r\n\r\n	}\r\n\r\n};\r\n\r\nObject.assign( THREE.Interpolant.prototype, {\r\n\r\n	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n		THREE.Interpolant.prototype.copySampleValue_,\r\n\r\n	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n		THREE.Interpolant.prototype.copySampleValue_\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/CubicInterpolant.js\r\n\r\n/**\r\n * Fast and simple cubic spline interpolant.\r\n *\r\n * It was derived from a Hermitian construction setting the first derivative\r\n * at each sample position to the linear slope between neighboring positions\r\n * over their parameter interval.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.CubicInterpolant = function(\r\n		parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n	THREE.Interpolant.call(\r\n			this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n	this._weightPrev = -0;\r\n	this._offsetPrev = -0;\r\n	this._weightNext = -0;\r\n	this._offsetNext = -0;\r\n\r\n};\r\n\r\nTHREE.CubicInterpolant.prototype =\r\n		Object.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n	constructor: THREE.CubicInterpolant,\r\n\r\n	DefaultSettings_: {\r\n\r\n		endingStart: 	THREE.ZeroCurvatureEnding,\r\n		endingEnd:		THREE.ZeroCurvatureEnding\r\n\r\n	},\r\n\r\n	intervalChanged_: function( i1, t0, t1 ) {\r\n\r\n		var pp = this.parameterPositions,\r\n			iPrev = i1 - 2,\r\n			iNext = i1 + 1,\r\n\r\n			tPrev = pp[ iPrev ],\r\n			tNext = pp[ iNext ];\r\n\r\n		if ( tPrev === undefined ) {\r\n\r\n			switch ( this.getSettings_().endingStart ) {\r\n\r\n				case THREE.ZeroSlopeEnding:\r\n\r\n					// f'(t0) = 0\r\n					iPrev = i1;\r\n					tPrev = 2 * t0 - t1;\r\n\r\n					break;\r\n\r\n				case THREE.WrapAroundEnding:\r\n\r\n					// use the other end of the curve\r\n					iPrev = pp.length - 2;\r\n					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\r\n					break;\r\n\r\n				default: // ZeroCurvatureEnding\r\n\r\n					// f''(t0) = 0 a.k.a. Natural Spline\r\n					iPrev = i1;\r\n					tPrev = t1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( tNext === undefined ) {\r\n\r\n			switch ( this.getSettings_().endingEnd ) {\r\n\r\n				case THREE.ZeroSlopeEnding:\r\n\r\n					// f'(tN) = 0\r\n					iNext = i1;\r\n					tNext = 2 * t1 - t0;\r\n\r\n					break;\r\n\r\n				case THREE.WrapAroundEnding:\r\n\r\n					// use the other end of the curve\r\n					iNext = 1;\r\n					tNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\r\n					break;\r\n\r\n				default: // ZeroCurvatureEnding\r\n\r\n					// f''(tN) = 0, a.k.a. Natural Spline\r\n					iNext = i1 - 1;\r\n					tNext = t0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var halfDt = ( t1 - t0 ) * 0.5,\r\n			stride = this.valueSize;\r\n\r\n		this._weightPrev = halfDt / ( t0 - tPrev );\r\n		this._weightNext = halfDt / ( tNext - t1 );\r\n		this._offsetPrev = iPrev * stride;\r\n		this._offsetNext = iNext * stride;\r\n\r\n	},\r\n\r\n	interpolate_: function( i1, t0, t, t1 ) {\r\n\r\n		var result = this.resultBuffer,\r\n			values = this.sampleValues,\r\n			stride = this.valueSize,\r\n\r\n			o1 = i1 * stride,		o0 = o1 - stride,\r\n			oP = this._offsetPrev, 	oN = this._offsetNext,\r\n			wP = this._weightPrev,	wN = this._weightNext,\r\n\r\n			p = ( t - t0 ) / ( t1 - t0 ),\r\n			pp = p * p,\r\n			ppp = pp * p;\r\n\r\n		// evaluate polynomials\r\n\r\n		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n		var sN =       wN   * ppp   -           wN      * pp;\r\n\r\n		// combine data linearly\r\n\r\n		for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n			result[ i ] =\r\n					sP * values[ oP + i ] +\r\n					s0 * values[ o0 + i ] +\r\n					s1 * values[ o1 + i ] +\r\n					sN * values[ oN + i ];\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/DiscreteInterpolant.js\r\n\r\n/**\r\n *\r\n * Interpolant that evaluates to the sample value at the position preceeding\r\n * the parameter.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.DiscreteInterpolant = function(\r\n		parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n	THREE.Interpolant.call(\r\n			this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.DiscreteInterpolant.prototype =\r\n		Object.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n	constructor: THREE.DiscreteInterpolant,\r\n\r\n	interpolate_: function( i1, t0, t, t1 ) {\r\n\r\n		return this.copySampleValue_( i1 - 1 );\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/LinearInterpolant.js\r\n\r\n/**\r\n * @author tschw\r\n */\r\n\r\nTHREE.LinearInterpolant = function(\r\n		parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n	THREE.Interpolant.call(\r\n			this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.LinearInterpolant.prototype =\r\n		Object.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n	constructor: THREE.LinearInterpolant,\r\n\r\n	interpolate_: function( i1, t0, t, t1 ) {\r\n\r\n		var result = this.resultBuffer,\r\n			values = this.sampleValues,\r\n			stride = this.valueSize,\r\n\r\n			offset1 = i1 * stride,\r\n			offset0 = offset1 - stride,\r\n\r\n			weight1 = ( t - t0 ) / ( t1 - t0 ),\r\n			weight0 = 1 - weight1;\r\n\r\n		for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n			result[ i ] =\r\n					values[ offset0 + i ] * weight0 +\r\n					values[ offset1 + i ] * weight1;\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\r\n/**\r\n * Spherical linear unit quaternion interpolant.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionLinearInterpolant = function(\r\n		parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n	THREE.Interpolant.call(\r\n			this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.QuaternionLinearInterpolant.prototype =\r\n		Object.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n	constructor: THREE.QuaternionLinearInterpolant,\r\n\r\n	interpolate_: function( i1, t0, t, t1 ) {\r\n\r\n		var result = this.resultBuffer,\r\n			values = this.sampleValues,\r\n			stride = this.valueSize,\r\n\r\n			offset = i1 * stride,\r\n\r\n			alpha = ( t - t0 ) / ( t1 - t0 );\r\n\r\n		for ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\r\n			THREE.Quaternion.slerpFlat( result, 0,\r\n					values, offset - stride, values, offset, alpha );\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n	this.startTime = 0;\r\n	this.oldTime = 0;\r\n	this.elapsedTime = 0;\r\n\r\n	this.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n	constructor: THREE.Clock,\r\n\r\n	start: function () {\r\n\r\n		this.startTime = performance.now();\r\n\r\n		this.oldTime = this.startTime;\r\n		this.running = true;\r\n\r\n	},\r\n\r\n	stop: function () {\r\n\r\n		this.getElapsedTime();\r\n		this.running = false;\r\n\r\n	},\r\n\r\n	getElapsedTime: function () {\r\n\r\n		this.getDelta();\r\n		return this.elapsedTime;\r\n\r\n	},\r\n\r\n	getDelta: function () {\r\n\r\n		var diff = 0;\r\n\r\n		if ( this.autoStart && ! this.running ) {\r\n\r\n			this.start();\r\n\r\n		}\r\n\r\n		if ( this.running ) {\r\n\r\n			var newTime = performance.now();\r\n\r\n			diff = 0.001 * ( newTime - this.oldTime );\r\n			this.oldTime = newTime;\r\n\r\n			this.elapsedTime += diff;\r\n\r\n		}\r\n\r\n		return diff;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {};\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n	constructor: THREE.EventDispatcher,\r\n\r\n	apply: function ( object ) {\r\n\r\n		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n	},\r\n\r\n	addEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) this._listeners = {};\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] === undefined ) {\r\n\r\n			listeners[ type ] = [];\r\n\r\n		}\r\n\r\n		if ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n			listeners[ type ].push( listener );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	hasEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return false;\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	removeEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			var index = listenerArray.indexOf( listener );\r\n\r\n			if ( index !== - 1 ) {\r\n\r\n				listenerArray.splice( index, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	dispatchEvent: function ( event ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ event.type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			event.target = this;\r\n\r\n			var array = [];\r\n			var length = listenerArray.length;\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ] = listenerArray[ i ];\r\n\r\n			}\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ].call( this, event );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Layers.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Layers = function () {\r\n\r\n	this.mask = 1;\r\n\r\n};\r\n\r\nTHREE.Layers.prototype = {\r\n\r\n	constructor: THREE.Layers,\r\n\r\n	set: function ( channel ) {\r\n\r\n		this.mask = 1 << channel;\r\n\r\n	},\r\n\r\n	enable: function ( channel ) {\r\n\r\n		this.mask |= 1 << channel;\r\n\r\n	},\r\n\r\n	toggle: function ( channel ) {\r\n\r\n		this.mask ^= 1 << channel;\r\n\r\n	},\r\n\r\n	disable: function ( channel ) {\r\n\r\n		this.mask &= ~ ( 1 << channel );\r\n\r\n	},\r\n\r\n	test: function ( layers ) {\r\n\r\n		return ( this.mask & layers.mask ) !== 0;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n	THREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n		this.ray = new THREE.Ray( origin, direction );\r\n		// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n		this.near = near || 0;\r\n		this.far = far || Infinity;\r\n\r\n		this.params = {\r\n			Mesh: {},\r\n			Line: {},\r\n			LOD: {},\r\n			Points: { threshold: 1 },\r\n			Sprite: {}\r\n		};\r\n\r\n		Object.defineProperties( this.params, {\r\n			PointCloud: {\r\n				get: function () {\r\n					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n					return this.Points;\r\n				}\r\n			}\r\n		} );\r\n\r\n	};\r\n\r\n	function ascSort( a, b ) {\r\n\r\n		return a.distance - b.distance;\r\n\r\n	}\r\n\r\n	function intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		object.raycast( raycaster, intersects );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			var children = object.children;\r\n\r\n			for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n				intersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	//\r\n\r\n	THREE.Raycaster.prototype = {\r\n\r\n		constructor: THREE.Raycaster,\r\n\r\n		linePrecision: 1,\r\n\r\n		set: function ( origin, direction ) {\r\n\r\n			// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n			this.ray.set( origin, direction );\r\n\r\n		},\r\n\r\n		setFromCamera: function ( coords, camera ) {\r\n\r\n			if ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n			} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n			} else {\r\n\r\n				console.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n			}\r\n\r\n		},\r\n\r\n		intersectObject: function ( object, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			intersectObject( object, this, intersects, recursive );\r\n\r\n			intersects.sort( ascSort );\r\n\r\n			return intersects;\r\n\r\n		},\r\n\r\n		intersectObjects: function ( objects, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			if ( Array.isArray( objects ) === false ) {\r\n\r\n				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n				return intersects;\r\n\r\n			}\r\n\r\n			for ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n				intersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n			}\r\n\r\n			intersects.sort( ascSort );\r\n\r\n			return intersects;\r\n\r\n		}\r\n\r\n	};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Object3D';\r\n\r\n	this.parent = null;\r\n	this.children = [];\r\n\r\n	this.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n	var position = new THREE.Vector3();\r\n	var rotation = new THREE.Euler();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n	function onRotationChange() {\r\n\r\n		quaternion.setFromEuler( rotation, false );\r\n\r\n	}\r\n\r\n	function onQuaternionChange() {\r\n\r\n		rotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n	}\r\n\r\n	rotation.onChange( onRotationChange );\r\n	quaternion.onChange( onQuaternionChange );\r\n\r\n	Object.defineProperties( this, {\r\n		position: {\r\n			enumerable: true,\r\n			value: position\r\n		},\r\n		rotation: {\r\n			enumerable: true,\r\n			value: rotation\r\n		},\r\n		quaternion: {\r\n			enumerable: true,\r\n			value: quaternion\r\n		},\r\n		scale: {\r\n			enumerable: true,\r\n			value: scale\r\n		},\r\n		modelViewMatrix: {\r\n			value: new THREE.Matrix4()\r\n		},\r\n		normalMatrix: {\r\n			value: new THREE.Matrix3()\r\n		}\r\n	} );\r\n\r\n	this.rotationAutoUpdate = true;\r\n\r\n	this.matrix = new THREE.Matrix4();\r\n	this.matrixWorld = new THREE.Matrix4();\r\n\r\n	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n	this.matrixWorldNeedsUpdate = false;\r\n\r\n	this.layers = new THREE.Layers();\r\n	this.visible = true;\r\n\r\n	this.castShadow = false;\r\n	this.receiveShadow = false;\r\n\r\n	this.frustumCulled = true;\r\n	this.renderOrder = 0;\r\n\r\n	this.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n	constructor: THREE.Object3D,\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		this.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n		this.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n	},\r\n\r\n	setRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// assumes axis is normalized\r\n\r\n		this.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n	},\r\n\r\n	setRotationFromEuler: function ( euler ) {\r\n\r\n		this.quaternion.setFromEuler( euler, true );\r\n\r\n	},\r\n\r\n	setRotationFromMatrix: function ( m ) {\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		this.quaternion.setFromRotationMatrix( m );\r\n\r\n	},\r\n\r\n	setRotationFromQuaternion: function ( q ) {\r\n\r\n		// assumes q is normalized\r\n\r\n		this.quaternion.copy( q );\r\n\r\n	},\r\n\r\n	rotateOnAxis: function () {\r\n\r\n		// rotate object on axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var q1 = new THREE.Quaternion();\r\n\r\n		return function ( axis, angle ) {\r\n\r\n			q1.setFromAxisAngle( axis, angle );\r\n\r\n			this.quaternion.multiply( q1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateOnAxis: function () {\r\n\r\n		// translate object by distance along axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( axis, distance ) {\r\n\r\n			v1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n			this.position.add( v1.multiplyScalar( distance ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	localToWorld: function ( vector ) {\r\n\r\n		return vector.applyMatrix4( this.matrixWorld );\r\n\r\n	},\r\n\r\n	worldToLocal: function () {\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			m1.lookAt( vector, this.position, this.up );\r\n\r\n			this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	add: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n				this.add( arguments[ i ] );\r\n\r\n			}\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		if ( object === this ) {\r\n\r\n			console.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n			return this;\r\n\r\n		}\r\n\r\n		if ( object instanceof THREE.Object3D ) {\r\n\r\n			if ( object.parent !== null ) {\r\n\r\n				object.parent.remove( object );\r\n\r\n			}\r\n\r\n			object.parent = this;\r\n			object.dispatchEvent( { type: 'added' } );\r\n\r\n			this.children.push( object );\r\n\r\n		} else {\r\n\r\n			console.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	remove: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n				this.remove( arguments[ i ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var index = this.children.indexOf( object );\r\n\r\n		if ( index !== - 1 ) {\r\n\r\n			object.parent = null;\r\n\r\n			object.dispatchEvent( { type: 'removed' } );\r\n\r\n			this.children.splice( index, 1 );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getObjectById: function ( id ) {\r\n\r\n		return this.getObjectByProperty( 'id', id );\r\n\r\n	},\r\n\r\n	getObjectByName: function ( name ) {\r\n\r\n		return this.getObjectByProperty( 'name', name );\r\n\r\n	},\r\n\r\n	getObjectByProperty: function ( name, value ) {\r\n\r\n		if ( this[ name ] === value ) return this;\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			var child = this.children[ i ];\r\n			var object = child.getObjectByProperty( name, value );\r\n\r\n			if ( object !== undefined ) {\r\n\r\n				return object;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return undefined;\r\n\r\n	},\r\n\r\n	getWorldPosition: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.updateMatrixWorld( true );\r\n\r\n		return result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n	},\r\n\r\n	getWorldQuaternion: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var scale = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Quaternion();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, result, scale );\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldRotation: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Euler();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldScale: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, quaternion, result );\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getWorldDirection: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	raycast: function () {},\r\n\r\n	traverse: function ( callback ) {\r\n\r\n		callback( this );\r\n\r\n		var children = this.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			children[ i ].traverse( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseVisible: function ( callback ) {\r\n\r\n		if ( this.visible === false ) return;\r\n\r\n		callback( this );\r\n\r\n		var children = this.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			children[ i ].traverseVisible( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseAncestors: function ( callback ) {\r\n\r\n		var parent = this.parent;\r\n\r\n		if ( parent !== null ) {\r\n\r\n			callback( parent );\r\n\r\n			parent.traverseAncestors( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	updateMatrix: function () {\r\n\r\n		this.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n		this.matrixWorldNeedsUpdate = true;\r\n\r\n	},\r\n\r\n	updateMatrixWorld: function ( force ) {\r\n\r\n		if ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n		if ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n			if ( this.parent === null ) {\r\n\r\n				this.matrixWorld.copy( this.matrix );\r\n\r\n			} else {\r\n\r\n				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n			}\r\n\r\n			this.matrixWorldNeedsUpdate = false;\r\n\r\n			force = true;\r\n\r\n		}\r\n\r\n		// update children\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].updateMatrixWorld( force );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		var isRootObject = ( meta === undefined );\r\n\r\n		var output = {};\r\n\r\n		// meta is a hash used to collect geometries, materials.\r\n		// not providing it implies that this is the root object\r\n		// being serialized.\r\n		if ( isRootObject ) {\r\n\r\n			// initialize meta obj\r\n			meta = {\r\n				geometries: {},\r\n				materials: {},\r\n				textures: {},\r\n				images: {}\r\n			};\r\n\r\n			output.metadata = {\r\n				version: 4.4,\r\n				type: 'Object',\r\n				generator: 'Object3D.toJSON'\r\n			};\r\n\r\n		}\r\n\r\n		// standard Object3D serialization\r\n\r\n		var object = {};\r\n\r\n		object.uuid = this.uuid;\r\n		object.type = this.type;\r\n\r\n		if ( this.name !== '' ) object.name = this.name;\r\n		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n		if ( this.castShadow === true ) object.castShadow = true;\r\n		if ( this.receiveShadow === true ) object.receiveShadow = true;\r\n		if ( this.visible === false ) object.visible = false;\r\n\r\n		object.matrix = this.matrix.toArray();\r\n\r\n		//\r\n\r\n		if ( this.geometry !== undefined ) {\r\n\r\n			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\r\n			}\r\n\r\n			object.geometry = this.geometry.uuid;\r\n\r\n		}\r\n\r\n		if ( this.material !== undefined ) {\r\n\r\n			if ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\r\n			}\r\n\r\n			object.material = this.material.uuid;\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( this.children.length > 0 ) {\r\n\r\n			object.children = [];\r\n\r\n			for ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n				object.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( isRootObject ) {\r\n\r\n			var geometries = extractFromCache( meta.geometries );\r\n			var materials = extractFromCache( meta.materials );\r\n			var textures = extractFromCache( meta.textures );\r\n			var images = extractFromCache( meta.images );\r\n\r\n			if ( geometries.length > 0 ) output.geometries = geometries;\r\n			if ( materials.length > 0 ) output.materials = materials;\r\n			if ( textures.length > 0 ) output.textures = textures;\r\n			if ( images.length > 0 ) output.images = images;\r\n\r\n		}\r\n\r\n		output.object = object;\r\n\r\n		return output;\r\n\r\n		// extract data from the cache hash\r\n		// remove metadata on each item\r\n		// and return as array\r\n		function extractFromCache ( cache ) {\r\n\r\n			var values = [];\r\n			for ( var key in cache ) {\r\n\r\n				var data = cache[ key ];\r\n				delete data.metadata;\r\n				values.push( data );\r\n\r\n			}\r\n			return values;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	clone: function ( recursive ) {\r\n\r\n		return new this.constructor().copy( this, recursive );\r\n\r\n	},\r\n\r\n	copy: function ( source, recursive ) {\r\n\r\n		if ( recursive === undefined ) recursive = true;\r\n\r\n		this.name = source.name;\r\n\r\n		this.up.copy( source.up );\r\n\r\n		this.position.copy( source.position );\r\n		this.quaternion.copy( source.quaternion );\r\n		this.scale.copy( source.scale );\r\n\r\n		this.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\r\n		this.matrix.copy( source.matrix );\r\n		this.matrixWorld.copy( source.matrixWorld );\r\n\r\n		this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n		this.visible = source.visible;\r\n\r\n		this.castShadow = source.castShadow;\r\n		this.receiveShadow = source.receiveShadow;\r\n\r\n		this.frustumCulled = source.frustumCulled;\r\n		this.renderOrder = source.renderOrder;\r\n\r\n		this.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			for ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n				var child = source.children[ i ];\r\n				this.add( child.clone() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n	this.a = a;\r\n	this.b = b;\r\n	this.c = c;\r\n\r\n	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n	this.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n	this.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n	this.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n	constructor: THREE.Face3,\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.a = source.a;\r\n		this.b = source.b;\r\n		this.c = source.c;\r\n\r\n		this.normal.copy( source.normal );\r\n		this.color.copy( source.color );\r\n\r\n		this.materialIndex = source.materialIndex;\r\n\r\n		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n			this.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.array = array;\r\n	this.itemSize = itemSize;\r\n\r\n	this.dynamic = false;\r\n	this.updateRange = { offset: 0, count: - 1 };\r\n\r\n	this.version = 0;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n	constructor: THREE.BufferAttribute,\r\n\r\n	get count() {\r\n\r\n		return this.array.length / this.itemSize;\r\n\r\n	},\r\n\r\n	set needsUpdate( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	setDynamic: function ( value ) {\r\n\r\n		this.dynamic = value;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.array = new source.array.constructor( source.array );\r\n		this.itemSize = source.itemSize;\r\n\r\n		this.dynamic = source.dynamic;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyAt: function ( index1, attribute, index2 ) {\r\n\r\n		index1 *= this.itemSize;\r\n		index2 *= attribute.itemSize;\r\n\r\n		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n			this.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyArray: function ( array ) {\r\n\r\n		this.array.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyColorsArray: function ( colors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n			var color = colors[ i ];\r\n\r\n			if ( color === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n				color = new THREE.Color();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = color.r;\r\n			array[ offset ++ ] = color.g;\r\n			array[ offset ++ ] = color.b;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyIndicesArray: function ( indices ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n			var index = indices[ i ];\r\n\r\n			array[ offset ++ ] = index.a;\r\n			array[ offset ++ ] = index.b;\r\n			array[ offset ++ ] = index.c;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector2sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector2();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector3sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector3();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n			array[ offset ++ ] = vector.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyVector4sArray: function ( vectors ) {\r\n\r\n		var array = this.array, offset = 0;\r\n\r\n		for ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n			var vector = vectors[ i ];\r\n\r\n			if ( vector === undefined ) {\r\n\r\n				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n				vector = new THREE.Vector4();\r\n\r\n			}\r\n\r\n			array[ offset ++ ] = vector.x;\r\n			array[ offset ++ ] = vector.y;\r\n			array[ offset ++ ] = vector.z;\r\n			array[ offset ++ ] = vector.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	set: function ( value, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.array.set( value, offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getX: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize ];\r\n\r\n	},\r\n\r\n	setX: function ( index, x ) {\r\n\r\n		this.array[ index * this.itemSize ] = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getY: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 1 ];\r\n\r\n	},\r\n\r\n	setY: function ( index, y ) {\r\n\r\n		this.array[ index * this.itemSize + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getZ: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 2 ];\r\n\r\n	},\r\n\r\n	setZ: function ( index, z ) {\r\n\r\n		this.array[ index * this.itemSize + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getW: function ( index ) {\r\n\r\n		return this.array[ index * this.itemSize + 3 ];\r\n\r\n	},\r\n\r\n	setW: function ( index, w ) {\r\n\r\n		this.array[ index * this.itemSize + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXY: function ( index, x, y ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZ: function ( index, x, y, z ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZW: function ( index, x, y, z, w ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index + 0 ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n		this.array[ index + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\r\n	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\r\n};\r\n\r\n\r\n// Deprecated\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\r\n};\r\n\r\n// File:src/core/InstancedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\r\n	THREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n	this.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\r\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\r\n	THREE.BufferAttribute.prototype.copy.call( this, source );\r\n\r\n	this.meshPerAttribute = source.meshPerAttribute;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.array = array;\r\n	this.stride = stride;\r\n\r\n	this.dynamic = false;\r\n	this.updateRange = { offset: 0, count: - 1 };\r\n\r\n	this.version = 0;\r\n\r\n};\r\n\r\nTHREE.InterleavedBuffer.prototype = {\r\n\r\n	constructor: THREE.InterleavedBuffer,\r\n\r\n	get length () {\r\n\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	get count () {\r\n\r\n		return this.array.length / this.stride;\r\n\r\n	},\r\n\r\n	set needsUpdate( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	setDynamic: function ( value ) {\r\n\r\n		this.dynamic = value;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.array = new source.array.constructor( source.array );\r\n		this.stride = source.stride;\r\n		this.dynamic = source.dynamic;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyAt: function ( index1, attribute, index2 ) {\r\n\r\n		index1 *= this.stride;\r\n		index2 *= attribute.stride;\r\n\r\n		for ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n			this.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	set: function ( value, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.array.set( value, offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/InstancedInterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\r\n	THREE.InterleavedBuffer.call( this, array, stride );\r\n\r\n	this.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\r\n	THREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n	this.meshPerAttribute = source.meshPerAttribute;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.data = interleavedBuffer;\r\n	this.itemSize = itemSize;\r\n	this.offset = offset;\r\n\r\n};\r\n\r\n\r\nTHREE.InterleavedBufferAttribute.prototype = {\r\n\r\n	constructor: THREE.InterleavedBufferAttribute,\r\n\r\n	get length() {\r\n\r\n		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	get count() {\r\n\r\n		return this.data.count;\r\n\r\n	},\r\n\r\n	setX: function ( index, x ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( index, y ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( index, z ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setW: function ( index, w ) {\r\n\r\n		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getX: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n	},\r\n\r\n	getY: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n	},\r\n\r\n	getZ: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n	},\r\n\r\n	getW: function ( index ) {\r\n\r\n		return this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n	},\r\n\r\n	setXY: function ( index, x, y ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZ: function ( index, x, y, z ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n		this.data.array[ index + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZW: function ( index, x, y, z, w ) {\r\n\r\n		index = index * this.data.stride + this.offset;\r\n\r\n		this.data.array[ index + 0 ] = x;\r\n		this.data.array[ index + 1 ] = y;\r\n		this.data.array[ index + 2 ] = z;\r\n		this.data.array[ index + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Geometry';\r\n\r\n	this.vertices = [];\r\n	this.colors = [];\r\n	this.faces = [];\r\n	this.faceVertexUvs = [ [] ];\r\n\r\n	this.morphTargets = [];\r\n	this.morphNormals = [];\r\n\r\n	this.skinWeights = [];\r\n	this.skinIndices = [];\r\n\r\n	this.lineDistances = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	// update flags\r\n\r\n	this.verticesNeedUpdate = false;\r\n	this.elementsNeedUpdate = false;\r\n	this.uvsNeedUpdate = false;\r\n	this.normalsNeedUpdate = false;\r\n	this.colorsNeedUpdate = false;\r\n	this.lineDistancesNeedUpdate = false;\r\n	this.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n	constructor: THREE.Geometry,\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertex.applyMatrix4( matrix );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n			face.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.boundingBox !== null ) {\r\n\r\n			this.computeBoundingBox();\r\n\r\n		}\r\n\r\n		if ( this.boundingSphere !== null ) {\r\n\r\n			this.computeBoundingSphere();\r\n\r\n		}\r\n\r\n		this.verticesNeedUpdate = true;\r\n		this.normalsNeedUpdate = true;\r\n\r\n	},\r\n\r\n	rotateX: function () {\r\n\r\n		// rotate geometry around world x-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateX( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationX( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		// rotate geometry around world y-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateY( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationY( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		// rotate geometry around world z-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateZ( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationZ( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function () {\r\n\r\n		// translate geometry\r\n\r\n		var m1;\r\n\r\n		return function translate( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeTranslation( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	scale: function () {\r\n\r\n		// scale geometry\r\n\r\n		var m1;\r\n\r\n		return function scale( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeScale( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		var obj;\r\n\r\n		return function lookAt( vector ) {\r\n\r\n			if ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n			obj.lookAt( vector );\r\n\r\n			obj.updateMatrix();\r\n\r\n			this.applyMatrix( obj.matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	fromBufferGeometry: function ( geometry ) {\r\n\r\n		var scope = this;\r\n\r\n		var indices = geometry.index !== null ? geometry.index.array : undefined;\r\n		var attributes = geometry.attributes;\r\n\r\n		var positions = attributes.position.array;\r\n		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n		var colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n		var tempNormals = [];\r\n		var tempUVs = [];\r\n		var tempUVs2 = [];\r\n\r\n		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n			scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\r\n			if ( normals !== undefined ) {\r\n\r\n				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( colors !== undefined ) {\r\n\r\n				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n			}\r\n\r\n			if ( uvs2 !== undefined ) {\r\n\r\n				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function addFace( a, b, c ) {\r\n\r\n			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );\r\n\r\n			scope.faces.push( face );\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n			}\r\n\r\n			if ( uvs2 !== undefined ) {\r\n\r\n				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( indices !== undefined ) {\r\n\r\n			var groups = geometry.groups;\r\n\r\n			if ( groups.length > 0 ) {\r\n\r\n				for ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n					var group = groups[ i ];\r\n\r\n					var start = group.start;\r\n					var count = group.count;\r\n\r\n					for ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				for ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n				addFace( i, i + 1, i + 2 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeFaceNormals();\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			this.boundingBox = geometry.boundingBox.clone();\r\n\r\n		}\r\n\r\n		if ( geometry.boundingSphere !== null ) {\r\n\r\n			this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function () {\r\n\r\n		this.computeBoundingBox();\r\n\r\n		var offset = this.boundingBox.center().negate();\r\n\r\n		this.translate( offset.x, offset.y, offset.z );\r\n\r\n		return offset;\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		this.computeBoundingSphere();\r\n\r\n		var center = this.boundingSphere.center;\r\n		var radius = this.boundingSphere.radius;\r\n\r\n		var s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n		var matrix = new THREE.Matrix4();\r\n		matrix.set(\r\n			s, 0, 0, - s * center.x,\r\n			0, s, 0, - s * center.y,\r\n			0, 0, s, - s * center.z,\r\n			0, 0, 0, 1\r\n		);\r\n\r\n		this.applyMatrix( matrix );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		var cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			var face = this.faces[ f ];\r\n\r\n			var vA = this.vertices[ face.a ];\r\n			var vB = this.vertices[ face.b ];\r\n			var vC = this.vertices[ face.c ];\r\n\r\n			cb.subVectors( vC, vB );\r\n			ab.subVectors( vA, vB );\r\n			cb.cross( ab );\r\n\r\n			cb.normalize();\r\n\r\n			face.normal.copy( cb );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeVertexNormals: function ( areaWeighted ) {\r\n\r\n		if ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n		var v, vl, f, fl, face, vertices;\r\n\r\n		vertices = new Array( this.vertices.length );\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		if ( areaWeighted ) {\r\n\r\n			// vertex normals weighted by triangle areas\r\n			// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n			var vA, vB, vC;\r\n			var cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vA = this.vertices[ face.a ];\r\n				vB = this.vertices[ face.b ];\r\n				vC = this.vertices[ face.c ];\r\n\r\n				cb.subVectors( vC, vB );\r\n				ab.subVectors( vA, vB );\r\n				cb.cross( ab );\r\n\r\n				vertices[ face.a ].add( cb );\r\n				vertices[ face.b ].add( cb );\r\n				vertices[ face.c ].add( cb );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vertices[ face.a ].add( face.normal );\r\n				vertices[ face.b ].add( face.normal );\r\n				vertices[ face.c ].add( face.normal );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ].normalize();\r\n\r\n		}\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			var vertexNormals = face.vertexNormals;\r\n\r\n			if ( vertexNormals.length === 3 ) {\r\n\r\n				vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n				vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n				vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n			} else {\r\n\r\n				vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n				vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n				vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.faces.length > 0 ) {\r\n\r\n			this.normalsNeedUpdate = true;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeMorphNormals: function () {\r\n\r\n		var i, il, f, fl, face;\r\n\r\n		// save original normals\r\n		// - create temp variables on first access\r\n		//   otherwise just copy (for faster repeated calls)\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			if ( ! face.__originalFaceNormal ) {\r\n\r\n				face.__originalFaceNormal = face.normal.clone();\r\n\r\n			} else {\r\n\r\n				face.__originalFaceNormal.copy( face.normal );\r\n\r\n			}\r\n\r\n			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n				if ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n				} else {\r\n\r\n					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// use temp geometry to compute face and vertex normals for each morph\r\n\r\n		var tmpGeo = new THREE.Geometry();\r\n		tmpGeo.faces = this.faces;\r\n\r\n		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n			// create on first access\r\n\r\n			if ( ! this.morphNormals[ i ] ) {\r\n\r\n				this.morphNormals[ i ] = {};\r\n				this.morphNormals[ i ].faceNormals = [];\r\n				this.morphNormals[ i ].vertexNormals = [];\r\n\r\n				var dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n				var faceNormal, vertexNormals;\r\n\r\n				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n					faceNormal = new THREE.Vector3();\r\n					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n					dstNormalsFace.push( faceNormal );\r\n					dstNormalsVertex.push( vertexNormals );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var morphNormals = this.morphNormals[ i ];\r\n\r\n			// set vertices to morph target\r\n\r\n			tmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n			// compute morph normals\r\n\r\n			tmpGeo.computeFaceNormals();\r\n			tmpGeo.computeVertexNormals();\r\n\r\n			// store morph normals\r\n\r\n			var faceNormal, vertexNormals;\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				faceNormal = morphNormals.faceNormals[ f ];\r\n				vertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n				faceNormal.copy( face.normal );\r\n\r\n				vertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n				vertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n				vertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore original normals\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			face.normal = face.__originalFaceNormal;\r\n			face.vertexNormals = face.__originalVertexNormals;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeTangents: function () {\r\n\r\n		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\r\n	},\r\n\r\n	computeLineDistances: function () {\r\n\r\n		var d = 0;\r\n		var vertices = this.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			if ( i > 0 ) {\r\n\r\n				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n			}\r\n\r\n			this.lineDistances[ i ] = d;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		if ( this.boundingBox === null ) {\r\n\r\n			this.boundingBox = new THREE.Box3();\r\n\r\n		}\r\n\r\n		this.boundingBox.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		if ( this.boundingSphere === null ) {\r\n\r\n			this.boundingSphere = new THREE.Sphere();\r\n\r\n		}\r\n\r\n		this.boundingSphere.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	merge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n		if ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		var normalMatrix,\r\n		vertexOffset = this.vertices.length,\r\n		vertices1 = this.vertices,\r\n		vertices2 = geometry.vertices,\r\n		faces1 = this.faces,\r\n		faces2 = geometry.faces,\r\n		uvs1 = this.faceVertexUvs[ 0 ],\r\n		uvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n		if ( matrix !== undefined ) {\r\n\r\n			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		}\r\n\r\n		// vertices\r\n\r\n		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n			var vertex = vertices2[ i ];\r\n\r\n			var vertexCopy = vertex.clone();\r\n\r\n			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n			vertices1.push( vertexCopy );\r\n\r\n		}\r\n\r\n		// faces\r\n\r\n		for ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n			var face = faces2[ i ], faceCopy, normal, color,\r\n			faceVertexNormals = face.vertexNormals,\r\n			faceVertexColors = face.vertexColors;\r\n\r\n			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n			faceCopy.normal.copy( face.normal );\r\n\r\n			if ( normalMatrix !== undefined ) {\r\n\r\n				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n				normal = faceVertexNormals[ j ].clone();\r\n\r\n				if ( normalMatrix !== undefined ) {\r\n\r\n					normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n				}\r\n\r\n				faceCopy.vertexNormals.push( normal );\r\n\r\n			}\r\n\r\n			faceCopy.color.copy( face.color );\r\n\r\n			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n				color = faceVertexColors[ j ];\r\n				faceCopy.vertexColors.push( color.clone() );\r\n\r\n			}\r\n\r\n			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n			faces1.push( faceCopy );\r\n\r\n		}\r\n\r\n		// uvs\r\n\r\n		for ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n			var uv = uvs2[ i ], uvCopy = [];\r\n\r\n			if ( uv === undefined ) {\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n				uvCopy.push( uv[ j ].clone() );\r\n\r\n			}\r\n\r\n			uvs1.push( uvCopy );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	mergeMesh: function ( mesh ) {\r\n\r\n		if ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n			return;\r\n\r\n		}\r\n\r\n		mesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n		this.merge( mesh.geometry, mesh.matrix );\r\n\r\n	},\r\n\r\n	/*\r\n	 * Checks for duplicate vertices with hashmap.\r\n	 * Duplicated vertices are removed\r\n	 * and faces' vertices are updated.\r\n	 */\r\n\r\n	mergeVertices: function () {\r\n\r\n		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n		var unique = [], changes = [];\r\n\r\n		var v, key;\r\n		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n		var precision = Math.pow( 10, precisionPoints );\r\n		var i, il, face;\r\n		var indices, j, jl;\r\n\r\n		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			v = this.vertices[ i ];\r\n			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n			if ( verticesMap[ key ] === undefined ) {\r\n\r\n				verticesMap[ key ] = i;\r\n				unique.push( this.vertices[ i ] );\r\n				changes[ i ] = unique.length - 1;\r\n\r\n			} else {\r\n\r\n				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n				changes[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		// if faces are completely degenerate after merging vertices, we\r\n		// have to remove them from the geometry.\r\n		var faceIndicesToRemove = [];\r\n\r\n		for ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			face = this.faces[ i ];\r\n\r\n			face.a = changes[ face.a ];\r\n			face.b = changes[ face.b ];\r\n			face.c = changes[ face.c ];\r\n\r\n			indices = [ face.a, face.b, face.c ];\r\n\r\n			var dupIndex = - 1;\r\n\r\n			// if any duplicate vertices are found in a Face3\r\n			// we have to remove the face as nothing can be saved\r\n			for ( var n = 0; n < 3; n ++ ) {\r\n\r\n				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n					dupIndex = n;\r\n					faceIndicesToRemove.push( i );\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n			var idx = faceIndicesToRemove[ i ];\r\n\r\n			this.faces.splice( idx, 1 );\r\n\r\n			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				this.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Use unique set of vertices\r\n\r\n		var diff = this.vertices.length - unique.length;\r\n		this.vertices = unique;\r\n		return diff;\r\n\r\n	},\r\n\r\n	sortFacesByMaterialIndex: function () {\r\n\r\n		var faces = this.faces;\r\n		var length = faces.length;\r\n\r\n		// tag faces\r\n\r\n		for ( var i = 0; i < length; i ++ ) {\r\n\r\n			faces[ i ]._id = i;\r\n\r\n		}\r\n\r\n		// sort faces\r\n\r\n		function materialIndexSort( a, b ) {\r\n\r\n			return a.materialIndex - b.materialIndex;\r\n\r\n		}\r\n\r\n		faces.sort( materialIndexSort );\r\n\r\n		// sort uvs\r\n\r\n		var uvs1 = this.faceVertexUvs[ 0 ];\r\n		var uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n		var newUvs1, newUvs2;\r\n\r\n		if ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n		if ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n		for ( var i = 0; i < length; i ++ ) {\r\n\r\n			var id = faces[ i ]._id;\r\n\r\n			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n		}\r\n\r\n		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Geometry',\r\n				generator: 'Geometry.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard Geometry serialization\r\n\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.parameters !== undefined ) {\r\n\r\n			var parameters = this.parameters;\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n			}\r\n\r\n			return data;\r\n\r\n		}\r\n\r\n		var vertices = [];\r\n\r\n		for ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n		}\r\n\r\n		var faces = [];\r\n		var normals = [];\r\n		var normalsHash = {};\r\n		var colors = [];\r\n		var colorsHash = {};\r\n		var uvs = [];\r\n		var uvsHash = {};\r\n\r\n		for ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n\r\n			var hasMaterial = true;\r\n			var hasFaceUv = false; // deprecated\r\n			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n			var hasFaceNormal = face.normal.length() > 0;\r\n			var hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n			var hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n			var faceType = 0;\r\n\r\n			faceType = setBit( faceType, 0, 0 ); // isQuad\r\n			faceType = setBit( faceType, 1, hasMaterial );\r\n			faceType = setBit( faceType, 2, hasFaceUv );\r\n			faceType = setBit( faceType, 3, hasFaceVertexUv );\r\n			faceType = setBit( faceType, 4, hasFaceNormal );\r\n			faceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n			faceType = setBit( faceType, 6, hasFaceColor );\r\n			faceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n			faces.push( faceType );\r\n			faces.push( face.a, face.b, face.c );\r\n			faces.push( face.materialIndex );\r\n\r\n			if ( hasFaceVertexUv ) {\r\n\r\n				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n				faces.push(\r\n					getUvIndex( faceVertexUvs[ 0 ] ),\r\n					getUvIndex( faceVertexUvs[ 1 ] ),\r\n					getUvIndex( faceVertexUvs[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceNormal ) {\r\n\r\n				faces.push( getNormalIndex( face.normal ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexNormal ) {\r\n\r\n				var vertexNormals = face.vertexNormals;\r\n\r\n				faces.push(\r\n					getNormalIndex( vertexNormals[ 0 ] ),\r\n					getNormalIndex( vertexNormals[ 1 ] ),\r\n					getNormalIndex( vertexNormals[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceColor ) {\r\n\r\n				faces.push( getColorIndex( face.color ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexColor ) {\r\n\r\n				var vertexColors = face.vertexColors;\r\n\r\n				faces.push(\r\n					getColorIndex( vertexColors[ 0 ] ),\r\n					getColorIndex( vertexColors[ 1 ] ),\r\n					getColorIndex( vertexColors[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function setBit( value, position, enabled ) {\r\n\r\n			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n		}\r\n\r\n		function getNormalIndex( normal ) {\r\n\r\n			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n			if ( normalsHash[ hash ] !== undefined ) {\r\n\r\n				return normalsHash[ hash ];\r\n\r\n			}\r\n\r\n			normalsHash[ hash ] = normals.length / 3;\r\n			normals.push( normal.x, normal.y, normal.z );\r\n\r\n			return normalsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getColorIndex( color ) {\r\n\r\n			var hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n			if ( colorsHash[ hash ] !== undefined ) {\r\n\r\n				return colorsHash[ hash ];\r\n\r\n			}\r\n\r\n			colorsHash[ hash ] = colors.length;\r\n			colors.push( color.getHex() );\r\n\r\n			return colorsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getUvIndex( uv ) {\r\n\r\n			var hash = uv.x.toString() + uv.y.toString();\r\n\r\n			if ( uvsHash[ hash ] !== undefined ) {\r\n\r\n				return uvsHash[ hash ];\r\n\r\n			}\r\n\r\n			uvsHash[ hash ] = uvs.length / 2;\r\n			uvs.push( uv.x, uv.y );\r\n\r\n			return uvsHash[ hash ];\r\n\r\n		}\r\n\r\n		data.data = {};\r\n\r\n		data.data.vertices = vertices;\r\n		data.data.normals = normals;\r\n		if ( colors.length > 0 ) data.data.colors = colors;\r\n		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n		data.data.faces = faces;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		/*\r\n		// Handle primitives\r\n\r\n		var parameters = this.parameters;\r\n\r\n		if ( parameters !== undefined ) {\r\n\r\n			var values = [];\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				values.push( parameters[ key ] );\r\n\r\n			}\r\n\r\n			var geometry = Object.create( this.constructor.prototype );\r\n			this.constructor.apply( geometry, values );\r\n			return geometry;\r\n\r\n		}\r\n\r\n		return new this.constructor().copy( this );\r\n		*/\r\n\r\n		return new THREE.Geometry().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.vertices = [];\r\n		this.faces = [];\r\n		this.faceVertexUvs = [ [] ];\r\n\r\n		var vertices = source.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			this.vertices.push( vertices[ i ].clone() );\r\n\r\n		}\r\n\r\n		var faces = source.faces;\r\n\r\n		for ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n			this.faces.push( faces[ i ].clone() );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n			var faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n			if ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n				this.faceVertexUvs[ i ] = [];\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				var uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n					var uv = uvs[ k ];\r\n\r\n					uvsCopy.push( uv.clone() );\r\n\r\n				}\r\n\r\n				this.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/core/DirectGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectGeometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'DirectGeometry';\r\n\r\n	this.indices = [];\r\n	this.vertices = [];\r\n	this.normals = [];\r\n	this.colors = [];\r\n	this.uvs = [];\r\n	this.uvs2 = [];\r\n\r\n	this.groups = [];\r\n\r\n	this.morphTargets = {};\r\n\r\n	this.skinWeights = [];\r\n	this.skinIndices = [];\r\n\r\n	// this.lineDistances = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	// update flags\r\n\r\n	this.verticesNeedUpdate = false;\r\n	this.normalsNeedUpdate = false;\r\n	this.colorsNeedUpdate = false;\r\n	this.uvsNeedUpdate = false;\r\n	this.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.DirectGeometry.prototype = {\r\n\r\n	constructor: THREE.DirectGeometry,\r\n\r\n	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\r\n	},\r\n\r\n	computeVertexNormals: function () {\r\n\r\n		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\r\n	},\r\n\r\n	computeGroups: function ( geometry ) {\r\n\r\n		var group;\r\n		var groups = [];\r\n		var materialIndex;\r\n\r\n		var faces = geometry.faces;\r\n\r\n		for ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			// materials\r\n\r\n			if ( face.materialIndex !== materialIndex ) {\r\n\r\n				materialIndex = face.materialIndex;\r\n\r\n				if ( group !== undefined ) {\r\n\r\n					group.count = ( i * 3 ) - group.start;\r\n					groups.push( group );\r\n\r\n				}\r\n\r\n				group = {\r\n					start: i * 3,\r\n					materialIndex: materialIndex\r\n				};\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( group !== undefined ) {\r\n\r\n			group.count = ( i * 3 ) - group.start;\r\n			groups.push( group );\r\n\r\n		}\r\n\r\n		this.groups = groups;\r\n\r\n	},\r\n\r\n	fromGeometry: function ( geometry ) {\r\n\r\n		var faces = geometry.faces;\r\n		var vertices = geometry.vertices;\r\n		var faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n		// morphs\r\n\r\n		var morphTargets = geometry.morphTargets;\r\n		var morphTargetsLength = morphTargets.length;\r\n\r\n		var morphTargetsPosition;\r\n\r\n		if ( morphTargetsLength > 0 ) {\r\n\r\n			morphTargetsPosition = [];\r\n\r\n			for ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n				morphTargetsPosition[ i ] = [];\r\n\r\n			}\r\n\r\n			this.morphTargets.position = morphTargetsPosition;\r\n\r\n		}\r\n\r\n		var morphNormals = geometry.morphNormals;\r\n		var morphNormalsLength = morphNormals.length;\r\n\r\n		var morphTargetsNormal;\r\n\r\n		if ( morphNormalsLength > 0 ) {\r\n\r\n			morphTargetsNormal = [];\r\n\r\n			for ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n				morphTargetsNormal[ i ] = [];\r\n\r\n			}\r\n\r\n			this.morphTargets.normal = morphTargetsNormal;\r\n\r\n		}\r\n\r\n		// skins\r\n\r\n		var skinIndices = geometry.skinIndices;\r\n		var skinWeights = geometry.skinWeights;\r\n\r\n		var hasSkinIndices = skinIndices.length === vertices.length;\r\n		var hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n		//\r\n\r\n		for ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n			var vertexNormals = face.vertexNormals;\r\n\r\n			if ( vertexNormals.length === 3 ) {\r\n\r\n				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n			} else {\r\n\r\n				var normal = face.normal;\r\n\r\n				this.normals.push( normal, normal, normal );\r\n\r\n			}\r\n\r\n			var vertexColors = face.vertexColors;\r\n\r\n			if ( vertexColors.length === 3 ) {\r\n\r\n				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n			} else {\r\n\r\n				var color = face.color;\r\n\r\n				this.colors.push( color, color, color );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexUv === true ) {\r\n\r\n				var vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n				if ( vertexUvs !== undefined ) {\r\n\r\n					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n				} else {\r\n\r\n					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexUv2 === true ) {\r\n\r\n				var vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n				if ( vertexUvs !== undefined ) {\r\n\r\n					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n				} else {\r\n\r\n					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// morphs\r\n\r\n			for ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n				var morphTarget = morphTargets[ j ].vertices;\r\n\r\n				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n			}\r\n\r\n			for ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n				var morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n			}\r\n\r\n			// skins\r\n\r\n			if ( hasSkinIndices ) {\r\n\r\n				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n			}\r\n\r\n			if ( hasSkinWeights ) {\r\n\r\n				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeGroups( geometry );\r\n\r\n		this.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n		this.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n		this.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n		this.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n		this.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'BufferGeometry';\r\n\r\n	this.index = null;\r\n	this.attributes = {};\r\n\r\n	this.morphAttributes = {};\r\n\r\n	this.groups = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	this.drawRange = { start: 0, count: Infinity };\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n	constructor: THREE.BufferGeometry,\r\n\r\n	getIndex: function () {\r\n\r\n		return this.index;\r\n\r\n	},\r\n\r\n	setIndex: function ( index ) {\r\n\r\n		this.index = index;\r\n\r\n	},\r\n\r\n	addAttribute: function ( name, attribute ) {\r\n\r\n		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		if ( name === 'index' ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n			this.setIndex( attribute );\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		this.attributes[ name ] = attribute;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getAttribute: function ( name ) {\r\n\r\n		return this.attributes[ name ];\r\n\r\n	},\r\n\r\n	removeAttribute: function ( name ) {\r\n\r\n		delete this.attributes[ name ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addGroup: function ( start, count, materialIndex ) {\r\n\r\n		this.groups.push( {\r\n\r\n			start: start,\r\n			count: count,\r\n			materialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n		} );\r\n\r\n	},\r\n\r\n	clearGroups: function () {\r\n\r\n		this.groups = [];\r\n\r\n	},\r\n\r\n	setDrawRange: function ( start, count ) {\r\n\r\n		this.drawRange.start = start;\r\n		this.drawRange.count = count;\r\n\r\n	},\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var position = this.attributes.position;\r\n\r\n		if ( position !== undefined ) {\r\n\r\n			matrix.applyToVector3Array( position.array );\r\n			position.needsUpdate = true;\r\n\r\n		}\r\n\r\n		var normal = this.attributes.normal;\r\n\r\n		if ( normal !== undefined ) {\r\n\r\n			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n			normalMatrix.applyToVector3Array( normal.array );\r\n			normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n		if ( this.boundingBox !== null ) {\r\n\r\n			this.computeBoundingBox();\r\n\r\n		}\r\n\r\n		if ( this.boundingSphere !== null ) {\r\n\r\n			this.computeBoundingSphere();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	rotateX: function () {\r\n\r\n		// rotate geometry around world x-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateX( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationX( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		// rotate geometry around world y-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateY( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationY( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		// rotate geometry around world z-axis\r\n\r\n		var m1;\r\n\r\n		return function rotateZ( angle ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeRotationZ( angle );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function () {\r\n\r\n		// translate geometry\r\n\r\n		var m1;\r\n\r\n		return function translate( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeTranslation( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	scale: function () {\r\n\r\n		// scale geometry\r\n\r\n		var m1;\r\n\r\n		return function scale( x, y, z ) {\r\n\r\n			if ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n			m1.makeScale( x, y, z );\r\n\r\n			this.applyMatrix( m1 );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		var obj;\r\n\r\n		return function lookAt( vector ) {\r\n\r\n			if ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n			obj.lookAt( vector );\r\n\r\n			obj.updateMatrix();\r\n\r\n			this.applyMatrix( obj.matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	center: function () {\r\n\r\n		this.computeBoundingBox();\r\n\r\n		var offset = this.boundingBox.center().negate();\r\n\r\n		this.translate( offset.x, offset.y, offset.z );\r\n\r\n		return offset;\r\n\r\n	},\r\n\r\n	setFromObject: function ( object ) {\r\n\r\n		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\r\n			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\r\n			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\r\n				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n			}\r\n\r\n			if ( geometry.boundingSphere !== null ) {\r\n\r\n				this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n			}\r\n\r\n			if ( geometry.boundingBox !== null ) {\r\n\r\n				this.boundingBox = geometry.boundingBox.clone();\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Mesh ) {\r\n\r\n			if ( geometry instanceof THREE.Geometry ) {\r\n\r\n				this.fromGeometry( geometry );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	updateFromObject: function ( object ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			var direct = geometry.__directGeometry;\r\n\r\n			if ( direct === undefined ) {\r\n\r\n				return this.fromGeometry( geometry );\r\n\r\n			}\r\n\r\n			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n			geometry.normalsNeedUpdate = false;\r\n			geometry.colorsNeedUpdate = false;\r\n			geometry.uvsNeedUpdate = false;\r\n			geometry.groupsNeedUpdate = false;\r\n\r\n			geometry = direct;\r\n\r\n		}\r\n\r\n		if ( geometry.verticesNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.position;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyVector3sArray( geometry.vertices );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.normalsNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.normal;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyVector3sArray( geometry.normals );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.normalsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.colorsNeedUpdate === true ) {\r\n\r\n			var attribute = this.attributes.color;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyColorsArray( geometry.colors );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.colorsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.uvsNeedUpdate ) {\r\n\r\n			var attribute = this.attributes.uv;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyVector2sArray( geometry.uvs );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.uvsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n			var attribute = this.attributes.lineDistance;\r\n\r\n			if ( attribute !== undefined ) {\r\n\r\n				attribute.copyArray( geometry.lineDistances );\r\n				attribute.needsUpdate = true;\r\n\r\n			}\r\n\r\n			geometry.lineDistancesNeedUpdate = false;\r\n\r\n		}\r\n\r\n		if ( geometry.groupsNeedUpdate ) {\r\n\r\n			geometry.computeGroups( object.geometry );\r\n			this.groups = geometry.groups;\r\n\r\n			geometry.groupsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromGeometry: function ( geometry ) {\r\n\r\n		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\r\n		return this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n	},\r\n\r\n	fromDirectGeometry: function ( geometry ) {\r\n\r\n		var positions = new Float32Array( geometry.vertices.length * 3 );\r\n		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n		if ( geometry.normals.length > 0 ) {\r\n\r\n			var normals = new Float32Array( geometry.normals.length * 3 );\r\n			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n		}\r\n\r\n		if ( geometry.colors.length > 0 ) {\r\n\r\n			var colors = new Float32Array( geometry.colors.length * 3 );\r\n			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n		}\r\n\r\n		if ( geometry.uvs.length > 0 ) {\r\n\r\n			var uvs = new Float32Array( geometry.uvs.length * 2 );\r\n			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n		}\r\n\r\n		if ( geometry.uvs2.length > 0 ) {\r\n\r\n			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n		}\r\n\r\n		if ( geometry.indices.length > 0 ) {\r\n\r\n			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n			var indices = new TypeArray( geometry.indices.length * 3 );\r\n			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\r\n		}\r\n\r\n		// groups\r\n\r\n		this.groups = geometry.groups;\r\n\r\n		// morphs\r\n\r\n		for ( var name in geometry.morphTargets ) {\r\n\r\n			var array = [];\r\n			var morphTargets = geometry.morphTargets[ name ];\r\n\r\n			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n				var morphTarget = morphTargets[ i ];\r\n\r\n				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\r\n				array.push( attribute.copyVector3sArray( morphTarget ) );\r\n\r\n			}\r\n\r\n			this.morphAttributes[ name ] = array;\r\n\r\n		}\r\n\r\n		// skinning\r\n\r\n		if ( geometry.skinIndices.length > 0 ) {\r\n\r\n			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n		}\r\n\r\n		if ( geometry.skinWeights.length > 0 ) {\r\n\r\n			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( geometry.boundingSphere !== null ) {\r\n\r\n			this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n		}\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			this.boundingBox = geometry.boundingBox.clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingBox === null ) {\r\n\r\n				this.boundingBox = new THREE.Box3();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				this.boundingBox.setFromArray( positions );\r\n\r\n			}\r\n\r\n			if ( positions === undefined || positions.length === 0 ) {\r\n\r\n				this.boundingBox.min.set( 0, 0, 0 );\r\n				this.boundingBox.max.set( 0, 0, 0 );\r\n\r\n			}\r\n\r\n			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n			}\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		var box = new THREE.Box3();\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingSphere === null ) {\r\n\r\n				this.boundingSphere = new THREE.Sphere();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				var center = this.boundingSphere.center;\r\n\r\n				box.setFromArray( positions );\r\n				box.center( center );\r\n\r\n				// hoping to find a boundingSphere with a radius smaller than the\r\n				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n				var maxRadiusSq = 0;\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.fromArray( positions, i );\r\n					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n				}\r\n\r\n				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n				if ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		// backwards compatibility\r\n\r\n	},\r\n\r\n	computeVertexNormals: function () {\r\n\r\n		var index = this.index;\r\n		var attributes = this.attributes;\r\n		var groups = this.groups;\r\n\r\n		if ( attributes.position ) {\r\n\r\n			var positions = attributes.position.array;\r\n\r\n			if ( attributes.normal === undefined ) {\r\n\r\n				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n			} else {\r\n\r\n				// reset existing normals to zero\r\n\r\n				var array = attributes.normal.array;\r\n\r\n				for ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n					array[ i ] = 0;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var normals = attributes.normal.array;\r\n\r\n			var vA, vB, vC,\r\n\r\n			pA = new THREE.Vector3(),\r\n			pB = new THREE.Vector3(),\r\n			pC = new THREE.Vector3(),\r\n\r\n			cb = new THREE.Vector3(),\r\n			ab = new THREE.Vector3();\r\n\r\n			// indexed elements\r\n\r\n			if ( index ) {\r\n\r\n				var indices = index.array;\r\n\r\n				if ( groups.length === 0 ) {\r\n\r\n					this.addGroup( 0, indices.length );\r\n\r\n				}\r\n\r\n				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\r\n					var group = groups[ j ];\r\n\r\n					var start = group.start;\r\n					var count = group.count;\r\n\r\n					for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n						vA = indices[ i + 0 ] * 3;\r\n						vB = indices[ i + 1 ] * 3;\r\n						vC = indices[ i + 2 ] * 3;\r\n\r\n						pA.fromArray( positions, vA );\r\n						pB.fromArray( positions, vB );\r\n						pC.fromArray( positions, vC );\r\n\r\n						cb.subVectors( pC, pB );\r\n						ab.subVectors( pA, pB );\r\n						cb.cross( ab );\r\n\r\n						normals[ vA ] += cb.x;\r\n						normals[ vA + 1 ] += cb.y;\r\n						normals[ vA + 2 ] += cb.z;\r\n\r\n						normals[ vB ] += cb.x;\r\n						normals[ vB + 1 ] += cb.y;\r\n						normals[ vB + 2 ] += cb.z;\r\n\r\n						normals[ vC ] += cb.x;\r\n						normals[ vC + 1 ] += cb.y;\r\n						normals[ vC + 2 ] += cb.z;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed elements (unconnected triangle soup)\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n					pA.fromArray( positions, i );\r\n					pB.fromArray( positions, i + 3 );\r\n					pC.fromArray( positions, i + 6 );\r\n\r\n					cb.subVectors( pC, pB );\r\n					ab.subVectors( pA, pB );\r\n					cb.cross( ab );\r\n\r\n					normals[ i ] = cb.x;\r\n					normals[ i + 1 ] = cb.y;\r\n					normals[ i + 2 ] = cb.z;\r\n\r\n					normals[ i + 3 ] = cb.x;\r\n					normals[ i + 4 ] = cb.y;\r\n					normals[ i + 5 ] = cb.z;\r\n\r\n					normals[ i + 6 ] = cb.x;\r\n					normals[ i + 7 ] = cb.y;\r\n					normals[ i + 8 ] = cb.z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.normalizeNormals();\r\n\r\n			attributes.normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	merge: function ( geometry, offset ) {\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		var attributes = this.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			if ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n			var attribute1 = attributes[ key ];\r\n			var attributeArray1 = attribute1.array;\r\n\r\n			var attribute2 = geometry.attributes[ key ];\r\n			var attributeArray2 = attribute2.array;\r\n\r\n			var attributeSize = attribute2.itemSize;\r\n\r\n			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n				attributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalizeNormals: function () {\r\n\r\n		var normals = this.attributes.normal.array;\r\n\r\n		var x, y, z, n;\r\n\r\n		for ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n			x = normals[ i ];\r\n			y = normals[ i + 1 ];\r\n			z = normals[ i + 2 ];\r\n\r\n			n = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n			normals[ i ] *= n;\r\n			normals[ i + 1 ] *= n;\r\n			normals[ i + 2 ] *= n;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toNonIndexed: function () {\r\n\r\n		if ( this.index === null ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n			return this;\r\n\r\n		}\r\n\r\n		var geometry2 = new THREE.BufferGeometry();\r\n\r\n		var indices = this.index.array;\r\n		var attributes = this.attributes;\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			var attribute = attributes[ name ];\r\n\r\n			var array = attribute.array;\r\n			var itemSize = attribute.itemSize;\r\n\r\n			var array2 = new array.constructor( indices.length * itemSize );\r\n\r\n			var index = 0, index2 = 0;\r\n\r\n			for ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n				index = indices[ i ] * itemSize;\r\n\r\n				for ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n					array2[ index2 ++ ] = array[ index ++ ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\r\n		}\r\n\r\n		return geometry2;\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'BufferGeometry',\r\n				generator: 'BufferGeometry.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard BufferGeometry serialization\r\n\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.parameters !== undefined ) {\r\n\r\n			var parameters = this.parameters;\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n			}\r\n\r\n			return data;\r\n\r\n		}\r\n\r\n		data.data = { attributes: {} };\r\n\r\n		var index = this.index;\r\n\r\n		if ( index !== null ) {\r\n\r\n			var array = Array.prototype.slice.call( index.array );\r\n\r\n			data.data.index = {\r\n				type: index.array.constructor.name,\r\n				array: array\r\n			};\r\n\r\n		}\r\n\r\n		var attributes = this.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n\r\n			var array = Array.prototype.slice.call( attribute.array );\r\n\r\n			data.data.attributes[ key ] = {\r\n				itemSize: attribute.itemSize,\r\n				type: attribute.array.constructor.name,\r\n				array: array\r\n			};\r\n\r\n		}\r\n\r\n		var groups = this.groups;\r\n\r\n		if ( groups.length > 0 ) {\r\n\r\n			data.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n		}\r\n\r\n		var boundingSphere = this.boundingSphere;\r\n\r\n		if ( boundingSphere !== null ) {\r\n\r\n			data.data.boundingSphere = {\r\n				center: boundingSphere.center.toArray(),\r\n				radius: boundingSphere.radius\r\n			};\r\n\r\n		}\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		/*\r\n		// Handle primitives\r\n\r\n		var parameters = this.parameters;\r\n\r\n		if ( parameters !== undefined ) {\r\n\r\n			var values = [];\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				values.push( parameters[ key ] );\r\n\r\n			}\r\n\r\n			var geometry = Object.create( this.constructor.prototype );\r\n			this.constructor.apply( geometry, values );\r\n			return geometry;\r\n\r\n		}\r\n\r\n		return new this.constructor().copy( this );\r\n		*/\r\n\r\n		return new THREE.BufferGeometry().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		var index = source.index;\r\n\r\n		if ( index !== null ) {\r\n\r\n			this.setIndex( index.clone() );\r\n\r\n		}\r\n\r\n		var attributes = source.attributes;\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			var attribute = attributes[ name ];\r\n			this.addAttribute( name, attribute.clone() );\r\n\r\n		}\r\n\r\n		var groups = source.groups;\r\n\r\n		for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n			var group = groups[ i ];\r\n			this.addGroup( group.start, group.count );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\nTHREE.BufferGeometry.MaxIndex = 65535;\r\n\r\n// File:src/core/InstancedBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferGeometry = function () {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'InstancedBufferGeometry';\r\n	this.maxInstancedCount = undefined;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\r\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\r\n	this.groups.push( {\r\n\r\n		start: start,\r\n		count: count,\r\n		instances: instances\r\n\r\n	} );\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\r\n	var index = source.index;\r\n\r\n	if ( index !== null ) {\r\n\r\n		this.setIndex( index.clone() );\r\n\r\n	}\r\n\r\n	var attributes = source.attributes;\r\n\r\n	for ( var name in attributes ) {\r\n\r\n		var attribute = attributes[ name ];\r\n		this.addAttribute( name, attribute.clone() );\r\n\r\n	}\r\n\r\n	var groups = source.groups;\r\n\r\n	for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n		var group = groups[ i ];\r\n		this.addGroup( group.start, group.count, group.instances );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\r\n// File:src/core/Uniform.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Uniform = function ( type, value ) {\r\n\r\n	this.type = type;\r\n	this.value = value;\r\n\r\n	this.dynamic = false;\r\n\r\n};\r\n\r\nTHREE.Uniform.prototype = {\r\n\r\n	constructor: THREE.Uniform,\r\n\r\n	onUpdate: function ( callback ) {\r\n\r\n		this.dynamic = true;\r\n		this.onUpdateCallback = callback;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/animation/AnimationClip.js\r\n\r\n/**\r\n *\r\n * Reusable set of Tracks that represent an animation.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\r\n	this.name = name || THREE.Math.generateUUID();\r\n	this.tracks = tracks;\r\n	this.duration = ( duration !== undefined ) ? duration : -1;\r\n\r\n	// this means it should figure out its duration by scanning the tracks\r\n	if ( this.duration < 0 ) {\r\n\r\n		this.resetDuration();\r\n\r\n	}\r\n\r\n	// maybe only do these on demand, as doing them here could potentially slow down loading\r\n	// but leaving these here during development as this ensures a lot of testing of these functions\r\n	this.trim();\r\n	this.optimize();\r\n\r\n};\r\n\r\nTHREE.AnimationClip.prototype = {\r\n\r\n	constructor: THREE.AnimationClip,\r\n\r\n	resetDuration: function() {\r\n\r\n		var tracks = this.tracks,\r\n			duration = 0;\r\n\r\n		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n			var track = this.tracks[ i ];\r\n\r\n			duration = Math.max(\r\n					duration, track.times[ track.times.length - 1 ] );\r\n\r\n		}\r\n\r\n		this.duration = duration;\r\n\r\n	},\r\n\r\n	trim: function() {\r\n\r\n		for ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n			this.tracks[ i ].trim( 0, this.duration );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	optimize: function() {\r\n\r\n		for ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n			this.tracks[ i ].optimize();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.AnimationClip, {\r\n\r\n	parse: function( json ) {\r\n\r\n		var tracks = [],\r\n			jsonTracks = json.tracks,\r\n			frameTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n			tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n		}\r\n\r\n		return new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\r\n	},\r\n\r\n\r\n	toJSON: function( clip ) {\r\n\r\n		var tracks = [],\r\n			clipTracks = clip.tracks;\r\n\r\n		var json = {\r\n\r\n			'name': clip.name,\r\n			'duration': clip.duration,\r\n			'tracks': tracks\r\n\r\n		};\r\n\r\n		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n			tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n		}\r\n\r\n		return json;\r\n\r\n	},\r\n\r\n\r\n	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {\r\n\r\n		var numMorphTargets = morphTargetSequence.length;\r\n		var tracks = [];\r\n\r\n		for ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n			var times = [];\r\n			var values = [];\r\n\r\n			times.push(\r\n					( i + numMorphTargets - 1 ) % numMorphTargets,\r\n					i,\r\n					( i + 1 ) % numMorphTargets );\r\n\r\n			values.push( 0, 1, 0 );\r\n\r\n			var order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n			times = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n			values = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\r\n			// if there is a key at the first frame, duplicate it as the\r\n			// last frame as well for perfect loop.\r\n			if ( times[ 0 ] === 0 ) {\r\n\r\n				times.push( numMorphTargets );\r\n				values.push( values[ 0 ] );\r\n\r\n			}\r\n\r\n			tracks.push(\r\n					new THREE.NumberKeyframeTrack(\r\n						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n						times, values\r\n					).scale( 1.0 / fps ) );\r\n		}\r\n\r\n		return new THREE.AnimationClip( name, -1, tracks );\r\n\r\n	},\r\n\r\n	findByName: function( clipArray, name ) {\r\n\r\n		for ( var i = 0; i < clipArray.length; i ++ ) {\r\n\r\n			if ( clipArray[ i ].name === name ) {\r\n\r\n				return clipArray[ i ];\r\n\r\n			}\r\n		}\r\n\r\n		return null;\r\n\r\n	},\r\n\r\n	CreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {\r\n\r\n		var animationToMorphTargets = {};\r\n\r\n		// tested with https://regex101.com/ on trick sequences\r\n		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n		var pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n		// sort morph target names into animation groups based\r\n		// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n			var morphTarget = morphTargets[ i ];\r\n			var parts = morphTarget.name.match( pattern );\r\n\r\n			if ( parts && parts.length > 1 ) {\r\n\r\n				var name = parts[ 1 ];\r\n\r\n				var animationMorphTargets = animationToMorphTargets[ name ];\r\n				if ( ! animationMorphTargets ) {\r\n\r\n					animationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n				}\r\n\r\n				animationMorphTargets.push( morphTarget );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var clips = [];\r\n\r\n		for ( var name in animationToMorphTargets ) {\r\n\r\n			clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );\r\n\r\n		}\r\n\r\n		return clips;\r\n\r\n	},\r\n\r\n	// parse the animation.hierarchy format\r\n	parseAnimation: function( animation, bones, nodeName ) {\r\n\r\n		if ( ! animation ) {\r\n\r\n			console.error( \"  no animation in JSONLoader data\" );\r\n			return null;\r\n\r\n		}\r\n\r\n		var addNonemptyTrack = function(\r\n				trackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n			// only return track if there are actually keys.\r\n			if ( animationKeys.length !== 0 ) {\r\n\r\n				var times = [];\r\n				var values = [];\r\n\r\n				THREE.AnimationUtils.flattenJSON(\r\n						animationKeys, times, values, propertyName );\r\n\r\n				// empty keys are filtered out, so check again\r\n				if ( times.length !== 0 ) {\r\n\r\n					destTracks.push( new trackType( trackName, times, values ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n		var tracks = [];\r\n\r\n		var clipName = animation.name || 'default';\r\n		// automatic length determination in AnimationClip.\r\n		var duration = animation.length || -1;\r\n		var fps = animation.fps || 30;\r\n\r\n		var hierarchyTracks = animation.hierarchy || [];\r\n\r\n		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n			var animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n			// skip empty tracks\r\n			if ( ! animationKeys || animationKeys.length == 0 ) continue;\r\n\r\n			// process morph targets in a way exactly compatible\r\n			// with AnimationHandler.init( animation )\r\n			if ( animationKeys[0].morphTargets ) {\r\n\r\n				// figure out all morph targets used in this track\r\n				var morphTargetNames = {};\r\n				for ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n					if ( animationKeys[k].morphTargets ) {\r\n\r\n						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\r\n							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				// create a track for each morph target with all zero\r\n				// morphTargetInfluences except for the keys in which\r\n				// the morphTarget is named.\r\n				for ( var morphTargetName in morphTargetNames ) {\r\n\r\n					var times = [];\r\n					var values = [];\r\n\r\n					for ( var m = 0;\r\n							m !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\r\n						var animationKey = animationKeys[k];\r\n\r\n						times.push( animationKey.time );\r\n						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )\r\n\r\n					}\r\n\r\n					tracks.push( new THREE.NumberKeyframeTrack(\r\n							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n				}\r\n\r\n				duration = morphTargetNames.length * ( fps || 1.0 );\r\n\r\n			} else {\r\n				// ...assume skeletal animation\r\n\r\n				var boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n				addNonemptyTrack(\r\n						THREE.VectorKeyframeTrack, boneName + '.position',\r\n						animationKeys, 'pos', tracks );\r\n\r\n				addNonemptyTrack(\r\n						THREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n						animationKeys, 'rot', tracks );\r\n\r\n				addNonemptyTrack(\r\n						THREE.VectorKeyframeTrack, boneName + '.scale',\r\n						animationKeys, 'scl', tracks );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( tracks.length === 0 ) {\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		var clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\r\n		return clip;\r\n\r\n	}\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationMixer.js\r\n\r\n/**\r\n *\r\n * Player for AnimationClips.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationMixer = function( root ) {\r\n\r\n	this._root = root;\r\n	this._initMemoryManager();\r\n	this._accuIndex = 0;\r\n\r\n	this.time = 0;\r\n\r\n	this.timeScale = 1.0;\r\n\r\n};\r\n\r\nTHREE.AnimationMixer.prototype = {\r\n\r\n	constructor: THREE.AnimationMixer,\r\n\r\n	// return an action for a clip optionally using a custom root target\r\n	// object (this method allocates a lot of dynamic memory in case a\r\n	// previously unknown clip/root combination is specified)\r\n	clipAction: function( clip, optionalRoot ) {\r\n\r\n		var root = optionalRoot || this._root,\r\n			rootUuid = root.uuid,\r\n			clipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n			clipObject = ( clip !== clipName ) ? clip : null,\r\n\r\n			actionsForClip = this._actionsByClip[ clipName ],\r\n			prototypeAction;\r\n\r\n		if ( actionsForClip !== undefined ) {\r\n\r\n			var existingAction =\r\n					actionsForClip.actionByRoot[ rootUuid ];\r\n\r\n			if ( existingAction !== undefined ) {\r\n\r\n				return existingAction;\r\n\r\n			}\r\n\r\n			// we know the clip, so we don't have to parse all\r\n			// the bindings again but can just copy\r\n			prototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n			// also, take the clip from the prototype action\r\n			clipObject = prototypeAction._clip;\r\n\r\n			if ( clip !== clipName && clip !== clipObject ) {\r\n\r\n				throw new Error(\r\n						\"Different clips with the same name detected!\" );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// clip must be known when specified via string\r\n		if ( clipObject === null ) return null;\r\n\r\n		// allocate all resources required to run it\r\n		var newAction = new THREE.\r\n				AnimationMixer._Action( this, clipObject, optionalRoot );\r\n\r\n		this._bindAction( newAction, prototypeAction );\r\n\r\n		// and make the action known to the memory manager\r\n		this._addInactiveAction( newAction, clipName, rootUuid );\r\n\r\n		return newAction;\r\n\r\n	},\r\n\r\n	// get an existing action\r\n	existingAction: function( clip, optionalRoot ) {\r\n\r\n		var root = optionalRoot || this._root,\r\n			rootUuid = root.uuid,\r\n			clipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n			actionsForClip = this._actionsByClip[ clipName ];\r\n\r\n		if ( actionsForClip !== undefined ) {\r\n\r\n			return actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n		}\r\n\r\n		return null;\r\n\r\n	},\r\n\r\n	// deactivates all previously scheduled actions\r\n	stopAllAction: function() {\r\n\r\n		var actions = this._actions,\r\n			nActions = this._nActiveActions,\r\n			bindings = this._bindings,\r\n			nBindings = this._nActiveBindings;\r\n\r\n		this._nActiveActions = 0;\r\n		this._nActiveBindings = 0;\r\n\r\n		for ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n			actions[ i ].reset();\r\n\r\n		}\r\n\r\n		for ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n			bindings[ i ].useCount = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// advance the time and update apply the animation\r\n	update: function( deltaTime ) {\r\n\r\n		deltaTime *= this.timeScale;\r\n\r\n		var actions = this._actions,\r\n			nActions = this._nActiveActions,\r\n\r\n			time = this.time += deltaTime,\r\n			timeDirection = Math.sign( deltaTime ),\r\n\r\n			accuIndex = this._accuIndex ^= 1;\r\n\r\n		// run active actions\r\n\r\n		for ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n			var action = actions[ i ];\r\n\r\n			if ( action.enabled ) {\r\n\r\n				action._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// update scene graph\r\n\r\n		var bindings = this._bindings,\r\n			nBindings = this._nActiveBindings;\r\n\r\n		for ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n			bindings[ i ].apply( accuIndex );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// return this mixer's root target object\r\n	getRoot: function() {\r\n\r\n		return this._root;\r\n\r\n	},\r\n\r\n	// free all resources specific to a particular clip\r\n	uncacheClip: function( clip ) {\r\n\r\n		var actions = this._actions,\r\n			clipName = clip.name,\r\n			actionsByClip = this._actionsByClip,\r\n			actionsForClip = actionsByClip[ clipName ];\r\n\r\n		if ( actionsForClip !== undefined ) {\r\n\r\n			// note: just calling _removeInactiveAction would mess up the\r\n			// iteration state and also require updating the state we can\r\n			// just throw away\r\n\r\n			var actionsToRemove = actionsForClip.knownActions;\r\n\r\n			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n				var action = actionsToRemove[ i ];\r\n\r\n				this._deactivateAction( action );\r\n\r\n				var cacheIndex = action._cacheIndex,\r\n					lastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n				action._cacheIndex = null;\r\n				action._byClipCacheIndex = null;\r\n\r\n				lastInactiveAction._cacheIndex = cacheIndex;\r\n				actions[ cacheIndex ] = lastInactiveAction;\r\n				actions.pop();\r\n\r\n				this._removeInactiveBindingsForAction( action );\r\n\r\n			}\r\n\r\n			delete actionsByClip[ clipName ];\r\n\r\n		}\r\n\r\n	},\r\n\r\n	// free all resources specific to a particular root target object\r\n	uncacheRoot: function( root ) {\r\n\r\n		var rootUuid = root.uuid,\r\n			actionsByClip = this._actionsByClip;\r\n\r\n		for ( var clipName in actionsByClip ) {\r\n\r\n			var actionByRoot = actionsByClip[ clipName ].actionByRoot,\r\n				action = actionByRoot[ rootUuid ];\r\n\r\n			if ( action !== undefined ) {\r\n\r\n				this._deactivateAction( action );\r\n				this._removeInactiveAction( action );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var bindingsByRoot = this._bindingsByRootAndName,\r\n			bindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n		if ( bindingByName !== undefined ) {\r\n\r\n			for ( var trackName in bindingByName ) {\r\n\r\n				var binding = bindingByName[ trackName ];\r\n				binding.restoreOriginalState();\r\n				this._removeInactiveBinding( binding );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	// remove a targeted clip from the cache\r\n	uncacheAction: function( clip, optionalRoot ) {\r\n\r\n		var action = this.existingAction( clip, optionalRoot );\r\n\r\n		if ( action !== null ) {\r\n\r\n			this._deactivateAction( action );\r\n			this._removeInactiveAction( action );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );\r\n\r\nTHREE.AnimationMixer._Action =\r\n		function( mixer, clip, localRoot ) {\r\n\r\n	this._mixer = mixer;\r\n	this._clip = clip;\r\n	this._localRoot = localRoot || null;\r\n\r\n	var tracks = clip.tracks,\r\n		nTracks = tracks.length,\r\n		interpolants = new Array( nTracks );\r\n\r\n	var interpolantSettings = {\r\n			endingStart: 	THREE.ZeroCurvatureEnding,\r\n			endingEnd:		THREE.ZeroCurvatureEnding\r\n	};\r\n\r\n	for ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n		var interpolant = tracks[ i ].createInterpolant( null );\r\n		interpolants[ i ] = interpolant;\r\n		interpolant.settings = interpolantSettings\r\n\r\n	}\r\n\r\n	this._interpolantSettings = interpolantSettings;\r\n\r\n	this._interpolants = interpolants;	// bound by the mixer\r\n\r\n	// inside: PropertyMixer (managed by the mixer)\r\n	this._propertyBindings = new Array( nTracks );\r\n\r\n	this._cacheIndex = null;			// for the memory manager\r\n	this._byClipCacheIndex = null;		// for the memory manager\r\n\r\n	this._timeScaleInterpolant = null;\r\n	this._weightInterpolant = null;\r\n\r\n	this.loop = THREE.LoopRepeat;\r\n	this._loopCount = -1;\r\n\r\n	// global mixer time when the action is to be started\r\n	// it's set back to 'null' upon start of the action\r\n	this._startTime = null;\r\n\r\n	// scaled local time of the action\r\n	// gets clamped or wrapped to 0..clip.duration according to loop\r\n	this.time = 0;\r\n\r\n	this.timeScale = 1;\r\n	this._effectiveTimeScale = 1;\r\n\r\n	this.weight = 1;\r\n	this._effectiveWeight = 1;\r\n\r\n	this.repetitions = Infinity; 		// no. of repetitions when looping\r\n\r\n	this.paused = false;				// false -> zero effective time scale\r\n	this.enabled = true;				// true -> zero effective weight\r\n\r\n	this.clampWhenFinished 	= false;	// keep feeding the last frame?\r\n\r\n	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate\r\n	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end\r\n\r\n};\r\n\r\nTHREE.AnimationMixer._Action.prototype = {\r\n\r\n	constructor: THREE.AnimationMixer._Action,\r\n\r\n	// State & Scheduling\r\n\r\n	play: function() {\r\n\r\n		this._mixer._activateAction( this );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	stop: function() {\r\n\r\n		this._mixer._deactivateAction( this );\r\n\r\n		return this.reset();\r\n\r\n	},\r\n\r\n	reset: function() {\r\n\r\n		this.paused = false;\r\n		this.enabled = true;\r\n\r\n		this.time = 0;			// restart clip\r\n		this._loopCount = -1;	// forget previous loops\r\n		this._startTime = null;	// forget scheduling\r\n\r\n		return this.stopFading().stopWarping();\r\n\r\n	},\r\n\r\n	isRunning: function() {\r\n\r\n		var start = this._startTime;\r\n\r\n		return this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n				this._startTime === null && this._mixer._isActiveAction( this )\r\n\r\n	},\r\n\r\n	// return true when play has been called\r\n	isScheduled: function() {\r\n\r\n		return this._mixer._isActiveAction( this );\r\n\r\n	},\r\n\r\n	startAt: function( time ) {\r\n\r\n		this._startTime = time;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setLoop: function( mode, repetitions ) {\r\n\r\n		this.loop = mode;\r\n		this.repetitions = repetitions;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// Weight\r\n\r\n	// set the weight stopping any scheduled fading\r\n	// although .enabled = false yields an effective weight of zero, this\r\n	// method does *not* change .enabled, because it would be confusing\r\n	setEffectiveWeight: function( weight ) {\r\n\r\n		this.weight = weight;\r\n\r\n		// note: same logic as when updated at runtime\r\n		this._effectiveWeight = this.enabled ? weight : 0;\r\n\r\n		return this.stopFading();\r\n\r\n	},\r\n\r\n	// return the weight considering fading and .enabled\r\n	getEffectiveWeight: function() {\r\n\r\n		return this._effectiveWeight;\r\n\r\n	},\r\n\r\n	fadeIn: function( duration ) {\r\n\r\n		return this._scheduleFading( duration, 0, 1 );\r\n\r\n	},\r\n\r\n	fadeOut: function( duration ) {\r\n\r\n		return this._scheduleFading( duration, 1, 0 );\r\n\r\n	},\r\n\r\n	crossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\r\n		var mixer = this._mixer;\r\n\r\n		fadeOutAction.fadeOut( duration );\r\n		this.fadeIn( duration );\r\n\r\n		if( warp ) {\r\n\r\n			var fadeInDuration = this._clip.duration,\r\n				fadeOutDuration = fadeOutAction._clip.duration,\r\n\r\n				startEndRatio = fadeOutDuration / fadeInDuration,\r\n				endStartRatio = fadeInDuration / fadeOutDuration;\r\n\r\n			fadeOutAction.warp( 1.0, startEndRatio, duration );\r\n			this.warp( endStartRatio, 1.0, duration );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	crossFadeTo: function( fadeInAction, duration, warp ) {\r\n\r\n		return fadeInAction.crossFadeFrom( this, duration, warp );\r\n\r\n	},\r\n\r\n	stopFading: function() {\r\n\r\n		var weightInterpolant = this._weightInterpolant;\r\n\r\n		if ( weightInterpolant !== null ) {\r\n\r\n			this._weightInterpolant = null;\r\n			this._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// Time Scale Control\r\n\r\n	// set the weight stopping any scheduled warping\r\n	// although .paused = true yields an effective time scale of zero, this\r\n	// method does *not* change .paused, because it would be confusing\r\n	setEffectiveTimeScale: function( timeScale ) {\r\n\r\n		this.timeScale = timeScale;\r\n		this._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\r\n		return this.stopWarping();\r\n\r\n	},\r\n\r\n	// return the time scale considering warping and .paused\r\n	getEffectiveTimeScale: function() {\r\n\r\n		return this._effectiveTimeScale;\r\n\r\n	},\r\n\r\n	setDuration: function( duration ) {\r\n\r\n		this.timeScale = this._clip.duration / duration;\r\n\r\n		return this.stopWarping();\r\n\r\n	},\r\n\r\n	syncWith: function( action ) {\r\n\r\n		this.time = action.time;\r\n		this.timeScale = action.timeScale;\r\n\r\n		return this.stopWarping();\r\n\r\n	},\r\n\r\n	halt: function( duration ) {\r\n\r\n		return this.warp( this._currentTimeScale, 0, duration );\r\n\r\n	},\r\n\r\n	warp: function( startTimeScale, endTimeScale, duration ) {\r\n\r\n		var mixer = this._mixer, now = mixer.time,\r\n			interpolant = this._timeScaleInterpolant,\r\n\r\n			timeScale = this.timeScale;\r\n\r\n		if ( interpolant === null ) {\r\n\r\n			interpolant = mixer._lendControlInterpolant(),\r\n			this._timeScaleInterpolant = interpolant;\r\n\r\n		}\r\n\r\n		var times = interpolant.parameterPositions,\r\n			values = interpolant.sampleValues;\r\n\r\n		times[ 0 ] = now;\r\n		times[ 1 ] = now + duration;\r\n\r\n		values[ 0 ] = startTimeScale / timeScale;\r\n		values[ 1 ] = endTimeScale / timeScale;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	stopWarping: function() {\r\n\r\n		var timeScaleInterpolant = this._timeScaleInterpolant;\r\n\r\n		if ( timeScaleInterpolant !== null ) {\r\n\r\n			this._timeScaleInterpolant = null;\r\n			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// Object Accessors\r\n\r\n	getMixer: function() {\r\n\r\n		return this._mixer;\r\n\r\n	},\r\n\r\n	getClip: function() {\r\n\r\n		return this._clip;\r\n\r\n	},\r\n\r\n	getRoot: function() {\r\n\r\n		return this._localRoot || this._mixer._root;\r\n\r\n	},\r\n\r\n	// Interna\r\n\r\n	_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n		// called by the mixer\r\n\r\n		var startTime = this._startTime;\r\n\r\n		if ( startTime !== null ) {\r\n\r\n			// check for scheduled start of action\r\n\r\n			var timeRunning = ( time - startTime ) * timeDirection;\r\n			if ( timeRunning < 0 || timeDirection === 0 ) {\r\n\r\n				return; // yet to come / don't decide when delta = 0\r\n\r\n			}\r\n\r\n			// start\r\n\r\n			this._startTime = null; // unschedule\r\n			deltaTime = timeDirection * timeRunning;\r\n\r\n		}\r\n\r\n		// apply time scale and advance time\r\n\r\n		deltaTime *= this._updateTimeScale( time );\r\n		var clipTime = this._updateTime( deltaTime );\r\n\r\n		// note: _updateTime may disable the action resulting in\r\n		// an effective weight of 0\r\n\r\n		var weight = this._updateWeight( time );\r\n\r\n		if ( weight > 0 ) {\r\n\r\n			var interpolants = this._interpolants;\r\n			var propertyMixers = this._propertyBindings;\r\n\r\n			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\r\n				interpolants[ j ].evaluate( clipTime );\r\n				propertyMixers[ j ].accumulate( accuIndex, weight );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_updateWeight: function( time ) {\r\n\r\n		var weight = 0;\r\n\r\n		if ( this.enabled ) {\r\n\r\n			weight = this.weight;\r\n			var interpolant = this._weightInterpolant;\r\n\r\n			if ( interpolant !== null ) {\r\n\r\n				var interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n				weight *= interpolantValue;\r\n\r\n				if ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n					this.stopFading();\r\n\r\n					if ( interpolantValue === 0 ) {\r\n\r\n						// faded out, disable\r\n						this.enabled = false;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this._effectiveWeight = weight;\r\n		return weight;\r\n\r\n	},\r\n\r\n	_updateTimeScale: function( time ) {\r\n\r\n		var timeScale = 0;\r\n\r\n		if ( ! this.paused ) {\r\n\r\n			timeScale = this.timeScale;\r\n\r\n			var interpolant = this._timeScaleInterpolant;\r\n\r\n			if ( interpolant !== null ) {\r\n\r\n				var interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n				timeScale *= interpolantValue;\r\n\r\n				if ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n					this.stopWarping();\r\n\r\n					if ( timeScale === 0 ) {\r\n\r\n						// motion has halted, pause\r\n						this.pause = true;\r\n\r\n					} else {\r\n\r\n						// warp done - apply final time scale\r\n						this.timeScale = timeScale;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this._effectiveTimeScale = timeScale;\r\n		return timeScale;\r\n\r\n	},\r\n\r\n	_updateTime: function( deltaTime ) {\r\n\r\n		var time = this.time + deltaTime;\r\n\r\n		if ( deltaTime === 0 ) return time;\r\n\r\n		var duration = this._clip.duration,\r\n\r\n			loop = this.loop,\r\n			loopCount = this._loopCount,\r\n\r\n			pingPong = false;\r\n\r\n		switch ( loop ) {\r\n\r\n			case THREE.LoopOnce:\r\n\r\n				if ( loopCount === -1 ) {\r\n\r\n					// just started\r\n\r\n					this.loopCount = 0;\r\n					this._setEndings( true, true, false );\r\n\r\n				}\r\n\r\n				if ( time >= duration ) {\r\n\r\n					time = duration;\r\n\r\n				} else if ( time < 0 ) {\r\n\r\n					time = 0;\r\n\r\n				} else break;\r\n\r\n				// reached the end\r\n\r\n				if ( this.clampWhenFinished ) this.pause = true;\r\n				else this.enabled = false;\r\n\r\n				this._mixer.dispatchEvent( {\r\n					type: 'finished', action: this,\r\n					direction: deltaTime < 0 ? -1 : 1\r\n				} );\r\n\r\n				break;\r\n\r\n			case THREE.LoopPingPong:\r\n\r\n				pingPong = true;\r\n\r\n			case THREE.LoopRepeat:\r\n\r\n				if ( loopCount === -1 ) {\r\n\r\n					// just started\r\n\r\n					if ( deltaTime > 0 ) {\r\n\r\n						loopCount = 0;\r\n\r\n						this._setEndings(\r\n								true, this.repetitions === 0, pingPong );\r\n\r\n					} else {\r\n\r\n						// when looping in reverse direction, the initial\r\n						// transition through zero counts as a repetition,\r\n						// so leave loopCount at -1\r\n\r\n						this._setEndings(\r\n								this.repetitions === 0, true, pingPong );\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( time >= duration || time < 0 ) {\r\n\r\n					// wrap around\r\n\r\n					var loopDelta = Math.floor( time / duration ); // signed\r\n					time -= duration * loopDelta;\r\n\r\n					loopCount += Math.abs( loopDelta );\r\n\r\n					var pending = this.repetitions - loopCount;\r\n\r\n					if ( pending < 0 ) {\r\n\r\n						// stop (switch state, clamp time, fire event)\r\n\r\n						if ( this.clampWhenFinished ) this.paused = true;\r\n						else this.enabled = false;\r\n\r\n						time = deltaTime > 0 ? duration : 0;\r\n\r\n						this._mixer.dispatchEvent( {\r\n							type: 'finished', action: this,\r\n							direction: deltaTime > 0 ? 1 : -1\r\n						} );\r\n\r\n						break;\r\n\r\n					} else if ( pending === 0 ) {\r\n\r\n						// transition to last round\r\n\r\n						var atStart = deltaTime < 0;\r\n						this._setEndings( atStart, ! atStart, pingPong );\r\n\r\n					} else {\r\n\r\n						this._setEndings( false, false, pingPong );\r\n\r\n					}\r\n\r\n					this._loopCount = loopCount;\r\n\r\n					this._mixer.dispatchEvent( {\r\n						type: 'loop', action: this, loopDelta: loopDelta\r\n					} );\r\n\r\n				}\r\n\r\n				if ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {\r\n\r\n					// invert time for the \"pong round\"\r\n\r\n					this.time = time;\r\n\r\n					return duration - time;\r\n\r\n				}\r\n\r\n				break;\r\n\r\n		}\r\n\r\n		this.time = time;\r\n\r\n		return time;\r\n\r\n	},\r\n\r\n	_setEndings: function( atStart, atEnd, pingPong ) {\r\n\r\n		var settings = this._interpolantSettings;\r\n\r\n		if ( pingPong ) {\r\n\r\n			settings.endingStart 	= THREE.ZeroSlopeEnding;\r\n			settings.endingEnd		= THREE.ZeroSlopeEnding;\r\n\r\n		} else {\r\n\r\n			// assuming for LoopOnce atStart == atEnd == true\r\n\r\n			if ( atStart ) {\r\n\r\n				settings.endingStart = this.zeroSlopeAtStart ?\r\n						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n			} else {\r\n\r\n				settings.endingStart = THREE.WrapAroundEnding;\r\n\r\n			}\r\n\r\n			if ( atEnd ) {\r\n\r\n				settings.endingEnd = this.zeroSlopeAtEnd ?\r\n						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n			} else {\r\n\r\n				settings.endingEnd 	 = THREE.WrapAroundEnding;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\r\n		var mixer = this._mixer, now = mixer.time,\r\n			interpolant = this._weightInterpolant;\r\n\r\n		if ( interpolant === null ) {\r\n\r\n			interpolant = mixer._lendControlInterpolant(),\r\n			this._weightInterpolant = interpolant;\r\n\r\n		}\r\n\r\n		var times = interpolant.parameterPositions,\r\n			values = interpolant.sampleValues;\r\n\r\n		times[ 0 ] = now; 				values[ 0 ] = weightNow;\r\n		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// Implementation details:\r\n\r\nObject.assign( THREE.AnimationMixer.prototype, {\r\n\r\n	_bindAction: function( action, prototypeAction ) {\r\n\r\n		var root = action._localRoot || this._root,\r\n			tracks = action._clip.tracks,\r\n			nTracks = tracks.length,\r\n			bindings = action._propertyBindings,\r\n			interpolants = action._interpolants,\r\n			rootUuid = root.uuid,\r\n			bindingsByRoot = this._bindingsByRootAndName,\r\n			bindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n		if ( bindingsByName === undefined ) {\r\n\r\n			bindingsByName = {};\r\n			bindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n		}\r\n\r\n		for ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n			var track = tracks[ i ],\r\n				trackName = track.name,\r\n				binding = bindingsByName[ trackName ];\r\n\r\n			if ( binding !== undefined ) {\r\n\r\n				bindings[ i ] = binding;\r\n\r\n			} else {\r\n\r\n				binding = bindings[ i ];\r\n\r\n				if ( binding !== undefined ) {\r\n\r\n					// existing binding, make sure the cache knows\r\n\r\n					if ( binding._cacheIndex === null ) {\r\n\r\n						++ binding.referenceCount;\r\n						this._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n					}\r\n\r\n					continue;\r\n\r\n				}\r\n\r\n				var path = prototypeAction && prototypeAction.\r\n						_propertyBindings[ i ].binding.parsedPath;\r\n\r\n				binding = new THREE.PropertyMixer(\r\n						THREE.PropertyBinding.create( root, trackName, path ),\r\n						track.ValueTypeName, track.getValueSize() );\r\n\r\n				++ binding.referenceCount;\r\n				this._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n				bindings[ i ] = binding;\r\n\r\n			}\r\n\r\n			interpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_activateAction: function( action ) {\r\n\r\n		if ( ! this._isActiveAction( action ) ) {\r\n\r\n			if ( action._cacheIndex === null ) {\r\n\r\n				// this action has been forgotten by the cache, but the user\r\n				// appears to be still using it -> rebind\r\n\r\n				var rootUuid = ( action._localRoot || this._root ).uuid,\r\n					clipName = action._clip.name,\r\n					actionsForClip = this._actionsByClip[ clipName ];\r\n\r\n				this._bindAction( action,\r\n						actionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n				this._addInactiveAction( action, clipName, rootUuid );\r\n\r\n			}\r\n\r\n			var bindings = action._propertyBindings;\r\n\r\n			// increment reference counts / sort out state\r\n			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n				var binding = bindings[ i ];\r\n\r\n				if ( binding.useCount ++ === 0 ) {\r\n\r\n					this._lendBinding( binding );\r\n					binding.saveOriginalState();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this._lendAction( action );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_deactivateAction: function( action ) {\r\n\r\n		if ( this._isActiveAction( action ) ) {\r\n\r\n			var bindings = action._propertyBindings;\r\n\r\n			// decrement reference counts / sort out state\r\n			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n				var binding = bindings[ i ];\r\n\r\n				if ( -- binding.useCount === 0 ) {\r\n\r\n					binding.restoreOriginalState();\r\n					this._takeBackBinding( binding );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this._takeBackAction( action );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	// Memory manager\r\n\r\n	_initMemoryManager: function() {\r\n\r\n		this._actions = []; // 'nActiveActions' followed by inactive ones\r\n		this._nActiveActions = 0;\r\n\r\n		this._actionsByClip = {};\r\n		// inside:\r\n		// {\r\n		// 		knownActions: Array< _Action >	- used as prototypes\r\n		// 		actionByRoot: _Action			- lookup\r\n		// }\r\n\r\n\r\n		this._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n		this._nActiveBindings = 0;\r\n\r\n		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\r\n		this._controlInterpolants = []; // same game as above\r\n		this._nActiveControlInterpolants = 0;\r\n\r\n		var scope = this;\r\n\r\n		this.stats = {\r\n\r\n			actions: {\r\n				get total() { return scope._actions.length; },\r\n				get inUse() { return scope._nActiveActions; }\r\n			},\r\n			bindings: {\r\n				get total() { return scope._bindings.length; },\r\n				get inUse() { return scope._nActiveBindings; }\r\n			},\r\n			controlInterpolants: {\r\n				get total() { return scope._controlInterpolants.length; },\r\n				get inUse() { return scope._nActiveControlInterpolants; }\r\n			}\r\n\r\n		};\r\n\r\n	},\r\n\r\n	// Memory management for _Action objects\r\n\r\n	_isActiveAction: function( action ) {\r\n\r\n		var index = action._cacheIndex;\r\n		return index !== null && index < this._nActiveActions;\r\n\r\n	},\r\n\r\n	_addInactiveAction: function( action, clipName, rootUuid ) {\r\n\r\n		var actions = this._actions,\r\n			actionsByClip = this._actionsByClip,\r\n			actionsForClip = actionsByClip[ clipName ];\r\n\r\n		if ( actionsForClip === undefined ) {\r\n\r\n			actionsForClip = {\r\n\r\n				knownActions: [ action ],\r\n				actionByRoot: {}\r\n\r\n			};\r\n\r\n			action._byClipCacheIndex = 0;\r\n\r\n			actionsByClip[ clipName ] = actionsForClip;\r\n\r\n		} else {\r\n\r\n			var knownActions = actionsForClip.knownActions;\r\n\r\n			action._byClipCacheIndex = knownActions.length;\r\n			knownActions.push( action );\r\n\r\n		}\r\n\r\n		action._cacheIndex = actions.length;\r\n		actions.push( action );\r\n\r\n		actionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n	},\r\n\r\n	_removeInactiveAction: function( action ) {\r\n\r\n		var actions = this._actions,\r\n			lastInactiveAction = actions[ actions.length - 1 ],\r\n			cacheIndex = action._cacheIndex;\r\n\r\n		lastInactiveAction._cacheIndex = cacheIndex;\r\n		actions[ cacheIndex ] = lastInactiveAction;\r\n		actions.pop();\r\n\r\n		action._cacheIndex = null;\r\n\r\n\r\n		var clipName = action._clip.name,\r\n			actionsByClip = this._actionsByClip,\r\n			actionsForClip = actionsByClip[ clipName ],\r\n			knownActionsForClip = actionsForClip.knownActions,\r\n\r\n			lastKnownAction =\r\n				knownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n			byClipCacheIndex = action._byClipCacheIndex;\r\n\r\n		lastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n		knownActionsForClip.pop();\r\n\r\n		action._byClipCacheIndex = null;\r\n\r\n\r\n		var actionByRoot = actionsForClip.actionByRoot,\r\n			rootUuid = ( actions._localRoot || this._root ).uuid;\r\n\r\n		delete actionByRoot[ rootUuid ];\r\n\r\n		if ( knownActionsForClip.length === 0 ) {\r\n\r\n			delete actionsByClip[ clipName ];\r\n\r\n		}\r\n\r\n		this._removeInactiveBindingsForAction( action );\r\n\r\n	},\r\n\r\n	_removeInactiveBindingsForAction: function( action ) {\r\n\r\n		var bindings = action._propertyBindings;\r\n		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n			var binding = bindings[ i ];\r\n\r\n			if ( -- binding.referenceCount === 0 ) {\r\n\r\n				this._removeInactiveBinding( binding );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_lendAction: function( action ) {\r\n\r\n		// [ active actions |  inactive actions  ]\r\n		// [  active actions >| inactive actions ]\r\n		//                 s        a\r\n		//                  <-swap->\r\n		//                 a        s\r\n\r\n		var actions = this._actions,\r\n			prevIndex = action._cacheIndex,\r\n\r\n			lastActiveIndex = this._nActiveActions ++,\r\n\r\n			firstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n		action._cacheIndex = lastActiveIndex;\r\n		actions[ lastActiveIndex ] = action;\r\n\r\n		firstInactiveAction._cacheIndex = prevIndex;\r\n		actions[ prevIndex ] = firstInactiveAction;\r\n\r\n	},\r\n\r\n	_takeBackAction: function( action ) {\r\n\r\n		// [  active actions  | inactive actions ]\r\n		// [ active actions |< inactive actions  ]\r\n		//        a        s\r\n		//         <-swap->\r\n		//        s        a\r\n\r\n		var actions = this._actions,\r\n			prevIndex = action._cacheIndex,\r\n\r\n			firstInactiveIndex = -- this._nActiveActions,\r\n\r\n			lastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n		action._cacheIndex = firstInactiveIndex;\r\n		actions[ firstInactiveIndex ] = action;\r\n\r\n		lastActiveAction._cacheIndex = prevIndex;\r\n		actions[ prevIndex ] = lastActiveAction;\r\n\r\n	},\r\n\r\n	// Memory management for PropertyMixer objects\r\n\r\n	_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\r\n		var bindingsByRoot = this._bindingsByRootAndName,\r\n			bindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n			bindings = this._bindings;\r\n\r\n		if ( bindingByName === undefined ) {\r\n\r\n			bindingByName = {};\r\n			bindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n		}\r\n\r\n		bindingByName[ trackName ] = binding;\r\n\r\n		binding._cacheIndex = bindings.length;\r\n		bindings.push( binding );\r\n\r\n	},\r\n\r\n	_removeInactiveBinding: function( binding ) {\r\n\r\n		var bindings = this._bindings,\r\n			propBinding = binding.binding,\r\n			rootUuid = propBinding.rootNode.uuid,\r\n			trackName = propBinding.path,\r\n			bindingsByRoot = this._bindingsByRootAndName,\r\n			bindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n			lastInactiveBinding = bindings[ bindings.length - 1 ],\r\n			cacheIndex = binding._cacheIndex;\r\n\r\n		lastInactiveBinding._cacheIndex = cacheIndex;\r\n		bindings[ cacheIndex ] = lastInactiveBinding;\r\n		bindings.pop();\r\n\r\n		delete bindingByName[ trackName ];\r\n\r\n		remove_empty_map: {\r\n\r\n			for ( var _ in bindingByName ) break remove_empty_map;\r\n\r\n			delete bindingsByRoot[ rootUuid ];\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_lendBinding: function( binding ) {\r\n\r\n		var bindings = this._bindings,\r\n			prevIndex = binding._cacheIndex,\r\n\r\n			lastActiveIndex = this._nActiveBindings ++,\r\n\r\n			firstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n		binding._cacheIndex = lastActiveIndex;\r\n		bindings[ lastActiveIndex ] = binding;\r\n\r\n		firstInactiveBinding._cacheIndex = prevIndex;\r\n		bindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n	},\r\n\r\n	_takeBackBinding: function( binding ) {\r\n\r\n		var bindings = this._bindings,\r\n			prevIndex = binding._cacheIndex,\r\n\r\n			firstInactiveIndex = -- this._nActiveBindings,\r\n\r\n			lastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n		binding._cacheIndex = firstInactiveIndex;\r\n		bindings[ firstInactiveIndex ] = binding;\r\n\r\n		lastActiveBinding._cacheIndex = prevIndex;\r\n		bindings[ prevIndex ] = lastActiveBinding;\r\n\r\n	},\r\n\r\n\r\n	// Memory management of Interpolants for weight and time scale\r\n\r\n	_lendControlInterpolant: function() {\r\n\r\n		var interpolants = this._controlInterpolants,\r\n			lastActiveIndex = this._nActiveControlInterpolants ++,\r\n			interpolant = interpolants[ lastActiveIndex ];\r\n\r\n		if ( interpolant === undefined ) {\r\n\r\n			interpolant = new THREE.LinearInterpolant(\r\n					new Float32Array( 2 ), new Float32Array( 2 ),\r\n						1, this._controlInterpolantsResultBuffer );\r\n\r\n			interpolant.__cacheIndex = lastActiveIndex;\r\n			interpolants[ lastActiveIndex ] = interpolant;\r\n\r\n		}\r\n\r\n		return interpolant;\r\n\r\n	},\r\n\r\n	_takeBackControlInterpolant: function( interpolant ) {\r\n\r\n		var interpolants = this._controlInterpolants,\r\n			prevIndex = interpolant.__cacheIndex,\r\n\r\n			firstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n			lastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n		interpolant.__cacheIndex = firstInactiveIndex;\r\n		interpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n		lastActiveInterpolant.__cacheIndex = prevIndex;\r\n		interpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n	},\r\n\r\n	_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationObjectGroup.js\r\n\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n * 	-	Add objects you would otherwise pass as 'root' to the\r\n * 		constructor or the .clipAction method of AnimationMixer.\r\n *\r\n * 	-	Instead pass this object as 'root'.\r\n *\r\n * 	-	You can also add and remove objects later when the mixer\r\n * 		is running.\r\n *\r\n * Note:\r\n *\r\n *  	Objects of this class appear as one object to the mixer,\r\n *  	so cache control of the individual objects must be done\r\n *  	on the group.\r\n *\r\n * Limitation:\r\n *\r\n * 	- 	The animated properties must be compatible among the\r\n * 		all objects in the group.\r\n *\r\n *  -	A single property can either be controlled through a\r\n *  	target group or directly, but not both.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationObjectGroup = function( var_args ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	// cached objects followed by the active ones\r\n	this._objects = Array.prototype.slice.call( arguments );\r\n\r\n	this.nCachedObjects_ = 0;			// threshold\r\n	// note: read by PropertyBinding.Composite\r\n\r\n	var indices = {};\r\n	this._indicesByUUID = indices;		// for bookkeeping\r\n\r\n	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n		indices[ arguments[ i ].uuid ] = i;\r\n\r\n	}\r\n\r\n	this._paths = [];					// inside: string\r\n	this._parsedPaths = [];				// inside: { we don't care, here }\r\n	this._bindings = []; 				// inside: Array< PropertyBinding >\r\n	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays\r\n\r\n	var scope = this;\r\n\r\n	this.stats = {\r\n\r\n		objects: {\r\n			get total() { return scope._objects.length; },\r\n			get inUse() { return this.total - scope.nCachedObjects_;  }\r\n		},\r\n\r\n		get bindingsPerObject() { return scope._bindings.length; }\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.AnimationObjectGroup.prototype = {\r\n\r\n	constructor: THREE.AnimationObjectGroup,\r\n\r\n	add: function( var_args ) {\r\n\r\n		var objects = this._objects,\r\n			nObjects = objects.length,\r\n			nCachedObjects = this.nCachedObjects_,\r\n			indicesByUUID = this._indicesByUUID,\r\n			paths = this._paths,\r\n			parsedPaths = this._parsedPaths,\r\n			bindings = this._bindings,\r\n			nBindings = bindings.length;\r\n\r\n		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n			var object = arguments[ i ],\r\n				uuid = object.uuid,\r\n				index = indicesByUUID[ uuid ];\r\n\r\n			if ( index === undefined ) {\r\n\r\n				// unknown object -> add it to the ACTIVE region\r\n\r\n				index = nObjects ++;\r\n				indicesByUUID[ uuid ] = index;\r\n				objects.push( object );\r\n\r\n				// accounting is done, now do the same for all bindings\r\n\r\n				for ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n					bindings[ j ].push(\r\n							new THREE.PropertyBinding(\r\n								object, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n				}\r\n\r\n			} else if ( index < nCachedObjects ) {\r\n\r\n				var knownObject = objects[ index ];\r\n\r\n				// move existing object to the ACTIVE region\r\n\r\n				var firstActiveIndex = -- nCachedObjects,\r\n					lastCachedObject = objects[ firstActiveIndex ];\r\n\r\n				indicesByUUID[ lastCachedObject.uuid ] = index;\r\n				objects[ index ] = lastCachedObject;\r\n\r\n				indicesByUUID[ uuid ] = firstActiveIndex;\r\n				objects[ firstActiveIndex ] = object;\r\n\r\n				// accounting is done, now do the same for all bindings\r\n\r\n				for ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n					var bindingsForPath = bindings[ j ],\r\n						lastCached = bindingsForPath[ firstActiveIndex ],\r\n						binding = bindingsForPath[ index ];\r\n\r\n					bindingsForPath[ index ] = lastCached;\r\n\r\n					if ( binding === undefined ) {\r\n\r\n						// since we do not bother to create new bindings\r\n						// for objects that are cached, the binding may\r\n						// or may not exist\r\n\r\n						binding = new THREE.PropertyBinding(\r\n								object, paths[ j ], parsedPaths[ j ] );\r\n\r\n					}\r\n\r\n					bindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n				}\r\n\r\n			} else if ( objects[ index ] !== knownObject) {\r\n\r\n				console.error( \"Different objects with the same UUID \" +\r\n						\"detected. Clean the caches or recreate your \" +\r\n						\"infrastructure when reloading scenes...\" );\r\n\r\n			} // else the object is already where we want it to be\r\n\r\n		} // for arguments\r\n\r\n		this.nCachedObjects_ = nCachedObjects;\r\n\r\n	},\r\n\r\n	remove: function( var_args ) {\r\n\r\n		var objects = this._objects,\r\n			nObjects = objects.length,\r\n			nCachedObjects = this.nCachedObjects_,\r\n			indicesByUUID = this._indicesByUUID,\r\n			bindings = this._bindings,\r\n			nBindings = bindings.length;\r\n\r\n		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n			var object = arguments[ i ],\r\n				uuid = object.uuid,\r\n				index = indicesByUUID[ uuid ];\r\n\r\n			if ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n				// move existing object into the CACHED region\r\n\r\n				var lastCachedIndex = nCachedObjects ++,\r\n					firstActiveObject = objects[ lastCachedIndex ];\r\n\r\n				indicesByUUID[ firstActiveObject.uuid ] = index;\r\n				objects[ index ] = firstActiveObject;\r\n\r\n				indicesByUUID[ uuid ] = lastCachedIndex;\r\n				objects[ lastCachedIndex ] = object;\r\n\r\n				// accounting is done, now do the same for all bindings\r\n\r\n				for ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n					var bindingsForPath = bindings[ j ],\r\n						firstActive = bindingsForPath[ lastCachedIndex ],\r\n						binding = bindingsForPath[ index ];\r\n\r\n					bindingsForPath[ index ] = firstActive;\r\n					bindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} // for arguments\r\n\r\n		this.nCachedObjects_ = nCachedObjects;\r\n\r\n	},\r\n\r\n	// remove & forget\r\n	uncache: function( var_args ) {\r\n\r\n		var objects = this._objects,\r\n			nObjects = objects.length,\r\n			nCachedObjects = this.nCachedObjects_,\r\n			indicesByUUID = this._indicesByUUID,\r\n			bindings = this._bindings,\r\n			nBindings = bindings.length;\r\n\r\n		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n			var object = arguments[ i ],\r\n				uuid = object.uuid,\r\n				index = indicesByUUID[ uuid ];\r\n\r\n			if ( index !== undefined ) {\r\n\r\n				delete indicesByUUID[ uuid ];\r\n\r\n				if ( index < nCachedObjects ) {\r\n\r\n					// object is cached, shrink the CACHED region\r\n\r\n					var firstActiveIndex = -- nCachedObjects,\r\n						lastCachedObject = objects[ firstActiveIndex ],\r\n						lastIndex = -- nObjects,\r\n						lastObject = objects[ lastIndex ];\r\n\r\n					// last cached object takes this object's place\r\n					indicesByUUID[ lastCachedObject.uuid ] = index;\r\n					objects[ index ] = lastCachedObject;\r\n\r\n					// last object goes to the activated slot and pop\r\n					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n					objects[ firstActiveIndex ] = lastObject;\r\n					objects.pop();\r\n\r\n					// accounting is done, now do the same for all bindings\r\n\r\n					for ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n						var bindingsForPath = bindings[ j ],\r\n							lastCached = bindingsForPath[ firstActiveIndex ],\r\n							last = bindingsForPath[ lastIndex ];\r\n\r\n						bindingsForPath[ index ] = lastCached;\r\n						bindingsForPath[ firstActiveIndex ] = last;\r\n						bindingsForPath.pop();\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					// object is active, just swap with the last and pop\r\n\r\n					var lastIndex = -- nObjects,\r\n						lastObject = objects[ lastIndex ];\r\n\r\n					indicesByUUID[ lastObject.uuid ] = index;\r\n					objects[ index ] = lastObject;\r\n					objects.pop();\r\n\r\n					// accounting is done, now do the same for all bindings\r\n\r\n					for ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n						var bindingsForPath = bindings[ j ];\r\n\r\n						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n						bindingsForPath.pop();\r\n\r\n					}\r\n\r\n				} // cached or active\r\n\r\n			} // if object is known\r\n\r\n		} // for arguments\r\n\r\n		this.nCachedObjects_ = nCachedObjects;\r\n\r\n	},\r\n\r\n	// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n	subscribe_: function( path, parsedPath ) {\r\n		// returns an array of bindings for the given path that is changed\r\n		// according to the contained objects in the group\r\n\r\n		var indicesByPath = this._bindingsIndicesByPath,\r\n			index = indicesByPath[ path ],\r\n			bindings = this._bindings;\r\n\r\n		if ( index !== undefined ) return bindings[ index ];\r\n\r\n		var paths = this._paths,\r\n			parsedPaths = this._parsedPaths,\r\n			objects = this._objects,\r\n			nObjects = objects.length,\r\n			nCachedObjects = this.nCachedObjects_,\r\n			bindingsForPath = new Array( nObjects );\r\n\r\n		index = bindings.length;\r\n\r\n		indicesByPath[ path ] = index;\r\n\r\n		paths.push( path );\r\n		parsedPaths.push( parsedPath );\r\n		bindings.push( bindingsForPath );\r\n\r\n		for ( var i = nCachedObjects,\r\n				n = objects.length; i !== n; ++ i ) {\r\n\r\n			var object = objects[ i ];\r\n\r\n			bindingsForPath[ i ] =\r\n					new THREE.PropertyBinding( object, path, parsedPath );\r\n\r\n		}\r\n\r\n		return bindingsForPath;\r\n\r\n	},\r\n\r\n	unsubscribe_: function( path ) {\r\n		// tells the group to forget about a property path and no longer\r\n		// update the array previously obtained with 'subscribe_'\r\n\r\n		var indicesByPath = this._bindingsIndicesByPath,\r\n			index = indicesByPath[ path ];\r\n\r\n		if ( index !== undefined ) {\r\n\r\n			var paths = this._paths,\r\n				parsedPaths = this._parsedPaths,\r\n				bindings = this._bindings,\r\n				lastBindingsIndex = bindings.length - 1,\r\n				lastBindings = bindings[ lastBindingsIndex ],\r\n				lastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n			indicesByPath[ lastBindingsPath ] = index;\r\n\r\n			bindings[ index ] = lastBindings;\r\n			bindings.pop();\r\n\r\n			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n			parsedPaths.pop();\r\n\r\n			paths[ index ] = paths[ lastBindingsIndex ];\r\n			paths.pop();\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// File:src/animation/AnimationUtils.js\r\n\r\n/**\r\n * @author tschw\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationUtils = {\r\n\r\n	// same as Array.prototype.slice, but also works on typed arrays\r\n	arraySlice: function( array, from, to ) {\r\n\r\n		if ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\r\n			return new array.constructor( array.subarray( from, to ) );\r\n\r\n		}\r\n\r\n		return array.slice( from, to );\r\n\r\n	},\r\n\r\n	// converts an array to a specific type\r\n	convertArray: function( array, type, forceClone ) {\r\n\r\n		if ( ! array || // let 'undefined' and 'null' pass\r\n				! forceClone && array.constructor === type ) return array;\r\n\r\n		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n			return new type( array ); // create typed array\r\n\r\n		}\r\n\r\n		return Array.prototype.slice.call( array ); // create Array\r\n\r\n	},\r\n\r\n	isTypedArray: function( object ) {\r\n\r\n		return ArrayBuffer.isView( object ) &&\r\n				! ( object instanceof DataView );\r\n\r\n	},\r\n\r\n	// returns an array by which times and values can be sorted\r\n	getKeyframeOrder: function( times ) {\r\n\r\n		function compareTime( i, j ) {\r\n\r\n			return times[ i ] - times[ j ];\r\n\r\n		}\r\n\r\n		var n = times.length;\r\n		var result = new Array( n );\r\n		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\r\n		result.sort( compareTime );\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n	sortedArray: function( values, stride, order ) {\r\n\r\n		var nValues = values.length;\r\n		var result = new values.constructor( nValues );\r\n\r\n		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n			var srcOffset = order[ i ] * stride;\r\n\r\n			for ( var j = 0; j !== stride; ++ j ) {\r\n\r\n				result[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	// function for parsing AOS keyframe formats\r\n	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n		var i = 1, key = jsonKeys[ 0 ];\r\n\r\n		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n			key = jsonKeys[ i ++ ];\r\n\r\n		}\r\n\r\n		if ( key === undefined ) return; // no data\r\n\r\n		var value = key[ valuePropertyName ];\r\n		if ( value === undefined ) return; // no data\r\n\r\n		if ( Array.isArray( value ) ) {\r\n\r\n			do {\r\n\r\n				value = key[ valuePropertyName ];\r\n\r\n				if ( value !== undefined ) {\r\n\r\n					times.push( key.time );\r\n					values.push.apply( values, value ); // push all elements\r\n\r\n				}\r\n\r\n				key = jsonKeys[ i ++ ];\r\n\r\n			} while ( key !== undefined );\r\n\r\n		} else if ( value.toArray !== undefined ) {\r\n			// ...assume THREE.Math-ish\r\n\r\n			do {\r\n\r\n				value = key[ valuePropertyName ];\r\n\r\n				if ( value !== undefined ) {\r\n\r\n					times.push( key.time );\r\n					value.toArray( values, values.length );\r\n\r\n				}\r\n\r\n				key = jsonKeys[ i ++ ];\r\n\r\n			} while ( key !== undefined );\r\n\r\n		} else {\r\n			// otherwise push as-is\r\n\r\n			do {\r\n\r\n				value = key[ valuePropertyName ];\r\n\r\n				if ( value !== undefined ) {\r\n\r\n					times.push( key.time );\r\n					values.push( value );\r\n\r\n				}\r\n\r\n				key = jsonKeys[ i ++ ];\r\n\r\n			} while ( key !== undefined );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/animation/KeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A timed sequence of keyframes for a specific property.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n	if( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\r\n	if( times === undefined || times.length === 0 ) {\r\n\r\n		throw new Error( \"no keyframes in track named \" + name );\r\n\r\n	}\r\n\r\n	this.name = name;\r\n\r\n	this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n	this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n	this.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n	this.validate();\r\n	this.optimize();\r\n\r\n};\r\n\r\nTHREE.KeyframeTrack.prototype = {\r\n\r\n	constructor: THREE.KeyframeTrack,\r\n\r\n	TimeBufferType: Float32Array,\r\n	ValueBufferType: Float32Array,\r\n\r\n	DefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n	InterpolantFactoryMethodDiscrete: function( result ) {\r\n\r\n		return new THREE.DiscreteInterpolant(\r\n				this.times, this.values, this.getValueSize(), result );\r\n\r\n	},\r\n\r\n	InterpolantFactoryMethodLinear: function( result ) {\r\n\r\n		return new THREE.LinearInterpolant(\r\n				this.times, this.values, this.getValueSize(), result );\r\n\r\n	},\r\n\r\n	InterpolantFactoryMethodSmooth: function( result ) {\r\n\r\n		return new THREE.CubicInterpolant(\r\n				this.times, this.values, this.getValueSize(), result );\r\n\r\n	},\r\n\r\n	setInterpolation: function( interpolation ) {\r\n\r\n		var factoryMethod = undefined;\r\n\r\n		switch ( interpolation ) {\r\n\r\n			case THREE.InterpolateDiscrete:\r\n\r\n				factoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n				break;\r\n\r\n			case THREE.InterpolateLinear:\r\n\r\n				factoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n				break;\r\n\r\n			case THREE.InterpolateSmooth:\r\n\r\n				factoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n				break;\r\n\r\n		}\r\n\r\n		if ( factoryMethod === undefined ) {\r\n\r\n			var message = \"unsupported interpolation for \" +\r\n					this.ValueTypeName + \" keyframe track named \" + this.name;\r\n\r\n			if ( this.createInterpolant === undefined ) {\r\n\r\n				// fall back to default, unless the default itself is messed up\r\n				if ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n					this.setInterpolation( this.DefaultInterpolation );\r\n\r\n				} else {\r\n\r\n					throw new Error( message ); // fatal, in this case\r\n\r\n				}\r\n\r\n			}\r\n\r\n			console.warn( message );\r\n			return;\r\n\r\n		}\r\n\r\n		this.createInterpolant = factoryMethod;\r\n\r\n	},\r\n\r\n	getInterpolation: function() {\r\n\r\n		switch ( this.createInterpolant ) {\r\n\r\n			case this.InterpolantFactoryMethodDiscrete:\r\n\r\n				return THREE.InterpolateDiscrete;\r\n\r\n			case this.InterpolantFactoryMethodLinear:\r\n\r\n				return THREE.InterpolateLinear;\r\n\r\n			case this.InterpolantFactoryMethodSmooth:\r\n\r\n				return THREE.InterpolateSmooth;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getValueSize: function() {\r\n\r\n		return this.values.length / this.times.length;\r\n\r\n	},\r\n\r\n	// move all keyframes either forwards or backwards in time\r\n	shift: function( timeOffset ) {\r\n\r\n		if( timeOffset !== 0.0 ) {\r\n\r\n			var times = this.times;\r\n\r\n			for( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n				times[ i ] += timeOffset;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n	scale: function( timeScale ) {\r\n\r\n		if( timeScale !== 1.0 ) {\r\n\r\n			var times = this.times;\r\n\r\n			for( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n				times[ i ] *= timeScale;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n	trim: function( startTime, endTime ) {\r\n\r\n		var times = this.times,\r\n			nKeys = times.length,\r\n			from = 0,\r\n			to = nKeys - 1;\r\n\r\n		while ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n		while ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\r\n		++ to; // inclusive -> exclusive bound\r\n\r\n		if( from !== 0 || to !== nKeys ) {\r\n\r\n			// empty tracks are forbidden, so keep at least one keyframe\r\n			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\r\n			var stride = this.getValueSize();\r\n			this.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n			this.values = THREE.AnimationUtils.\r\n					arraySlice( this.values, from * stride, to * stride );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n	validate: function() {\r\n\r\n		var valid = true;\r\n\r\n		var valueSize = this.getValueSize();\r\n		if ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n			console.error( \"invalid value size in track\", this );\r\n			valid = false;\r\n\r\n		}\r\n\r\n		var times = this.times,\r\n			values = this.values,\r\n\r\n			nKeys = times.length;\r\n\r\n		if( nKeys === 0 ) {\r\n\r\n			console.error( \"track is empty\", this );\r\n			valid = false;\r\n\r\n		}\r\n\r\n		var prevTime = null;\r\n\r\n		for( var i = 0; i !== nKeys; i ++ ) {\r\n\r\n			var currTime = times[ i ];\r\n\r\n			if ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n				console.error( \"time is not a valid number\", this, i, currTime );\r\n				valid = false;\r\n				break;\r\n\r\n			}\r\n\r\n			if( prevTime !== null && prevTime > currTime ) {\r\n\r\n				console.error( \"out of order keys\", this, i, currTime, prevTime );\r\n				valid = false;\r\n				break;\r\n\r\n			}\r\n\r\n			prevTime = currTime;\r\n\r\n		}\r\n\r\n		if ( values !== undefined ) {\r\n\r\n			if ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\r\n				for ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n					var value = values[ i ];\r\n\r\n					if ( isNaN( value ) ) {\r\n\r\n						console.error( \"value is not a valid number\", this, i, value );\r\n						valid = false;\r\n						break;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return valid;\r\n\r\n	},\r\n\r\n	// removes equivalent sequential keys as common in morph target sequences\r\n	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n	optimize: function() {\r\n\r\n		var times = this.times,\r\n			values = this.values,\r\n			stride = this.getValueSize(),\r\n\r\n			writeIndex = 1;\r\n\r\n		for( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\r\n			var keep = false;\r\n\r\n			var time = times[ i ];\r\n			var timeNext = times[ i + 1 ];\r\n\r\n			// remove adjacent keyframes scheduled at the same time\r\n\r\n			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\r\n				// remove unnecessary keyframes same as their neighbors\r\n				var offset = i * stride,\r\n					offsetP = offset - stride,\r\n					offsetN = offset + stride;\r\n\r\n				for ( var j = 0; j !== stride; ++ j ) {\r\n\r\n					var value = values[ offset + j ];\r\n\r\n					if ( value !== values[ offsetP + j ] ||\r\n							value !== values[ offsetN + j ] ) {\r\n\r\n						keep = true;\r\n						break;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// in-place compaction\r\n\r\n			if ( keep ) {\r\n\r\n				if ( i !== writeIndex ) {\r\n\r\n					times[ writeIndex ] = times[ i ];\r\n\r\n					var readOffset = i * stride,\r\n						writeOffset = writeIndex * stride;\r\n\r\n					for ( var j = 0; j !== stride; ++ j ) {\r\n\r\n						values[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n					}\r\n\r\n\r\n				}\r\n\r\n				++ writeIndex;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( writeIndex !== times.length ) {\r\n\r\n			this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n			this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.KeyframeTrack, {\r\n\r\n	// Serialization (in static context, because of constructor invocation\r\n	// and automatic invocation of .toJSON):\r\n\r\n	parse: function( json ) {\r\n\r\n		if( json.type === undefined ) {\r\n\r\n			throw new Error( \"track type undefined, can not parse\" );\r\n\r\n		}\r\n\r\n		var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\r\n		if ( json.times === undefined ) {\r\n\r\n			console.warn( \"legacy JSON format detected, converting\" );\r\n\r\n			var times = [], values = [];\r\n\r\n			THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n			json.times = times;\r\n			json.values = values;\r\n\r\n		}\r\n\r\n		// derived classes can define a static parse method\r\n		if ( trackType.parse !== undefined ) {\r\n\r\n			return trackType.parse( json );\r\n\r\n		} else {\r\n\r\n			// by default, we asssume a constructor compatible with the base\r\n			return new trackType(\r\n					json.name, json.times, json.values, json.interpolation );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function( track ) {\r\n\r\n		var trackType = track.constructor;\r\n\r\n		var json;\r\n\r\n		// derived classes can define a static toJSON method\r\n		if ( trackType.toJSON !== undefined ) {\r\n\r\n			json = trackType.toJSON( track );\r\n\r\n		} else {\r\n\r\n			// by default, we assume the data can be serialized as-is\r\n			json = {\r\n\r\n				'name': track.name,\r\n				'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n				'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\r\n			};\r\n\r\n			var interpolation = track.getInterpolation();\r\n\r\n			if ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n				json.interpolation = interpolation;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		json.type = track.ValueTypeName; // mandatory\r\n\r\n		return json;\r\n\r\n	},\r\n\r\n	_getTrackTypeForValueTypeName: function( typeName ) {\r\n\r\n		switch( typeName.toLowerCase() ) {\r\n\r\n			case \"scalar\":\r\n			case \"double\":\r\n			case \"float\":\r\n			case \"number\":\r\n			case \"integer\":\r\n\r\n				return THREE.NumberKeyframeTrack;\r\n\r\n			case \"vector\":\r\n			case \"vector2\":\r\n			case \"vector3\":\r\n			case \"vector4\":\r\n\r\n				return THREE.VectorKeyframeTrack;\r\n\r\n			case \"color\":\r\n\r\n				return THREE.ColorKeyframeTrack;\r\n\r\n			case \"quaternion\":\r\n\r\n				return THREE.QuaternionKeyframeTrack;\r\n\r\n			case \"bool\":\r\n			case \"boolean\":\r\n\r\n				return THREE.BooleanKeyframeTrack;\r\n\r\n			case \"string\":\r\n\r\n				return THREE.StringKeyframeTrack;\r\n\r\n		};\r\n\r\n		throw new Error( \"Unsupported typeName: \" + typeName );\r\n\r\n	}\r\n\r\n} );\r\n\r\n// File:src/animation/PropertyBinding.js\r\n\r\n/**\r\n *\r\n * A reference to a real property in the scene graph.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\r\n	this.path = path;\r\n	this.parsedPath = parsedPath ||\r\n			THREE.PropertyBinding.parseTrackName( path );\r\n\r\n	this.node = THREE.PropertyBinding.findNode(\r\n			rootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n	this.rootNode = rootNode;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.prototype = {\r\n\r\n	constructor: THREE.PropertyBinding,\r\n\r\n	getValue: function getValue_unbound( targetArray, offset ) {\r\n\r\n		this.bind();\r\n		this.getValue( targetArray, offset );\r\n\r\n		// Note: This class uses a State pattern on a per-method basis:\r\n		// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n		// prototype version of these methods with one that represents\r\n		// the bound state. When the property is not found, the methods\r\n		// become no-ops.\r\n\r\n	},\r\n\r\n	setValue: function getValue_unbound( sourceArray, offset ) {\r\n\r\n		this.bind();\r\n		this.setValue( sourceArray, offset );\r\n\r\n	},\r\n\r\n	// create getter / setter pair for a property in the scene graph\r\n	bind: function() {\r\n\r\n		var targetObject = this.node,\r\n			parsedPath = this.parsedPath,\r\n\r\n			objectName = parsedPath.objectName,\r\n			propertyName = parsedPath.propertyName,\r\n			propertyIndex = parsedPath.propertyIndex;\r\n\r\n		if ( ! targetObject ) {\r\n\r\n			targetObject = THREE.PropertyBinding.findNode(\r\n					this.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n			this.node = targetObject;\r\n\r\n		}\r\n\r\n		// set fail state so we can just 'return' on error\r\n		this.getValue = this._getValue_unavailable;\r\n		this.setValue = this._setValue_unavailable;\r\n\r\n 		// ensure there is a value node\r\n		if ( ! targetObject ) {\r\n\r\n			console.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n			return;\r\n\r\n		}\r\n\r\n		if( objectName ) {\r\n\r\n			var objectIndex = parsedPath.objectIndex;\r\n\r\n			// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n			switch ( objectName ) {\r\n\r\n				case 'materials':\r\n\r\n					if( ! targetObject.material ) {\r\n\r\n						console.error( '  can not bind to material as node does not have a material', this );\r\n						return;\r\n\r\n					}\r\n\r\n					if( ! targetObject.material.materials ) {\r\n\r\n						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n						return;\r\n\r\n					}\r\n\r\n					targetObject = targetObject.material.materials;\r\n\r\n					break;\r\n\r\n				case 'bones':\r\n\r\n					if( ! targetObject.skeleton ) {\r\n\r\n						console.error( '  can not bind to bones as node does not have a skeleton', this );\r\n						return;\r\n\r\n					}\r\n\r\n					// potential future optimization: skip this if propertyIndex is already an integer\r\n					// and convert the integer string to a true integer.\r\n\r\n					targetObject = targetObject.skeleton.bones;\r\n\r\n					// support resolving morphTarget names into indices.\r\n					for ( var i = 0; i < targetObject.length; i ++ ) {\r\n\r\n						if ( targetObject[i].name === objectIndex ) {\r\n\r\n							objectIndex = i;\r\n							break;\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					if ( targetObject[ objectName ] === undefined ) {\r\n\r\n						console.error( '  can not bind to objectName of node, undefined', this );\r\n						return;\r\n\r\n					}\r\n\r\n					targetObject = targetObject[ objectName ];\r\n\r\n			}\r\n\r\n\r\n			if ( objectIndex !== undefined ) {\r\n\r\n				if( targetObject[ objectIndex ] === undefined ) {\r\n\r\n					console.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n					return;\r\n\r\n				}\r\n\r\n				targetObject = targetObject[ objectIndex ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// resolve property\r\n		var nodeProperty = targetObject[ propertyName ];\r\n\r\n		if ( ! nodeProperty ) {\r\n\r\n			var nodeName = parsedPath.nodeName;\r\n\r\n			console.error( \"  trying to update property for track: \" + nodeName +\r\n					'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n			return;\r\n\r\n		}\r\n\r\n		// determine versioning scheme\r\n		var versioning = this.Versioning.None;\r\n\r\n		if ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n			versioning = this.Versioning.NeedsUpdate;\r\n			this.targetObject = targetObject;\r\n\r\n		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n			versioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n			this.targetObject = targetObject;\r\n\r\n		}\r\n\r\n		// determine how the property gets bound\r\n		var bindingType = this.BindingType.Direct;\r\n\r\n		if ( propertyIndex !== undefined ) {\r\n			// access a sub element of the property array (only primitives are supported right now)\r\n\r\n			if ( propertyName === \"morphTargetInfluences\" ) {\r\n				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n				// support resolving morphTarget names into indices.\r\n				if ( ! targetObject.geometry ) {\r\n\r\n					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n					return;\r\n\r\n				}\r\n\r\n				if ( ! targetObject.geometry.morphTargets ) {\r\n\r\n					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n					return;\r\n\r\n				}\r\n\r\n				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\r\n					if ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\r\n						propertyIndex = i;\r\n						break;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			bindingType = this.BindingType.ArrayElement;\r\n\r\n			this.resolvedProperty = nodeProperty;\r\n			this.propertyIndex = propertyIndex;\r\n\r\n		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n			// must use copy for Object3D.Euler/Quaternion\r\n\r\n			bindingType = this.BindingType.HasFromToArray;\r\n\r\n			this.resolvedProperty = nodeProperty;\r\n\r\n		} else if ( nodeProperty.length !== undefined ) {\r\n\r\n			bindingType = this.BindingType.EntireArray;\r\n\r\n			this.resolvedProperty = nodeProperty;\r\n\r\n		} else {\r\n\r\n			this.propertyName = propertyName;\r\n\r\n		}\r\n\r\n		// select getter / setter\r\n		this.getValue = this.GetterByBindingType[ bindingType ];\r\n		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n	},\r\n\r\n	unbind: function() {\r\n\r\n		this.node = null;\r\n\r\n		// back to the prototype version of getValue / setValue\r\n		// note: avoiding to mutate the shape of 'this' via 'delete'\r\n		this.getValue = this._getValue_unbound;\r\n		this.setValue = this._setValue_unbound;\r\n\r\n	}\r\n\r\n};\r\n\r\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\r\n	// these are used to \"bind\" a nonexistent property\r\n	_getValue_unavailable: function() {},\r\n	_setValue_unavailable: function() {},\r\n\r\n	// initial state of these methods that calls 'bind'\r\n	_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n	_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\r\n	BindingType: {\r\n		Direct: 0,\r\n		EntireArray: 1,\r\n		ArrayElement: 2,\r\n		HasFromToArray: 3\r\n	},\r\n\r\n	Versioning: {\r\n		None: 0,\r\n		NeedsUpdate: 1,\r\n		MatrixWorldNeedsUpdate: 2\r\n	},\r\n\r\n	GetterByBindingType: [\r\n\r\n		function getValue_direct( buffer, offset ) {\r\n\r\n			buffer[ offset ] = this.node[ this.propertyName ];\r\n\r\n		},\r\n\r\n		function getValue_array( buffer, offset ) {\r\n\r\n			var source = this.resolvedProperty;\r\n\r\n			for ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n				buffer[ offset ++ ] = source[ i ];\r\n\r\n			}\r\n\r\n		},\r\n\r\n		function getValue_arrayElement( buffer, offset ) {\r\n\r\n			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n		},\r\n\r\n		function getValue_toArray( buffer, offset ) {\r\n\r\n			this.resolvedProperty.toArray( buffer, offset );\r\n\r\n		}\r\n\r\n	],\r\n\r\n	SetterByBindingTypeAndVersioning: [\r\n\r\n		[\r\n			// Direct\r\n\r\n			function setValue_direct( buffer, offset ) {\r\n\r\n				this.node[ this.propertyName ] = buffer[ offset ];\r\n\r\n			},\r\n\r\n			function setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n				this.node[ this.propertyName ] = buffer[ offset ];\r\n				this.targetObject.needsUpdate = true;\r\n\r\n			},\r\n\r\n			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n				this.node[ this.propertyName ] = buffer[ offset ];\r\n				this.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n			}\r\n\r\n		], [\r\n\r\n			// EntireArray\r\n\r\n			function setValue_array( buffer, offset ) {\r\n\r\n				var dest = this.resolvedProperty;\r\n\r\n				for ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n					dest[ i ] = buffer[ offset ++ ];\r\n\r\n				}\r\n\r\n			},\r\n\r\n			function setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n				var dest = this.resolvedProperty;\r\n\r\n				for ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n					dest[ i ] = buffer[ offset ++ ];\r\n\r\n				}\r\n\r\n				this.targetObject.needsUpdate = true;\r\n\r\n			},\r\n\r\n			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n				var dest = this.resolvedProperty;\r\n\r\n				for ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n					dest[ i ] = buffer[ offset ++ ];\r\n\r\n				}\r\n\r\n				this.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n			}\r\n\r\n		], [\r\n\r\n			// ArrayElement\r\n\r\n			function setValue_arrayElement( buffer, offset ) {\r\n\r\n				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n			},\r\n\r\n			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n				this.targetObject.needsUpdate = true;\r\n\r\n			},\r\n\r\n			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n				this.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n			}\r\n\r\n		], [\r\n\r\n			// HasToFromArray\r\n\r\n			function setValue_fromArray( buffer, offset ) {\r\n\r\n				this.resolvedProperty.fromArray( buffer, offset );\r\n\r\n			},\r\n\r\n			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n				this.resolvedProperty.fromArray( buffer, offset );\r\n				this.targetObject.needsUpdate = true;\r\n\r\n			},\r\n\r\n			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n				this.resolvedProperty.fromArray( buffer, offset );\r\n				this.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n			}\r\n\r\n		]\r\n\r\n	]\r\n\r\n} );\r\n\r\nTHREE.PropertyBinding.Composite =\r\n		function( targetGroup, path, optionalParsedPath ) {\r\n\r\n	var parsedPath = optionalParsedPath ||\r\n			THREE.PropertyBinding.parseTrackName( path );\r\n\r\n	this._targetGroup = targetGroup;\r\n	this._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.Composite.prototype = {\r\n\r\n	constructor: THREE.PropertyBinding.Composite,\r\n\r\n	getValue: function( array, offset ) {\r\n\r\n		this.bind(); // bind all binding\r\n\r\n		var firstValidIndex = this._targetGroup.nCachedObjects_,\r\n			binding = this._bindings[ firstValidIndex ];\r\n\r\n		// and only call .getValue on the first\r\n		if ( binding !== undefined ) binding.getValue( array, offset );\r\n\r\n	},\r\n\r\n	setValue: function( array, offset ) {\r\n\r\n		var bindings = this._bindings;\r\n\r\n		for ( var i = this._targetGroup.nCachedObjects_,\r\n				n = bindings.length; i !== n; ++ i ) {\r\n\r\n			bindings[ i ].setValue( array, offset );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	bind: function() {\r\n\r\n		var bindings = this._bindings;\r\n\r\n		for ( var i = this._targetGroup.nCachedObjects_,\r\n				n = bindings.length; i !== n; ++ i ) {\r\n\r\n			bindings[ i ].bind();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	unbind: function() {\r\n\r\n		var bindings = this._bindings;\r\n\r\n		for ( var i = this._targetGroup.nCachedObjects_,\r\n				n = bindings.length; i !== n; ++ i ) {\r\n\r\n			bindings[ i ].unbind();\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\r\n	if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\r\n		return new THREE.PropertyBinding( root, path, parsedPath );\r\n\r\n	} else {\r\n\r\n		return new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\r\n	// matches strings in the form of:\r\n	//    nodeName.property\r\n	//    nodeName.property[accessor]\r\n	//    nodeName.material.property[accessor]\r\n	//    uuid.property[accessor]\r\n	//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n	//    parentName/nodeName.property\r\n	//    parentName/parentName/nodeName.property[index]\r\n	//	  .bone[Armature.DEF_cog].position\r\n	// created and tested via https://regex101.com/#javascript\r\n\r\n	var re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n	var matches = re.exec(trackName);\r\n\r\n	if( ! matches ) {\r\n		throw new Error( \"cannot parse trackName at all: \" + trackName );\r\n	}\r\n\r\n    if (matches.index === re.lastIndex) {\r\n        re.lastIndex++;\r\n    }\r\n\r\n	var results = {\r\n		// directoryName: matches[1], // (tschw) currently unused\r\n		nodeName: matches[3], 	// allowed to be null, specified root node.\r\n		objectName: matches[5],\r\n		objectIndex: matches[7],\r\n		propertyName: matches[9],\r\n		propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.\r\n	};\r\n\r\n	if( results.propertyName === null || results.propertyName.length === 0 ) {\r\n		throw new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n	}\r\n\r\n	return results;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\r\n	if( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n		return root;\r\n\r\n	}\r\n\r\n	// search into skeleton bones.\r\n	if( root.skeleton ) {\r\n\r\n		var searchSkeleton = function( skeleton ) {\r\n\r\n			for( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\r\n				var bone = skeleton.bones[i];\r\n\r\n				if( bone.name === nodeName ) {\r\n\r\n					return bone;\r\n\r\n				}\r\n			}\r\n\r\n			return null;\r\n\r\n		};\r\n\r\n		var bone = searchSkeleton( root.skeleton );\r\n\r\n		if( bone ) {\r\n\r\n			return bone;\r\n\r\n		}\r\n	}\r\n\r\n	// search into node subtree.\r\n	if( root.children ) {\r\n\r\n		var searchNodeSubtree = function( children ) {\r\n\r\n			for( var i = 0; i < children.length; i ++ ) {\r\n\r\n				var childNode = children[i];\r\n\r\n				if( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n					return childNode;\r\n\r\n				}\r\n\r\n				var result = searchNodeSubtree( childNode.children );\r\n\r\n				if( result ) return result;\r\n\r\n			}\r\n\r\n			return null;\r\n\r\n		};\r\n\r\n		var subTreeNode = searchNodeSubtree( root.children );\r\n\r\n		if( subTreeNode ) {\r\n\r\n			return subTreeNode;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return null;\r\n\r\n}\r\n\r\n// File:src/animation/PropertyMixer.js\r\n\r\n/**\r\n *\r\n * Buffered scene graph property that allows weighted accumulation.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\r\n	this.binding = binding;\r\n	this.valueSize = valueSize;\r\n\r\n	var bufferType = Float64Array,\r\n		mixFunction;\r\n\r\n	switch ( typeName ) {\r\n\r\n		case 'quaternion':			mixFunction = this._slerp;		break;\r\n\r\n		case 'string':\r\n		case 'bool':\r\n\r\n			bufferType = Array,		mixFunction = this._select;		break;\r\n\r\n		default:					mixFunction = this._lerp;\r\n\r\n	}\r\n\r\n	this.buffer = new bufferType( valueSize * 4 );\r\n	// layout: [ incoming | accu0 | accu1 | orig ]\r\n	//\r\n	// interpolators can use .buffer as their .result\r\n	// the data then goes to 'incoming'\r\n	//\r\n	// 'accu0' and 'accu1' are used frame-interleaved for\r\n	// the cumulative result and are compared to detect\r\n	// changes\r\n	//\r\n	// 'orig' stores the original state of the property\r\n\r\n	this._mixBufferRegion = mixFunction;\r\n\r\n	this.cumulativeWeight = 0;\r\n\r\n	this.useCount = 0;\r\n	this.referenceCount = 0;\r\n\r\n};\r\n\r\nTHREE.PropertyMixer.prototype = {\r\n\r\n	constructor: THREE.PropertyMixer,\r\n\r\n	// accumulate data in the 'incoming' region into 'accu<i>'\r\n	accumulate: function( accuIndex, weight ) {\r\n\r\n		// note: happily accumulating nothing when weight = 0, the caller knows\r\n		// the weight and shouldn't have made the call in the first place\r\n\r\n		var buffer = this.buffer,\r\n			stride = this.valueSize,\r\n			offset = accuIndex * stride + stride,\r\n\r\n			currentWeight = this.cumulativeWeight;\r\n\r\n		if ( currentWeight === 0 ) {\r\n\r\n			// accuN := incoming * weight\r\n\r\n			for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n				buffer[ offset + i ] = buffer[ i ];\r\n\r\n			}\r\n\r\n			currentWeight = weight;\r\n\r\n		} else {\r\n\r\n			// accuN := accuN + incoming * weight\r\n\r\n			currentWeight += weight;\r\n			var mix = weight / currentWeight;\r\n			this._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n		}\r\n\r\n		this.cumulativeWeight = currentWeight;\r\n\r\n	},\r\n\r\n	// apply the state of 'accu<i>' to the binding when accus differ\r\n	apply: function( accuIndex ) {\r\n\r\n		var stride = this.valueSize,\r\n			buffer = this.buffer,\r\n			offset = accuIndex * stride + stride,\r\n\r\n			weight = this.cumulativeWeight,\r\n\r\n			binding = this.binding;\r\n\r\n		this.cumulativeWeight = 0;\r\n\r\n		if ( weight < 1 ) {\r\n\r\n			// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n			var originalValueOffset = stride * 3;\r\n\r\n			this._mixBufferRegion(\r\n					buffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n		}\r\n\r\n		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n			if ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n				// value has changed -> update scene graph\r\n\r\n				binding.setValue( buffer, offset );\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	// remember the state of the bound property and copy it to both accus\r\n	saveOriginalState: function() {\r\n\r\n		var binding = this.binding;\r\n\r\n		var buffer = this.buffer,\r\n			stride = this.valueSize,\r\n\r\n			originalValueOffset = stride * 3;\r\n\r\n		binding.getValue( buffer, originalValueOffset );\r\n\r\n		// accu[0..1] := orig -- initially detect changes against the original\r\n		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n		}\r\n\r\n		this.cumulativeWeight = 0;\r\n\r\n	},\r\n\r\n	// apply the state previously taken via 'saveOriginalState' to the binding\r\n	restoreOriginalState: function() {\r\n\r\n		var originalValueOffset = this.valueSize * 3;\r\n		this.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n	},\r\n\r\n\r\n	// mix functions\r\n\r\n	_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n		if ( t >= 0.5 ) {\r\n\r\n			for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n		THREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n				buffer, dstOffset, buffer, srcOffset, t );\r\n\r\n	},\r\n\r\n	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n		var s = 1 - t;\r\n\r\n		for ( var i = 0; i !== stride; ++ i ) {\r\n\r\n			var j = dstOffset + i;\r\n\r\n			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of Boolean keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\r\n	THREE.KeyframeTrack.call( this, name, times, values );\r\n\r\n};\r\n\r\nTHREE.BooleanKeyframeTrack.prototype =\r\n		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n	constructor: THREE.BooleanKeyframeTrack,\r\n\r\n	ValueTypeName: 'bool',\r\n	ValueBufferType: Array,\r\n\r\n	DefaultInterpolation: THREE.IntepolateDiscrete,\r\n\r\n	InterpolantFactoryMethodLinear: undefined,\r\n	InterpolantFactoryMethodSmooth: undefined\r\n\r\n	// Note: Actually this track could have a optimized / compressed\r\n	// representation of a single value and a custom interpolant that\r\n	// computes \"firstValue ^ isOdd( index )\".\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of numeric keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n	THREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.NumberKeyframeTrack.prototype =\r\n		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n	constructor: THREE.NumberKeyframeTrack,\r\n\r\n	ValueTypeName: 'number',\r\n\r\n	// ValueBufferType is inherited\r\n\r\n	// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of quaternion keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n	THREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.QuaternionKeyframeTrack.prototype =\r\n		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n	constructor: THREE.QuaternionKeyframeTrack,\r\n\r\n	ValueTypeName: 'quaternion',\r\n\r\n	// ValueBufferType is inherited\r\n\r\n	DefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n	InterpolantFactoryMethodLinear: function( result ) {\r\n\r\n		return new THREE.QuaternionLinearInterpolant(\r\n				this.times, this.values, this.getValueSize(), result );\r\n\r\n	},\r\n\r\n	InterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/StringKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track that interpolates Strings\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n	THREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.StringKeyframeTrack.prototype =\r\n		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n	constructor: THREE.StringKeyframeTrack,\r\n\r\n	ValueTypeName: 'string',\r\n	ValueBufferType: Array,\r\n\r\n	DefaultInterpolation: THREE.IntepolateDiscrete,\r\n\r\n	InterpolantFactoryMethodLinear: undefined,\r\n\r\n	InterpolantFactoryMethodSmooth: undefined\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of vectored keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n	THREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.VectorKeyframeTrack.prototype =\r\n		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n	constructor: THREE.VectorKeyframeTrack,\r\n\r\n	ValueTypeName: 'vector'\r\n\r\n	// ValueBufferType is inherited\r\n\r\n	// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Audio';\r\n\r\n	this.context = listener.context;\r\n	this.source = this.context.createBufferSource();\r\n	this.source.onended = this.onEnded.bind( this );\r\n\r\n	this.gain = this.context.createGain();\r\n	this.gain.connect( listener.getInput() );\r\n\r\n	this.autoplay = false;\r\n\r\n	this.startTime = 0;\r\n	this.playbackRate = 1;\r\n	this.isPlaying = false;\r\n	this.hasPlaybackControl = true;\r\n	this.sourceType = 'empty';\r\n\r\n	this.filter = null;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.getOutput = function () {\r\n\r\n	return this.gain;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n	var buffer = new THREE.AudioBuffer( this.context );\r\n	buffer.load( file );\r\n\r\n	this.setBuffer( buffer );\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setNodeSource = function ( audioNode ) {\r\n\r\n	this.hasPlaybackControl = false;\r\n	this.sourceType = 'audioNode';\r\n	this.source = audioNode;\r\n	this.connect();\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setBuffer = function ( audioBuffer ) {\r\n\r\n	var scope = this;\r\n\r\n	audioBuffer.onReady( function( buffer ) {\r\n\r\n		scope.source.buffer = buffer;\r\n		scope.sourceType = 'buffer';\r\n		if ( scope.autoplay ) scope.play();\r\n\r\n	} );\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		console.warn( 'THREE.Audio: Audio is already playing.' );\r\n		return;\r\n\r\n	}\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return;\r\n\r\n	}\r\n\r\n	var source = this.context.createBufferSource();\r\n\r\n	source.buffer = this.source.buffer;\r\n	source.loop = this.source.loop;\r\n	source.onended = this.source.onended;\r\n	source.start( 0, this.startTime );\r\n	source.playbackRate.value = this.playbackRate;\r\n\r\n	this.isPlaying = true;\r\n\r\n	this.source = source;\r\n\r\n	this.connect();\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return;\r\n\r\n	}\r\n\r\n	this.source.stop();\r\n	this.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return;\r\n\r\n	}\r\n\r\n	this.source.stop();\r\n	this.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.connect = function () {\r\n\r\n	if ( this.filter !== null ) {\r\n\r\n		this.source.connect( this.filter );\r\n		this.filter.connect( this.getOutput() );\r\n\r\n	} else {\r\n\r\n		this.source.connect( this.getOutput() );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.disconnect = function () {\r\n\r\n	if ( this.filter !== null ) {\r\n\r\n		this.source.disconnect( this.filter );\r\n		this.filter.disconnect( this.getOutput() );\r\n\r\n	} else {\r\n\r\n		this.source.disconnect( this.getOutput() );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getFilter = function () {\r\n\r\n	return this.filter;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\r\n	if ( value === undefined ) value = null;\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		this.disconnect();\r\n		this.filter = value;\r\n		this.connect();\r\n\r\n	} else {\r\n\r\n		this.filter = value;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return;\r\n\r\n	}\r\n\r\n	this.playbackRate = value;\r\n\r\n	if ( this.isPlaying === true ) {\r\n\r\n		this.source.playbackRate.value = this.playbackRate;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\r\n	return this.playbackRate;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function() {\r\n\r\n	this.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return;\r\n\r\n	}\r\n\r\n	this.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getLoop = function () {\r\n\r\n	if ( this.hasPlaybackControl === false ) {\r\n\r\n		console.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n		return false;\r\n\r\n	}\r\n\r\n	return this.source.loop;\r\n\r\n};\r\n\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n	this.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getVolume = function () {\r\n\r\n	return this.gain.gain.value;\r\n\r\n};\r\n\r\n// File:src/audio/AudioAnalyser.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\r\n	this.analyser = audio.context.createAnalyser();\r\n	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\r\n	this.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\r\n	audio.getOutput().connect( this.analyser );\r\n\r\n};\r\n\r\nTHREE.AudioAnalyser.prototype = {\r\n\r\n	constructor: THREE.AudioAnalyser,\r\n\r\n	getData: function () {\r\n\r\n		this.analyser.getByteFrequencyData( this.data );\r\n		return this.data;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/audio/AudioBuffer.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioBuffer = function ( context ) {\r\n\r\n	this.context = context;\r\n	this.ready = false;\r\n	this.readyCallbacks = [];\r\n\r\n};\r\n\r\nTHREE.AudioBuffer.prototype.load = function ( file ) {\r\n\r\n	var scope = this;\r\n\r\n	var request = new XMLHttpRequest();\r\n	request.open( 'GET', file, true );\r\n	request.responseType = 'arraybuffer';\r\n	request.onload = function ( e ) {\r\n\r\n		scope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n			scope.buffer = buffer;\r\n			scope.ready = true;\r\n\r\n			for ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {\r\n\r\n				scope.readyCallbacks[ i ]( scope.buffer );\r\n\r\n			}\r\n\r\n			scope.readyCallbacks = [];\r\n\r\n		} );\r\n\r\n	};\r\n	request.send();\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.AudioBuffer.prototype.onReady = function ( callback ) {\r\n\r\n	if ( this.ready ) {\r\n\r\n		callback( this.buffer );\r\n\r\n	} else {\r\n\r\n		this.readyCallbacks.push( callback );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/audio/PositionalAudio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PositionalAudio = function ( listener ) {\r\n\r\n	THREE.Audio.call( this, listener );\r\n\r\n	this.panner = this.context.createPanner();\r\n	this.panner.connect( this.gain );\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );\r\nTHREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;\r\n\r\nTHREE.PositionalAudio.prototype.getOutput = function () {\r\n\r\n	return this.panner;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRefDistance = function ( value ) {\r\n\r\n	this.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRefDistance = function () {\r\n\r\n	return this.panner.refDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n	this.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRolloffFactor = function () {\r\n\r\n	return this.panner.rolloffFactor;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {\r\n\r\n	this.panner.distanceModel = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getDistanceModel = function () {\r\n\r\n	return this.panner.distanceModel;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {\r\n\r\n	this.panner.maxDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getMaxDistance = function () {\r\n\r\n	return this.panner.maxDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n\r\n	return function updateMatrixWorld( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		position.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		this.panner.setPosition( position.x, position.y, position.z );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'AudioListener';\r\n\r\n	this.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n	this.gain = this.context.createGain();\r\n	this.gain.connect( this.context.destination );\r\n\r\n	this.filter = null;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.getInput = function () {\r\n\r\n	return this.gain;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.removeFilter = function ( ) {\r\n\r\n	if ( this.filter !== null ) {\r\n\r\n		this.gain.disconnect( this.filter );\r\n		this.filter.disconnect( this.context.destination );\r\n		this.gain.connect( this.context.destination );\r\n		this.filter = null;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setFilter = function ( value ) {\r\n\r\n	if ( this.filter !== null ) {\r\n\r\n		this.gain.disconnect( this.filter );\r\n		this.filter.disconnect( this.context.destination );\r\n\r\n	} else {\r\n\r\n		this.gain.disconnect( this.context.destination );\r\n\r\n	}\r\n\r\n	this.filter = value;\r\n	this.gain.connect( this.filter );\r\n	this.filter.connect( this.context.destination );\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getFilter = function () {\r\n\r\n	return this.filter;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setMasterVolume = function ( value ) {\r\n\r\n	this.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getMasterVolume = function () {\r\n\r\n	return this.gain.gain.value;\r\n\r\n};\r\n\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3();\r\n\r\n	var orientation = new THREE.Vector3();\r\n\r\n	return function updateMatrixWorld( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		var listener = this.context.listener;\r\n		var up = this.up;\r\n\r\n		this.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n		listener.setPosition( position.x, position.y, position.z );\r\n		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Camera';\r\n\r\n	this.matrixWorldInverse = new THREE.Matrix4();\r\n	this.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n	var quaternion = new THREE.Quaternion();\r\n\r\n	return function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.getWorldQuaternion( quaternion );\r\n\r\n		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n	// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n	var m1 = new THREE.Matrix4();\r\n\r\n	return function ( vector ) {\r\n\r\n		m1.lookAt( this.position, vector, this.up );\r\n\r\n		this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function () {\r\n\r\n	return new this.constructor().copy( this );\r\n\r\n};\r\n\r\nTHREE.Camera.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	this.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n	this.projectionMatrix.copy( source.projectionMatrix );\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *	- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'CubeCamera';\r\n\r\n	var fov = 90, aspect = 1;\r\n\r\n	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPX.up.set( 0, - 1, 0 );\r\n	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n	this.add( cameraPX );\r\n\r\n	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNX.up.set( 0, - 1, 0 );\r\n	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n	this.add( cameraNX );\r\n\r\n	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPY.up.set( 0, 0, 1 );\r\n	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n	this.add( cameraPY );\r\n\r\n	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNY.up.set( 0, 0, - 1 );\r\n	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n	this.add( cameraNY );\r\n\r\n	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPZ.up.set( 0, - 1, 0 );\r\n	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n	this.add( cameraPZ );\r\n\r\n	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNZ.up.set( 0, - 1, 0 );\r\n	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n	this.add( cameraNZ );\r\n\r\n	var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\r\n	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\r\n	this.updateCubeMap = function ( renderer, scene ) {\r\n\r\n		if ( this.parent === null ) this.updateMatrixWorld();\r\n\r\n		var renderTarget = this.renderTarget;\r\n		var generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\r\n		renderTarget.texture.generateMipmaps = false;\r\n\r\n		renderTarget.activeCubeFace = 0;\r\n		renderer.render( scene, cameraPX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 1;\r\n		renderer.render( scene, cameraNX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 2;\r\n		renderer.render( scene, cameraPY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 3;\r\n		renderer.render( scene, cameraNY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 4;\r\n		renderer.render( scene, cameraPZ, renderTarget );\r\n\r\n		renderTarget.texture.generateMipmaps = generateMipmaps;\r\n\r\n		renderTarget.activeCubeFace = 5;\r\n		renderer.render( scene, cameraNZ, renderTarget );\r\n\r\n		renderer.setRenderTarget( null );\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'OrthographicCamera';\r\n\r\n	this.zoom = 1;\r\n\r\n	this.left = left;\r\n	this.right = right;\r\n	this.top = top;\r\n	this.bottom = bottom;\r\n\r\n	this.near = ( near !== undefined ) ? near : 0.1;\r\n	this.far = ( far !== undefined ) ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n	var cx = ( this.right + this.left ) / 2;\r\n	var cy = ( this.top + this.bottom ) / 2;\r\n\r\n	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n\r\n	THREE.Camera.prototype.copy.call( this, source );\r\n\r\n	this.left = source.left;\r\n	this.right = source.right;\r\n	this.top = source.top;\r\n	this.bottom = source.bottom;\r\n	this.near = source.near;\r\n	this.far = source.far;\r\n\r\n	this.zoom = source.zoom;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.zoom = this.zoom;\r\n	data.object.left = this.left;\r\n	data.object.right = this.right;\r\n	data.object.top = this.top;\r\n	data.object.bottom = this.bottom;\r\n	data.object.near = this.near;\r\n	data.object.far = this.far;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'PerspectiveCamera';\r\n\r\n	this.focalLength = 10;\r\n	this.zoom = 1;\r\n\r\n	this.fov = fov !== undefined ? fov : 50;\r\n	this.aspect = aspect !== undefined ? aspect : 1;\r\n	this.near = near !== undefined ? near : 0.1;\r\n	this.far = far !== undefined ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (full-frame) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n	if ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n	this.fullWidth = fullWidth;\r\n	this.fullHeight = fullHeight;\r\n	this.x = x;\r\n	this.y = y;\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n	if ( this.fullWidth ) {\r\n\r\n		var aspect = this.fullWidth / this.fullHeight;\r\n		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n		var bottom = - top;\r\n		var left = aspect * bottom;\r\n		var right = aspect * top;\r\n		var width = Math.abs( right - left );\r\n		var height = Math.abs( top - bottom );\r\n\r\n		this.projectionMatrix.makeFrustum(\r\n			left + this.x * width / this.fullWidth,\r\n			left + ( this.x + this.width ) * width / this.fullWidth,\r\n			top - ( this.y + this.height ) * height / this.fullHeight,\r\n			top - this.y * height / this.fullHeight,\r\n			this.near,\r\n			this.far\r\n		);\r\n\r\n	} else {\r\n\r\n		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.copy = function ( source ) {\r\n\r\n	THREE.Camera.prototype.copy.call( this, source );\r\n\r\n	this.focalLength = source.focalLength;\r\n	this.zoom = source.zoom;\r\n\r\n	this.fov = source.fov;\r\n	this.aspect = source.aspect;\r\n	this.near = source.near;\r\n	this.far = source.far;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.focalLength = this.focalLength;\r\n	data.object.zoom = this.zoom;\r\n\r\n	data.object.fov = this.fov;\r\n	data.object.aspect = this.aspect;\r\n	data.object.near = this.near;\r\n	data.object.far = this.far;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/cameras/StereoCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.StereoCamera = function () {\r\n\r\n	this.type = 'StereoCamera';\r\n\r\n	this.aspect = 1;\r\n\r\n	this.cameraL = new THREE.PerspectiveCamera();\r\n	this.cameraL.layers.enable( 1 );\r\n	this.cameraL.matrixAutoUpdate = false;\r\n\r\n	this.cameraR = new THREE.PerspectiveCamera();\r\n	this.cameraR.layers.enable( 2 );\r\n	this.cameraR.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.StereoCamera.prototype = {\r\n\r\n	constructor: THREE.StereoCamera,\r\n\r\n	update: ( function () {\r\n\r\n		var focalLength, fov, aspect, near, far;\r\n\r\n		var eyeRight = new THREE.Matrix4();\r\n		var eyeLeft = new THREE.Matrix4();\r\n\r\n		return function update ( camera ) {\r\n\r\n			var needsUpdate = focalLength !== camera.focalLength || fov !== camera.fov ||\r\n												aspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n												far !== camera.far;\r\n\r\n			if ( needsUpdate ) {\r\n\r\n				focalLength = camera.focalLength;\r\n				fov = camera.fov;\r\n				aspect = camera.aspect * this.aspect;\r\n				near = camera.near;\r\n				far = camera.far;\r\n\r\n				// Off-axis stereoscopic effect based on\r\n				// http://paulbourke.net/stereographics/stereorender/\r\n\r\n				var projectionMatrix = camera.projectionMatrix.clone();\r\n				var eyeSep = 0.064 / 2;\r\n				var eyeSepOnProjection = eyeSep * near / focalLength;\r\n				var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n				var xmin, xmax;\r\n\r\n				// translate xOffset\r\n\r\n				eyeLeft.elements[ 12 ] = - eyeSep;\r\n				eyeRight.elements[ 12 ] = eyeSep;\r\n\r\n				// for left eye\r\n\r\n				xmin = - ymax * aspect + eyeSepOnProjection;\r\n				xmax = ymax * aspect + eyeSepOnProjection;\r\n\r\n				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n				this.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\r\n				// for right eye\r\n\r\n				xmin = - ymax * aspect - eyeSepOnProjection;\r\n				xmax = ymax * aspect - eyeSepOnProjection;\r\n\r\n				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n				this.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\r\n			}\r\n\r\n			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\r\n		};\r\n\r\n	} )()\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color, intensity ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Light';\r\n\r\n	this.color = new THREE.Color( color );\r\n	this.intensity = intensity !== undefined ? intensity : 1;\r\n\r\n	this.receiveShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.intensity = source.intensity;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Light.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.color = this.color.getHex();\r\n	data.object.intensity = this.intensity;\r\n\r\n	if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\r\n	if ( this.distance !== undefined ) data.object.distance = this.distance;\r\n	if ( this.angle !== undefined ) data.object.angle = this.angle;\r\n	if ( this.decay !== undefined ) data.object.decay = this.decay;\r\n	if ( this.exponent !== undefined ) data.object.exponent = this.exponent;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/lights/LightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LightShadow = function ( camera ) {\r\n\r\n	this.camera = camera;\r\n\r\n	this.bias = 0;\r\n	this.radius = 1;\r\n\r\n	this.mapSize = new THREE.Vector2( 512, 512 );\r\n\r\n	this.map = null;\r\n	this.matrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.LightShadow.prototype = {\r\n\r\n	constructor: THREE.LightShadow,\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.camera = source.camera.clone();\r\n\r\n		this.bias = source.bias;\r\n		this.radius = source.radius;\r\n\r\n		this.mapSize.copy( source.mapSize );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color, intensity ) {\r\n\r\n	THREE.Light.call( this, color, intensity );\r\n\r\n	this.type = 'AmbientLight';\r\n\r\n	this.castShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n	THREE.Light.call( this, color, intensity );\r\n\r\n	this.type = 'DirectionalLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.target = source.target.clone();\r\n\r\n	this.shadow = source.shadow.clone();\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n	THREE.Light.call( this, skyColor, intensity );\r\n\r\n	this.type = 'HemisphereLight';\r\n\r\n	this.castShadow = undefined;\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.groundColor = new THREE.Color( groundColor );\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.groundColor.copy( source.groundColor );\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n	THREE.Light.call( this, color, intensity );\r\n\r\n	this.type = 'PointLight';\r\n\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.\r\n\r\n	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nTHREE.PointLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.distance = source.distance;\r\n	this.decay = source.decay;\r\n\r\n	this.shadow = source.shadow.clone();\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\r\n	THREE.Light.call( this, color, intensity );\r\n\r\n	this.type = 'SpotLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.updateMatrix();\r\n\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n	this.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.\r\n\r\n	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\r\n	THREE.Light.prototype.copy.call( this, source );\r\n\r\n	this.distance = source.distance;\r\n	this.angle = source.angle;\r\n	this.exponent = source.exponent;\r\n	this.decay = source.decay;\r\n\r\n	this.target = source.target.clone();\r\n\r\n	this.shadow = source.shadow.clone();\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n	enabled: false,\r\n\r\n	files: {},\r\n\r\n	add: function ( key, file ) {\r\n\r\n		if ( this.enabled === false ) return;\r\n\r\n		// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n		this.files[ key ] = file;\r\n\r\n	},\r\n\r\n	get: function ( key ) {\r\n\r\n		if ( this.enabled === false ) return;\r\n\r\n		// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n		return this.files[ key ];\r\n\r\n	},\r\n\r\n	remove: function ( key ) {\r\n\r\n		delete this.files[ key ];\r\n\r\n	},\r\n\r\n	clear: function () {\r\n\r\n		this.files = {};\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function () {\r\n\r\n	this.onLoadStart = function () {};\r\n	this.onLoadProgress = function () {};\r\n	this.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n	constructor: THREE.Loader,\r\n\r\n	crossOrigin: undefined,\r\n\r\n	extractUrlBase: function ( url ) {\r\n\r\n		var parts = url.split( '/' );\r\n\r\n		if ( parts.length === 1 ) return './';\r\n\r\n		parts.pop();\r\n\r\n		return parts.join( '/' ) + '/';\r\n\r\n	},\r\n\r\n	initMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\r\n		var array = [];\r\n\r\n		for ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n		}\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	createMaterial: ( function () {\r\n\r\n		var color, textureLoader, materialLoader;\r\n\r\n		return function ( m, texturePath, crossOrigin ) {\r\n\r\n			if ( color === undefined ) color = new THREE.Color();\r\n			if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n			if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\r\n			// convert from old material format\r\n\r\n			var textures = {};\r\n\r\n			function loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\r\n				var fullPath = texturePath + path;\r\n				var loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n				var texture;\r\n\r\n				if ( loader !== null ) {\r\n\r\n					texture = loader.load( fullPath );\r\n\r\n				} else {\r\n\r\n					textureLoader.setCrossOrigin( crossOrigin );\r\n					texture = textureLoader.load( fullPath );\r\n\r\n				}\r\n\r\n				if ( repeat !== undefined ) {\r\n\r\n					texture.repeat.fromArray( repeat );\r\n\r\n					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n				}\r\n\r\n				if ( offset !== undefined ) {\r\n\r\n					texture.offset.fromArray( offset );\r\n\r\n				}\r\n\r\n				if ( wrap !== undefined ) {\r\n\r\n					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\r\n					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\r\n				}\r\n\r\n				if ( anisotropy !== undefined ) {\r\n\r\n					texture.anisotropy = anisotropy;\r\n\r\n				}\r\n\r\n				var uuid = THREE.Math.generateUUID();\r\n\r\n				textures[ uuid ] = texture;\r\n\r\n				return uuid;\r\n\r\n			}\r\n\r\n			//\r\n\r\n			var json = {\r\n				uuid: THREE.Math.generateUUID(),\r\n				type: 'MeshLambertMaterial'\r\n			};\r\n\r\n			for ( var name in m ) {\r\n\r\n				var value = m[ name ];\r\n\r\n				switch ( name ) {\r\n					case 'DbgColor':\r\n					case 'DbgIndex':\r\n					case 'opticalDensity':\r\n					case 'illumination':\r\n						break;\r\n					case 'DbgName':\r\n						json.name = value;\r\n						break;\r\n					case 'blending':\r\n						json.blending = THREE[ value ];\r\n						break;\r\n					case 'colorAmbient':\r\n						console.warn( 'THREE.Loader.createMaterial: colorAmbient is no longer supported' );\r\n						break;\r\n					case 'colorDiffuse':\r\n						json.color = color.fromArray( value ).getHex();\r\n						break;\r\n					case 'colorSpecular':\r\n						json.specular = color.fromArray( value ).getHex();\r\n						break;\r\n					case 'colorEmissive':\r\n						json.emissive = color.fromArray( value ).getHex();\r\n						break;\r\n					case 'specularCoef':\r\n						json.shininess = value;\r\n						break;\r\n					case 'shading':\r\n						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n						break;\r\n					case 'mapDiffuse':\r\n						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n						break;\r\n					case 'mapDiffuseRepeat':\r\n					case 'mapDiffuseOffset':\r\n					case 'mapDiffuseWrap':\r\n					case 'mapDiffuseAnisotropy':\r\n						break;\r\n					case 'mapLight':\r\n						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n						break;\r\n					case 'mapLightRepeat':\r\n					case 'mapLightOffset':\r\n					case 'mapLightWrap':\r\n					case 'mapLightAnisotropy':\r\n						break;\r\n					case 'mapAO':\r\n						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n						break;\r\n					case 'mapAORepeat':\r\n					case 'mapAOOffset':\r\n					case 'mapAOWrap':\r\n					case 'mapAOAnisotropy':\r\n						break;\r\n					case 'mapBump':\r\n						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n						break;\r\n					case 'mapBumpScale':\r\n						json.bumpScale = value;\r\n						break;\r\n					case 'mapBumpRepeat':\r\n					case 'mapBumpOffset':\r\n					case 'mapBumpWrap':\r\n					case 'mapBumpAnisotropy':\r\n						break;\r\n					case 'mapNormal':\r\n						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n						break;\r\n					case 'mapNormalFactor':\r\n						json.normalScale = [ value, value ];\r\n						break;\r\n					case 'mapNormalRepeat':\r\n					case 'mapNormalOffset':\r\n					case 'mapNormalWrap':\r\n					case 'mapNormalAnisotropy':\r\n						break;\r\n					case 'mapSpecular':\r\n						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n						break;\r\n					case 'mapSpecularRepeat':\r\n					case 'mapSpecularOffset':\r\n					case 'mapSpecularWrap':\r\n					case 'mapSpecularAnisotropy':\r\n						break;\r\n					case 'mapAlpha':\r\n						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n						break;\r\n					case 'mapAlphaRepeat':\r\n					case 'mapAlphaOffset':\r\n					case 'mapAlphaWrap':\r\n					case 'mapAlphaAnisotropy':\r\n						break;\r\n					case 'flipSided':\r\n						json.side = THREE.BackSide;\r\n						break;\r\n					case 'doubleSided':\r\n						json.side = THREE.DoubleSide;\r\n						break;\r\n					case 'transparency':\r\n						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n						json.opacity = value;\r\n						break;\r\n					case 'depthTest':\r\n					case 'depthWrite':\r\n					case 'colorWrite':\r\n					case 'opacity':\r\n					case 'reflectivity':\r\n					case 'transparent':\r\n					case 'visible':\r\n					case 'wireframe':\r\n						json[ name ] = value;\r\n						break;\r\n					case 'vertexColors':\r\n						if ( value === true ) json.vertexColors = THREE.VertexColors;\r\n						if ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n						break;\r\n					default:\r\n						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n						break;\r\n				}\r\n\r\n			}\r\n\r\n			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\r\n			if ( json.opacity < 1 ) json.transparent = true;\r\n\r\n			materialLoader.setTextures( textures );\r\n\r\n			return materialLoader.parse( json );\r\n\r\n		};\r\n\r\n	} )()\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n	handlers: [],\r\n\r\n	add: function ( regex, loader ) {\r\n\r\n		this.handlers.push( regex, loader );\r\n\r\n	},\r\n\r\n	get: function ( file ) {\r\n\r\n		var handlers = this.handlers;\r\n\r\n		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\r\n			var regex = handlers[ i ];\r\n			var loader  = handlers[ i + 1 ];\r\n\r\n			if ( regex.test( file ) ) {\r\n\r\n				return loader;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return null;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n	constructor: THREE.XHRLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		if ( this.path !== undefined ) url = this.path + url;\r\n\r\n		var scope = this;\r\n\r\n		var cached = THREE.Cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			if ( onLoad ) {\r\n\r\n				setTimeout( function () {\r\n\r\n					onLoad( cached );\r\n\r\n				}, 0 );\r\n\r\n			}\r\n\r\n			return cached;\r\n\r\n		}\r\n\r\n		var request = new XMLHttpRequest();\r\n		request.overrideMimeType( 'text/plain' );\r\n		request.open( 'GET', url, true );\r\n\r\n		request.addEventListener( 'load', function ( event ) {\r\n\r\n			var response = event.target.response;\r\n\r\n			THREE.Cache.add( url, response );\r\n\r\n			if ( this.status === 200 ) {\r\n\r\n				if ( onLoad ) onLoad( response );\r\n\r\n				scope.manager.itemEnd( url );\r\n\r\n			} else if ( this.status === 0 ) {\r\n\r\n				// Some browsers return HTTP Status 0 when using non-http protocol\r\n				// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\r\n				if ( onLoad ) onLoad( response );\r\n\r\n				scope.manager.itemEnd( url );\r\n\r\n			} else {\r\n\r\n				if ( onError ) onError( event );\r\n\r\n				scope.manager.itemError( url );\r\n\r\n			}\r\n\r\n		}, false );\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			request.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		request.addEventListener( 'error', function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n			scope.manager.itemError( url );\r\n\r\n		}, false );\r\n\r\n		if ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\r\n		request.send( null );\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n		return request;\r\n\r\n	},\r\n\r\n	setPath: function ( value ) {\r\n\r\n		this.path = value;\r\n\r\n	},\r\n\r\n	setResponseType: function ( value ) {\r\n\r\n		this.responseType = value;\r\n\r\n	},\r\n\r\n	setWithCredentials: function ( value ) {\r\n\r\n		this.withCredentials = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/FontLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.FontLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.FontLoader.prototype = {\r\n\r\n	constructor: THREE.FontLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n	constructor: THREE.ImageLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		if ( this.path !== undefined ) url = this.path + url;\r\n\r\n		var scope = this;\r\n\r\n		var cached = THREE.Cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			scope.manager.itemStart( url );\r\n\r\n			if ( onLoad ) {\r\n\r\n				setTimeout( function () {\r\n\r\n					onLoad( cached );\r\n\r\n					scope.manager.itemEnd( url );\r\n\r\n				}, 0 );\r\n\r\n			} else {\r\n\r\n				scope.manager.itemEnd( url );\r\n\r\n			}\r\n\r\n			return cached;\r\n\r\n		}\r\n\r\n		var image = document.createElement( 'img' );\r\n\r\n		image.addEventListener( 'load', function ( event ) {\r\n\r\n			THREE.Cache.add( url, this );\r\n\r\n			if ( onLoad ) onLoad( this );\r\n\r\n			scope.manager.itemEnd( url );\r\n\r\n		}, false );\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			image.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		image.addEventListener( 'error', function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n			scope.manager.itemError( url );\r\n\r\n		}, false );\r\n\r\n		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n		image.src = url;\r\n\r\n		return image;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setPath: function ( value ) {\r\n\r\n		this.path = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( manager ) {\r\n\r\n	if ( typeof manager === 'boolean' ) {\r\n\r\n		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n		manager = undefined;\r\n\r\n	}\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	this.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = {\r\n\r\n	constructor: THREE.JSONLoader,\r\n\r\n	// Deprecated\r\n\r\n	get statusDomElement () {\r\n\r\n		if ( this._statusDomElement === undefined ) {\r\n\r\n			this._statusDomElement = document.createElement( 'div' );\r\n\r\n		}\r\n\r\n		console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n		return this._statusDomElement;\r\n\r\n	},\r\n\r\n	load: function( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setWithCredentials( this.withCredentials );\r\n		loader.load( url, function ( text ) {\r\n\r\n			var json = JSON.parse( text );\r\n			var metadata = json.metadata;\r\n\r\n			if ( metadata !== undefined ) {\r\n\r\n				var type = metadata.type;\r\n\r\n				if ( type !== undefined ) {\r\n\r\n					if ( type.toLowerCase() === 'object' ) {\r\n\r\n						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n						return;\r\n\r\n					}\r\n\r\n					if ( type.toLowerCase() === 'scene' ) {\r\n\r\n						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n						return;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var object = scope.parse( json, texturePath );\r\n			onLoad( object.geometry, object.materials );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setTexturePath: function ( value ) {\r\n\r\n		this.texturePath = value;\r\n\r\n	},\r\n\r\n	parse: function ( json, texturePath ) {\r\n\r\n		var geometry = new THREE.Geometry(),\r\n		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n		parseModel( scale );\r\n\r\n		parseSkin();\r\n		parseMorphing( scale );\r\n		parseAnimations();\r\n\r\n		geometry.computeFaceNormals();\r\n		geometry.computeBoundingSphere();\r\n\r\n		function parseModel( scale ) {\r\n\r\n			function isBitSet( value, position ) {\r\n\r\n				return value & ( 1 << position );\r\n\r\n			}\r\n\r\n			var i, j, fi,\r\n\r\n			offset, zLength,\r\n\r\n		colorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n			type,\r\n			isQuad,\r\n			hasMaterial,\r\n			hasFaceVertexUv,\r\n			hasFaceNormal, hasFaceVertexNormal,\r\n			hasFaceColor, hasFaceVertexColor,\r\n\r\n		vertex, face, faceA, faceB, hex, normal,\r\n\r\n			uvLayer, uv, u, v,\r\n\r\n			faces = json.faces,\r\n			vertices = json.vertices,\r\n			normals = json.normals,\r\n			colors = json.colors,\r\n\r\n			nUvLayers = 0;\r\n\r\n			if ( json.uvs !== undefined ) {\r\n\r\n				// disregard empty arrays\r\n\r\n				for ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n					if ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n				}\r\n\r\n				for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n					geometry.faceVertexUvs[ i ] = [];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			offset = 0;\r\n			zLength = vertices.length;\r\n\r\n			while ( offset < zLength ) {\r\n\r\n				vertex = new THREE.Vector3();\r\n\r\n				vertex.x = vertices[ offset ++ ] * scale;\r\n				vertex.y = vertices[ offset ++ ] * scale;\r\n				vertex.z = vertices[ offset ++ ] * scale;\r\n\r\n				geometry.vertices.push( vertex );\r\n\r\n			}\r\n\r\n			offset = 0;\r\n			zLength = faces.length;\r\n\r\n			while ( offset < zLength ) {\r\n\r\n				type = faces[ offset ++ ];\r\n\r\n\r\n				isQuad              = isBitSet( type, 0 );\r\n				hasMaterial         = isBitSet( type, 1 );\r\n				hasFaceVertexUv     = isBitSet( type, 3 );\r\n				hasFaceNormal       = isBitSet( type, 4 );\r\n				hasFaceVertexNormal = isBitSet( type, 5 );\r\n				hasFaceColor	     = isBitSet( type, 6 );\r\n				hasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n				// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n				if ( isQuad ) {\r\n\r\n					faceA = new THREE.Face3();\r\n					faceA.a = faces[ offset ];\r\n					faceA.b = faces[ offset + 1 ];\r\n					faceA.c = faces[ offset + 3 ];\r\n\r\n					faceB = new THREE.Face3();\r\n					faceB.a = faces[ offset + 1 ];\r\n					faceB.b = faces[ offset + 2 ];\r\n					faceB.c = faces[ offset + 3 ];\r\n\r\n					offset += 4;\r\n\r\n					if ( hasMaterial ) {\r\n\r\n						materialIndex = faces[ offset ++ ];\r\n						faceA.materialIndex = materialIndex;\r\n						faceB.materialIndex = materialIndex;\r\n\r\n					}\r\n\r\n					// to get face <=> uv index correspondence\r\n\r\n					fi = geometry.faces.length;\r\n\r\n					if ( hasFaceVertexUv ) {\r\n\r\n						for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n							uvLayer = json.uvs[ i ];\r\n\r\n							geometry.faceVertexUvs[ i ][ fi ] = [];\r\n							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n							for ( j = 0; j < 4; j ++ ) {\r\n\r\n								uvIndex = faces[ offset ++ ];\r\n\r\n								u = uvLayer[ uvIndex * 2 ];\r\n								v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n								uv = new THREE.Vector2( u, v );\r\n\r\n								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n					if ( hasFaceNormal ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						faceA.normal.set(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n						faceB.normal.copy( faceA.normal );\r\n\r\n					}\r\n\r\n					if ( hasFaceVertexNormal ) {\r\n\r\n						for ( i = 0; i < 4; i ++ ) {\r\n\r\n							normalIndex = faces[ offset ++ ] * 3;\r\n\r\n							normal = new THREE.Vector3(\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ]\r\n							);\r\n\r\n\r\n							if ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n							if ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n						}\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceColor ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						hex = colors[ colorIndex ];\r\n\r\n						faceA.color.setHex( hex );\r\n						faceB.color.setHex( hex );\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceVertexColor ) {\r\n\r\n						for ( i = 0; i < 4; i ++ ) {\r\n\r\n							colorIndex = faces[ offset ++ ];\r\n							hex = colors[ colorIndex ];\r\n\r\n							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					geometry.faces.push( faceA );\r\n					geometry.faces.push( faceB );\r\n\r\n				} else {\r\n\r\n					face = new THREE.Face3();\r\n					face.a = faces[ offset ++ ];\r\n					face.b = faces[ offset ++ ];\r\n					face.c = faces[ offset ++ ];\r\n\r\n					if ( hasMaterial ) {\r\n\r\n						materialIndex = faces[ offset ++ ];\r\n						face.materialIndex = materialIndex;\r\n\r\n					}\r\n\r\n					// to get face <=> uv index correspondence\r\n\r\n					fi = geometry.faces.length;\r\n\r\n					if ( hasFaceVertexUv ) {\r\n\r\n						for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n							uvLayer = json.uvs[ i ];\r\n\r\n							geometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n							for ( j = 0; j < 3; j ++ ) {\r\n\r\n								uvIndex = faces[ offset ++ ];\r\n\r\n								u = uvLayer[ uvIndex * 2 ];\r\n								v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n								uv = new THREE.Vector2( u, v );\r\n\r\n								geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n					if ( hasFaceNormal ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						face.normal.set(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n					}\r\n\r\n					if ( hasFaceVertexNormal ) {\r\n\r\n						for ( i = 0; i < 3; i ++ ) {\r\n\r\n							normalIndex = faces[ offset ++ ] * 3;\r\n\r\n							normal = new THREE.Vector3(\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ++ ],\r\n								normals[ normalIndex ]\r\n							);\r\n\r\n							face.vertexNormals.push( normal );\r\n\r\n						}\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceColor ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						face.color.setHex( colors[ colorIndex ] );\r\n\r\n					}\r\n\r\n\r\n					if ( hasFaceVertexColor ) {\r\n\r\n						for ( i = 0; i < 3; i ++ ) {\r\n\r\n							colorIndex = faces[ offset ++ ];\r\n							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					geometry.faces.push( face );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		};\r\n\r\n		function parseSkin() {\r\n\r\n			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n			if ( json.skinWeights ) {\r\n\r\n				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n					var x =                               json.skinWeights[ i ];\r\n					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( json.skinIndices ) {\r\n\r\n				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n					var a =                               json.skinIndices[ i ];\r\n					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry.bones = json.bones;\r\n\r\n			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n			}\r\n\r\n		};\r\n\r\n		function parseMorphing( scale ) {\r\n\r\n			if ( json.morphTargets !== undefined ) {\r\n\r\n				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n					geometry.morphTargets[ i ] = {};\r\n					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n					geometry.morphTargets[ i ].vertices = [];\r\n\r\n					var dstVertices = geometry.morphTargets[ i ].vertices;\r\n					var srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n						var vertex = new THREE.Vector3();\r\n						vertex.x = srcVertices[ v ] * scale;\r\n						vertex.y = srcVertices[ v + 1 ] * scale;\r\n						vertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n						dstVertices.push( vertex );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\r\n				console.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\r\n				var faces = geometry.faces;\r\n				var morphColors = json.morphColors[ 0 ].colors;\r\n\r\n				for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n					faces[ i ].color.fromArray( morphColors, i * 3 );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function parseAnimations() {\r\n\r\n			var outputAnimations = [];\r\n\r\n			// parse old style Bone/Hierarchy animations\r\n			var animations = [];\r\n\r\n			if ( json.animation !== undefined ) {\r\n\r\n				animations.push( json.animation );\r\n\r\n			}\r\n\r\n			if ( json.animations !== undefined ) {\r\n\r\n				if ( json.animations.length ) {\r\n\r\n					animations = animations.concat( json.animations );\r\n\r\n				} else {\r\n\r\n					animations.push( json.animations );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( var i = 0; i < animations.length; i ++ ) {\r\n\r\n				var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n				if ( clip ) outputAnimations.push( clip );\r\n\r\n			}\r\n\r\n			// parse implicit morph animations\r\n			if ( geometry.morphTargets ) {\r\n\r\n				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n				var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n				outputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\r\n			}\r\n\r\n			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\r\n		};\r\n\r\n		if ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n			return { geometry: geometry };\r\n\r\n		} else {\r\n\r\n			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n			return { geometry: geometry, materials: materials };\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n	var scope = this;\r\n\r\n	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\r\n	this.onStart = undefined;\r\n	this.onLoad = onLoad;\r\n	this.onProgress = onProgress;\r\n	this.onError = onError;\r\n\r\n	this.itemStart = function ( url ) {\r\n\r\n		itemsTotal ++;\r\n\r\n		if ( isLoading === false ) {\r\n\r\n			if ( scope.onStart !== undefined ) {\r\n\r\n				scope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		isLoading = true;\r\n\r\n	};\r\n\r\n	this.itemEnd = function ( url ) {\r\n\r\n		itemsLoaded ++;\r\n\r\n		if ( scope.onProgress !== undefined ) {\r\n\r\n			scope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n		}\r\n\r\n		if ( itemsLoaded === itemsTotal ) {\r\n\r\n			isLoading = false;\r\n\r\n			if ( scope.onLoad !== undefined ) {\r\n\r\n				scope.onLoad();\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.itemError = function ( url ) {\r\n\r\n		if ( scope.onError !== undefined ) {\r\n\r\n			scope.onError( url );\r\n\r\n		}\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n	constructor: THREE.BufferGeometryLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var geometry = new THREE.BufferGeometry();\r\n\r\n		var index = json.data.index;\r\n\r\n		var TYPED_ARRAYS = {\r\n			'Int8Array': Int8Array,\r\n			'Uint8Array': Uint8Array,\r\n			'Uint8ClampedArray': Uint8ClampedArray,\r\n			'Int16Array': Int16Array,\r\n			'Uint16Array': Uint16Array,\r\n			'Int32Array': Int32Array,\r\n			'Uint32Array': Uint32Array,\r\n			'Float32Array': Float32Array,\r\n			'Float64Array': Float64Array\r\n		};\r\n\r\n		if ( index !== undefined ) {\r\n\r\n			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\r\n		}\r\n\r\n		var attributes = json.data.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\r\n			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n		}\r\n\r\n		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n		if ( groups !== undefined ) {\r\n\r\n			for ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n				var group = groups[ i ];\r\n\r\n				geometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var boundingSphere = json.data.boundingSphere;\r\n\r\n		if ( boundingSphere !== undefined ) {\r\n\r\n			var center = new THREE.Vector3();\r\n\r\n			if ( boundingSphere.center !== undefined ) {\r\n\r\n				center.fromArray( boundingSphere.center );\r\n\r\n			}\r\n\r\n			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n	this.textures = {};\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n	constructor: THREE.MaterialLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setTextures: function ( value ) {\r\n\r\n		this.textures = value;\r\n\r\n	},\r\n\r\n	getTexture: function ( name ) {\r\n\r\n		var textures = this.textures;\r\n\r\n		if ( textures[ name ] === undefined ) {\r\n\r\n			console.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\r\n		}\r\n\r\n		return textures[ name ];\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var material = new THREE[ json.type ];\r\n\r\n		if ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n		if ( json.name !== undefined ) material.name = json.name;\r\n		if ( json.color !== undefined ) material.color.setHex( json.color );\r\n		if ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n		if ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n		if ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n		if ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n		if ( json.shading !== undefined ) material.shading = json.shading;\r\n		if ( json.blending !== undefined ) material.blending = json.blending;\r\n		if ( json.side !== undefined ) material.side = json.side;\r\n		if ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n		if ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\r\n		// for PointsMaterial\r\n		if ( json.size !== undefined ) material.size = json.size;\r\n		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n		// maps\r\n\r\n		if ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\r\n		if ( json.alphaMap !== undefined ) {\r\n\r\n			material.alphaMap = this.getTexture( json.alphaMap );\r\n			material.transparent = true;\r\n\r\n		}\r\n\r\n		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\r\n		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n		if ( json.normalScale !== undefined ) {\r\n\r\n			var normalScale = json.normalScale;\r\n\r\n			if ( Array.isArray( normalScale ) === false ) {\r\n\r\n				// Blender exporter used to export a scalar. See #7459\r\n\r\n				normalScale = [ normalScale, normalScale ];\r\n\r\n			}\r\n\r\n			material.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\r\n		}\r\n\r\n		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\r\n		if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n		if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\r\n		if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\r\n		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\r\n		if ( json.envMap !== undefined ) {\r\n\r\n			material.envMap = this.getTexture( json.envMap );\r\n			material.combine = THREE.MultiplyOperation;\r\n\r\n		}\r\n\r\n		if ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\r\n		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\r\n		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\r\n		// MultiMaterial\r\n\r\n		if ( json.materials !== undefined ) {\r\n\r\n			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n				material.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n	this.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n	constructor: THREE.ObjectLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		if ( this.texturePath === '' ) {\r\n\r\n			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n		}\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.load( url, function ( text ) {\r\n\r\n			scope.parse( JSON.parse( text ), onLoad );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setTexturePath: function ( value ) {\r\n\r\n		this.texturePath = value;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json, onLoad ) {\r\n\r\n		var geometries = this.parseGeometries( json.geometries );\r\n\r\n		var images = this.parseImages( json.images, function () {\r\n\r\n			if ( onLoad !== undefined ) onLoad( object );\r\n\r\n		} );\r\n\r\n		var textures  = this.parseTextures( json.textures, images );\r\n		var materials = this.parseMaterials( json.materials, textures );\r\n\r\n		var object = this.parseObject( json.object, geometries, materials );\r\n\r\n		if ( json.animations ) {\r\n\r\n			object.animations = this.parseAnimations( json.animations );\r\n\r\n		}\r\n\r\n		if ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n			if ( onLoad !== undefined ) onLoad( object );\r\n\r\n		}\r\n\r\n		return object;\r\n\r\n	},\r\n\r\n	parseGeometries: function ( json ) {\r\n\r\n		var geometries = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var geometryLoader = new THREE.JSONLoader();\r\n			var bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var geometry;\r\n				var data = json[ i ];\r\n\r\n				switch ( data.type ) {\r\n\r\n					case 'PlaneGeometry':\r\n					case 'PlaneBufferGeometry':\r\n\r\n						geometry = new THREE[ data.type ](\r\n							data.width,\r\n							data.height,\r\n							data.widthSegments,\r\n							data.heightSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BoxGeometry':\r\n					case 'CubeGeometry': // backwards compatible\r\n\r\n						geometry = new THREE.BoxGeometry(\r\n							data.width,\r\n							data.height,\r\n							data.depth,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.depthSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CircleBufferGeometry':\r\n\r\n						geometry = new THREE.CircleBufferGeometry(\r\n							data.radius,\r\n							data.segments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CircleGeometry':\r\n\r\n						geometry = new THREE.CircleGeometry(\r\n							data.radius,\r\n							data.segments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CylinderGeometry':\r\n\r\n						geometry = new THREE.CylinderGeometry(\r\n							data.radiusTop,\r\n							data.radiusBottom,\r\n							data.height,\r\n							data.radialSegments,\r\n							data.heightSegments,\r\n							data.openEnded,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'SphereGeometry':\r\n\r\n						geometry = new THREE.SphereGeometry(\r\n							data.radius,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.phiStart,\r\n							data.phiLength,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'SphereBufferGeometry':\r\n\r\n						geometry = new THREE.SphereBufferGeometry(\r\n							data.radius,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.phiStart,\r\n							data.phiLength,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'DodecahedronGeometry':\r\n\r\n						geometry = new THREE.DodecahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'IcosahedronGeometry':\r\n\r\n						geometry = new THREE.IcosahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'OctahedronGeometry':\r\n\r\n						geometry = new THREE.OctahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TetrahedronGeometry':\r\n\r\n						geometry = new THREE.TetrahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'RingGeometry':\r\n\r\n						geometry = new THREE.RingGeometry(\r\n							data.innerRadius,\r\n							data.outerRadius,\r\n							data.thetaSegments,\r\n							data.phiSegments,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusGeometry':\r\n\r\n						geometry = new THREE.TorusGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.arc\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusKnotGeometry':\r\n\r\n						geometry = new THREE.TorusKnotGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.p,\r\n							data.q,\r\n							data.heightScale\r\n						);\r\n\r\n						break;\r\n\r\n					case 'LatheGeometry':\r\n\r\n						geometry = new THREE.LatheGeometry(\r\n							data.points,\r\n							data.segments,\r\n							data.phiStart,\r\n							data.phiLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BufferGeometry':\r\n\r\n						geometry = bufferGeometryLoader.parse( data );\r\n\r\n						break;\r\n\r\n					case 'Geometry':\r\n\r\n						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\r\n						break;\r\n\r\n					default:\r\n\r\n						console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n						continue;\r\n\r\n				}\r\n\r\n				geometry.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n				geometries[ data.uuid ] = geometry;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometries;\r\n\r\n	},\r\n\r\n	parseMaterials: function ( json, textures ) {\r\n\r\n		var materials = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var loader = new THREE.MaterialLoader();\r\n			loader.setTextures( textures );\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var material = loader.parse( json[ i ] );\r\n				materials[ material.uuid ] = material;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return materials;\r\n\r\n	},\r\n\r\n	parseAnimations: function ( json ) {\r\n\r\n		var animations = [];\r\n\r\n		for ( var i = 0; i < json.length; i ++ ) {\r\n\r\n			var clip = THREE.AnimationClip.parse( json[ i ] );\r\n\r\n			animations.push( clip );\r\n\r\n		}\r\n\r\n		return animations;\r\n\r\n	},\r\n\r\n	parseImages: function ( json, onLoad ) {\r\n\r\n		var scope = this;\r\n		var images = {};\r\n\r\n		function loadImage( url ) {\r\n\r\n			scope.manager.itemStart( url );\r\n\r\n			return loader.load( url, function () {\r\n\r\n				scope.manager.itemEnd( url );\r\n\r\n			} );\r\n\r\n		}\r\n\r\n		if ( json !== undefined && json.length > 0 ) {\r\n\r\n			var manager = new THREE.LoadingManager( onLoad );\r\n\r\n			var loader = new THREE.ImageLoader( manager );\r\n			loader.setCrossOrigin( this.crossOrigin );\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var image = json[ i ];\r\n				var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n				images[ image.uuid ] = loadImage( path );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return images;\r\n\r\n	},\r\n\r\n	parseTextures: function ( json, images ) {\r\n\r\n		function parseConstant( value ) {\r\n\r\n			if ( typeof( value ) === 'number' ) return value;\r\n\r\n			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n			return THREE[ value ];\r\n\r\n		}\r\n\r\n		var textures = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var data = json[ i ];\r\n\r\n				if ( data.image === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n				}\r\n\r\n				if ( images[ data.image ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n				}\r\n\r\n				var texture = new THREE.Texture( images[ data.image ] );\r\n				texture.needsUpdate = true;\r\n\r\n				texture.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) texture.name = data.name;\r\n				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n				if ( Array.isArray( data.wrap ) ) {\r\n\r\n					texture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n					texture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\r\n				}\r\n\r\n				textures[ data.uuid ] = texture;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return textures;\r\n\r\n	},\r\n\r\n	parseObject: function () {\r\n\r\n		var matrix = new THREE.Matrix4();\r\n\r\n		return function ( data, geometries, materials ) {\r\n\r\n			var object;\r\n\r\n			function getGeometry( name ) {\r\n\r\n				if ( geometries[ name ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n				}\r\n\r\n				return geometries[ name ];\r\n\r\n			}\r\n\r\n			function getMaterial( name ) {\r\n\r\n				if ( name === undefined ) return undefined;\r\n\r\n				if ( materials[ name ] === undefined ) {\r\n\r\n					console.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n				}\r\n\r\n				return materials[ name ];\r\n\r\n			}\r\n\r\n			switch ( data.type ) {\r\n\r\n				case 'Scene':\r\n\r\n					object = new THREE.Scene();\r\n\r\n					break;\r\n\r\n				case 'PerspectiveCamera':\r\n\r\n					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'OrthographicCamera':\r\n\r\n					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'AmbientLight':\r\n\r\n					object = new THREE.AmbientLight( data.color, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'DirectionalLight':\r\n\r\n					object = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'PointLight':\r\n\r\n					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n					break;\r\n\r\n				case 'SpotLight':\r\n\r\n					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\r\n					break;\r\n\r\n				case 'HemisphereLight':\r\n\r\n					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'Mesh':\r\n\r\n					var geometry = getGeometry( data.geometry );\r\n					var material = getMaterial( data.material );\r\n\r\n					if ( geometry.bones && geometry.bones.length > 0 ) {\r\n\r\n						object = new THREE.SkinnedMesh( geometry, material );\r\n\r\n					} else {\r\n\r\n						object = new THREE.Mesh( geometry, material );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'LOD':\r\n\r\n					object = new THREE.LOD();\r\n\r\n					break;\r\n\r\n				case 'Line':\r\n\r\n					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n					break;\r\n\r\n				case 'PointCloud':\r\n				case 'Points':\r\n\r\n					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n					break;\r\n\r\n				case 'Sprite':\r\n\r\n					object = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n					break;\r\n\r\n				case 'Group':\r\n\r\n					object = new THREE.Group();\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					object = new THREE.Object3D();\r\n\r\n			}\r\n\r\n			object.uuid = data.uuid;\r\n\r\n			if ( data.name !== undefined ) object.name = data.name;\r\n			if ( data.matrix !== undefined ) {\r\n\r\n				matrix.fromArray( data.matrix );\r\n				matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n			} else {\r\n\r\n				if ( data.position !== undefined ) object.position.fromArray( data.position );\r\n				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n			}\r\n\r\n			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n			if ( data.visible !== undefined ) object.visible = data.visible;\r\n			if ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n			if ( data.children !== undefined ) {\r\n\r\n				for ( var child in data.children ) {\r\n\r\n					object.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( data.type === 'LOD' ) {\r\n\r\n				var levels = data.levels;\r\n\r\n				for ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n					var level = levels[ l ];\r\n					var child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n					if ( child !== undefined ) {\r\n\r\n						object.addLevel( child, level.distance );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return object;\r\n\r\n		}\r\n\r\n	}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n	constructor: THREE.TextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var texture = new THREE.Texture();\r\n\r\n		var loader = new THREE.ImageLoader( this.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.setPath( this.path );\r\n		loader.load( url, function ( image ) {\r\n\r\n			texture.image = image;\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad !== undefined ) {\r\n\r\n				onLoad( texture );\r\n\r\n			}\r\n\r\n		}, onProgress, onError );\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setPath: function ( value ) {\r\n\r\n		this.path = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/CubeTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.CubeTextureLoader.prototype = {\r\n\r\n	constructor: THREE.CubeTextureLoader,\r\n\r\n	load: function ( urls, onLoad, onProgress, onError ) {\r\n\r\n		var texture = new THREE.CubeTexture( [] );\r\n\r\n		var loader = new THREE.ImageLoader( this.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.setPath( this.path );\r\n\r\n		var loaded = 0;\r\n\r\n		function loadTexture( i ) {\r\n\r\n			loader.load( urls[ i ], function ( image ) {\r\n\r\n				texture.images[ i ] = image;\r\n\r\n				loaded ++;\r\n\r\n				if ( loaded === 6 ) {\r\n\r\n					texture.needsUpdate = true;\r\n\r\n					if ( onLoad ) onLoad( texture );\r\n\r\n				}\r\n\r\n			}, undefined, onError );\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < urls.length; ++ i ) {\r\n\r\n			loadTexture( i );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	setPath: function ( value ) {\r\n\r\n		this.path = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n	constructor: THREE.BinaryTextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var texture = new THREE.DataTexture();\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		loader.load( url, function ( buffer ) {\r\n\r\n			var texData = scope._parser( buffer );\r\n\r\n			if ( ! texData ) return;\r\n\r\n			if ( undefined !== texData.image ) {\r\n\r\n				texture.image = texData.image;\r\n\r\n			} else if ( undefined !== texData.data ) {\r\n\r\n				texture.image.width = texData.width;\r\n				texture.image.height = texData.height;\r\n				texture.image.data = texData.data;\r\n\r\n			}\r\n\r\n			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n			if ( undefined !== texData.format ) {\r\n\r\n				texture.format = texData.format;\r\n\r\n			}\r\n			if ( undefined !== texData.type ) {\r\n\r\n				texture.type = texData.type;\r\n\r\n			}\r\n\r\n			if ( undefined !== texData.mipmaps ) {\r\n\r\n				texture.mipmaps = texData.mipmaps;\r\n\r\n			}\r\n\r\n			if ( 1 === texData.mipmapCount ) {\r\n\r\n				texture.minFilter = THREE.LinearFilter;\r\n\r\n			}\r\n\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad ) onLoad( texture, texData );\r\n\r\n		}, onProgress, onError );\r\n\r\n\r\n		return texture;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n	constructor: THREE.CompressedTextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var images = [];\r\n\r\n		var texture = new THREE.CompressedTexture();\r\n		texture.image = images;\r\n\r\n		var loader = new THREE.XHRLoader( this.manager );\r\n		loader.setPath( this.path );\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		function loadTexture( i ) {\r\n\r\n			loader.load( url[ i ], function ( buffer ) {\r\n\r\n				var texDatas = scope._parser( buffer, true );\r\n\r\n				images[ i ] = {\r\n					width: texDatas.width,\r\n					height: texDatas.height,\r\n					format: texDatas.format,\r\n					mipmaps: texDatas.mipmaps\r\n				};\r\n\r\n				loaded += 1;\r\n\r\n				if ( loaded === 6 ) {\r\n\r\n					if ( texDatas.mipmapCount === 1 )\r\n						texture.minFilter = THREE.LinearFilter;\r\n\r\n					texture.format = texDatas.format;\r\n					texture.needsUpdate = true;\r\n\r\n					if ( onLoad ) onLoad( texture );\r\n\r\n				}\r\n\r\n			}, onProgress, onError );\r\n\r\n		}\r\n\r\n		if ( Array.isArray( url ) ) {\r\n\r\n			var loaded = 0;\r\n\r\n			for ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n				loadTexture( i );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// compressed cubemap texture stored in a single DDS file\r\n\r\n			loader.load( url, function ( buffer ) {\r\n\r\n				var texDatas = scope._parser( buffer, true );\r\n\r\n				if ( texDatas.isCubemap ) {\r\n\r\n					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n					for ( var f = 0; f < faces; f ++ ) {\r\n\r\n						images[ f ] = { mipmaps : [] };\r\n\r\n						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n							images[ f ].format = texDatas.format;\r\n							images[ f ].width = texDatas.width;\r\n							images[ f ].height = texDatas.height;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					texture.image.width = texDatas.width;\r\n					texture.image.height = texDatas.height;\r\n					texture.mipmaps = texDatas.mipmaps;\r\n\r\n				}\r\n\r\n				if ( texDatas.mipmapCount === 1 ) {\r\n\r\n					texture.minFilter = THREE.LinearFilter;\r\n\r\n				}\r\n\r\n				texture.format = texDatas.format;\r\n				texture.needsUpdate = true;\r\n\r\n				if ( onLoad ) onLoad( texture );\r\n\r\n			}, onProgress, onError );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	setPath: function ( value ) {\r\n\r\n		this.path = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Material';\r\n\r\n	this.side = THREE.FrontSide;\r\n\r\n	this.opacity = 1;\r\n	this.transparent = false;\r\n\r\n	this.blending = THREE.NormalBlending;\r\n\r\n	this.blendSrc = THREE.SrcAlphaFactor;\r\n	this.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n	this.blendEquation = THREE.AddEquation;\r\n	this.blendSrcAlpha = null;\r\n	this.blendDstAlpha = null;\r\n	this.blendEquationAlpha = null;\r\n\r\n	this.depthFunc = THREE.LessEqualDepth;\r\n	this.depthTest = true;\r\n	this.depthWrite = true;\r\n\r\n	this.colorWrite = true;\r\n\r\n	this.precision = null; // override the renderer's default precision for this material\r\n\r\n	this.polygonOffset = false;\r\n	this.polygonOffsetFactor = 0;\r\n	this.polygonOffsetUnits = 0;\r\n\r\n	this.alphaTest = 0;\r\n\r\n	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n	this.visible = true;\r\n\r\n	this._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n	constructor: THREE.Material,\r\n\r\n	get needsUpdate () {\r\n\r\n		return this._needsUpdate;\r\n\r\n	},\r\n\r\n	set needsUpdate ( value ) {\r\n\r\n		if ( value === true ) this.update();\r\n\r\n		this._needsUpdate = value;\r\n\r\n	},\r\n\r\n	setValues: function ( values ) {\r\n\r\n		if ( values === undefined ) return;\r\n\r\n		for ( var key in values ) {\r\n\r\n			var newValue = values[ key ];\r\n\r\n			if ( newValue === undefined ) {\r\n\r\n				console.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n				continue;\r\n\r\n			}\r\n\r\n			var currentValue = this[ key ];\r\n\r\n			if ( currentValue === undefined ) {\r\n\r\n				console.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n				continue;\r\n\r\n			}\r\n\r\n			if ( currentValue instanceof THREE.Color ) {\r\n\r\n				currentValue.set( newValue );\r\n\r\n			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n				currentValue.copy( newValue );\r\n\r\n			} else if ( key === 'overdraw' ) {\r\n\r\n				// ensure overdraw is backwards-compatible with legacy boolean type\r\n				this[ key ] = Number( newValue );\r\n\r\n			} else {\r\n\r\n				this[ key ] = newValue;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		var isRoot = meta === undefined;\r\n\r\n		if ( isRoot ) {\r\n\r\n			meta = {\r\n				textures: {},\r\n				images: {}\r\n			};\r\n\r\n		}\r\n\r\n		var data = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Material',\r\n				generator: 'Material.toJSON'\r\n			}\r\n		};\r\n\r\n		// standard Material serialization\r\n		data.uuid = this.uuid;\r\n		data.type = this.type;\r\n		if ( this.name !== '' ) data.name = this.name;\r\n\r\n		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\r\n		if ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n		if ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\r\n		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n		if ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\r\n		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n		if ( this.bumpMap instanceof THREE.Texture ) {\r\n\r\n			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n			data.bumpScale = this.bumpScale;\r\n\r\n		}\r\n		if ( this.normalMap instanceof THREE.Texture ) {\r\n\r\n			data.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n			data.normalScale = this.normalScale.toArray();\r\n\r\n		}\r\n		if ( this.displacementMap instanceof THREE.Texture ) {\r\n\r\n			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n			data.displacementScale = this.displacementScale;\r\n			data.displacementBias = this.displacementBias;\r\n\r\n		}\r\n		if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n		if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\r\n		if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\r\n		if ( this.envMap instanceof THREE.Texture ) {\r\n\r\n			data.envMap = this.envMap.toJSON( meta ).uuid;\r\n			data.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n		}\r\n\r\n		if ( this.size !== undefined ) data.size = this.size;\r\n		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\r\n		if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n		if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n		if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n		if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\r\n		if ( this.opacity < 1 ) data.opacity = this.opacity;\r\n		if ( this.transparent === true ) data.transparent = this.transparent;\r\n		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n		if ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n		// TODO: Copied from Object3D.toJSON\r\n\r\n		function extractFromCache ( cache ) {\r\n\r\n			var values = [];\r\n\r\n			for ( var key in cache ) {\r\n\r\n				var data = cache[ key ];\r\n				delete data.metadata;\r\n				values.push( data );\r\n\r\n			}\r\n\r\n			return values;\r\n\r\n		}\r\n\r\n		if ( isRoot ) {\r\n\r\n			var textures = extractFromCache( meta.textures );\r\n			var images = extractFromCache( meta.images );\r\n\r\n			if ( textures.length > 0 ) data.textures = textures;\r\n			if ( images.length > 0 ) data.images = images;\r\n\r\n		}\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.name = source.name;\r\n\r\n		this.side = source.side;\r\n\r\n		this.opacity = source.opacity;\r\n		this.transparent = source.transparent;\r\n\r\n		this.blending = source.blending;\r\n\r\n		this.blendSrc = source.blendSrc;\r\n		this.blendDst = source.blendDst;\r\n		this.blendEquation = source.blendEquation;\r\n		this.blendSrcAlpha = source.blendSrcAlpha;\r\n		this.blendDstAlpha = source.blendDstAlpha;\r\n		this.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n		this.depthFunc = source.depthFunc;\r\n		this.depthTest = source.depthTest;\r\n		this.depthWrite = source.depthWrite;\r\n\r\n		this.colorWrite = source.colorWrite;\r\n\r\n		this.precision = source.precision;\r\n\r\n		this.polygonOffset = source.polygonOffset;\r\n		this.polygonOffsetFactor = source.polygonOffsetFactor;\r\n		this.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n		this.alphaTest = source.alphaTest;\r\n\r\n		this.overdraw = source.overdraw;\r\n\r\n		this.visible = source.visible;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	update: function () {\r\n\r\n		this.dispatchEvent( { type: 'update' } );\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n	this.linecap = 'round';\r\n	this.linejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.linewidth = source.linewidth;\r\n	this.linecap = source.linecap;\r\n	this.linejoin = source.linejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineDashedMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.scale = 1;\r\n	this.dashSize = 3;\r\n	this.gapSize = 1;\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	\r\n	this.linewidth = source.linewidth;\r\n\r\n	this.scale = source.scale;\r\n	this.dashSize = source.dashSize;\r\n	this.gapSize = source.gapSize;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n	this.map = null;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.map = source.map;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshLambertMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n	this.lightMapIntensity = 1.0;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n	this.emissiveIntensity = 1.0;\r\n	this.emissiveMap = null;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.map = source.map;\r\n\r\n	this.lightMap = source.lightMap;\r\n	this.lightMapIntensity = source.lightMapIntensity;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.emissive.copy( source.emissive );\r\n	this.emissiveMap = source.emissiveMap;\r\n	this.emissiveIntensity = source.emissiveIntensity;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshPhongMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.specular = new THREE.Color( 0x111111 );\r\n	this.shininess = 30;\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n	this.lightMapIntensity = 1.0;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n	this.emissiveIntensity = 1.0;\r\n	this.emissiveMap = null;\r\n\r\n	this.bumpMap = null;\r\n	this.bumpScale = 1;\r\n\r\n	this.normalMap = null;\r\n	this.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n	this.displacementMap = null;\r\n	this.displacementScale = 1;\r\n	this.displacementBias = 0;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.specular.copy( source.specular );\r\n	this.shininess = source.shininess;\r\n\r\n	this.map = source.map;\r\n\r\n	this.lightMap = source.lightMap;\r\n	this.lightMapIntensity = source.lightMapIntensity;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.emissive.copy( source.emissive );\r\n	this.emissiveMap = source.emissiveMap;\r\n	this.emissiveIntensity = source.emissiveIntensity;\r\n\r\n	this.bumpMap = source.bumpMap;\r\n	this.bumpScale = source.bumpScale;\r\n\r\n	this.normalMap = source.normalMap;\r\n	this.normalScale.copy( source.normalScale );\r\n\r\n	this.displacementMap = source.displacementMap;\r\n	this.displacementScale = source.displacementScale;\r\n	this.displacementBias = source.displacementBias;\r\n\r\n	this.specularMap = source.specularMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.combine = source.combine;\r\n	this.reflectivity = source.reflectivity;\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshStandardMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  roughness: <float>,\r\n *  metalness: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  roughnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  metalnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  envMapIntensity: <float>\r\n *\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshStandardMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.roughness = 0.5;\r\n	this.metalness = 0.5;\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n	this.lightMapIntensity = 1.0;\r\n\r\n	this.aoMap = null;\r\n	this.aoMapIntensity = 1.0;\r\n\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n	this.emissiveIntensity = 1.0;\r\n	this.emissiveMap = null;\r\n\r\n	this.bumpMap = null;\r\n	this.bumpScale = 1;\r\n\r\n	this.normalMap = null;\r\n	this.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n	this.displacementMap = null;\r\n	this.displacementScale = 1;\r\n	this.displacementBias = 0;\r\n\r\n	this.roughnessMap = null;\r\n\r\n	this.metalnessMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.envMapIntensity = 1.0;\r\n\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\r\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.roughness = source.roughness;\r\n	this.metalness = source.metalness;\r\n\r\n	this.map = source.map;\r\n\r\n	this.lightMap = source.lightMap;\r\n	this.lightMapIntensity = source.lightMapIntensity;\r\n\r\n	this.aoMap = source.aoMap;\r\n	this.aoMapIntensity = source.aoMapIntensity;\r\n\r\n	this.emissive.copy( source.emissive );\r\n	this.emissiveMap = source.emissiveMap;\r\n	this.emissiveIntensity = source.emissiveIntensity;\r\n\r\n	this.bumpMap = source.bumpMap;\r\n	this.bumpScale = source.bumpScale;\r\n\r\n	this.normalMap = source.normalMap;\r\n	this.normalScale.copy( source.normalScale );\r\n\r\n	this.displacementMap = source.displacementMap;\r\n	this.displacementScale = source.displacementScale;\r\n	this.displacementBias = source.displacementBias;\r\n\r\n	this.roughnessMap = source.roughnessMap;\r\n\r\n	this.metalnessMap = source.metalnessMap;\r\n\r\n	this.alphaMap = source.alphaMap;\r\n\r\n	this.envMap = source.envMap;\r\n	this.envMapIntensity = source.envMapIntensity;\r\n\r\n	this.refractionRatio = source.refractionRatio;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n	this.wireframeLinecap = source.wireframeLinecap;\r\n	this.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshDepthMaterial';\r\n\r\n	this.morphTargets = false;\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this, parameters );\r\n\r\n	this.type = 'MeshNormalMaterial';\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/MultiMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MultiMaterial = function ( materials ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.type = 'MultiMaterial';\r\n\r\n	this.materials = materials instanceof Array ? materials : [];\r\n\r\n	this.visible = true;\r\n\r\n};\r\n\r\nTHREE.MultiMaterial.prototype = {\r\n\r\n	constructor: THREE.MultiMaterial,\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.2,\r\n				type: 'material',\r\n				generator: 'MaterialExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type,\r\n			materials: []\r\n		};\r\n\r\n		var materials = this.materials;\r\n\r\n		for ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n			var material = materials[ i ].toJSON( meta );\r\n			delete material.metadata;\r\n\r\n			output.materials.push( material );\r\n\r\n		}\r\n\r\n		output.visible = this.visible;\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var material = new this.constructor();\r\n\r\n		for ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n			material.materials.push( this.materials[ i ].clone() );\r\n\r\n		}\r\n\r\n		material.visible = this.visible;\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/materials/PointsMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointsMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'PointsMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.map = null;\r\n\r\n	this.size = 1;\r\n	this.sizeAttenuation = true;\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\r\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n\r\n	this.map = source.map;\r\n\r\n	this.size = source.size;\r\n	this.sizeAttenuation = source.sizeAttenuation;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'ShaderMaterial';\r\n\r\n	this.defines = {};\r\n	this.uniforms = {};\r\n\r\n	this.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n	this.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.fog = false; // set to use scene fog\r\n\r\n	this.lights = false; // set to use scene lights\r\n\r\n	this.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n	this.skinning = false; // set to use skinning attribute streams\r\n\r\n	this.morphTargets = false; // set to use morph targets\r\n	this.morphNormals = false; // set to use morph normals\r\n\r\n	this.extensions = {\r\n		derivatives: false, // set to use derivatives\r\n		fragDepth: false, // set to use fragment depth values\r\n		drawBuffers: false, // set to use draw buffers\r\n		shaderTextureLOD: false // set to use shader texture LOD\r\n	};\r\n\r\n	// When rendered geometry doesn't include these attributes but the material does,\r\n	// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n	this.defaultAttributeValues = {\r\n		'color': [ 1, 1, 1 ],\r\n		'uv': [ 0, 0 ],\r\n		'uv2': [ 0, 0 ]\r\n	};\r\n\r\n	this.index0AttributeName = undefined;\r\n\r\n	if ( parameters !== undefined ) {\r\n\r\n		if ( parameters.attributes !== undefined ) {\r\n\r\n			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n		}\r\n\r\n		this.setValues( parameters );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.fragmentShader = source.fragmentShader;\r\n	this.vertexShader = source.vertexShader;\r\n\r\n	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\r\n	this.defines = source.defines;\r\n\r\n	this.shading = source.shading;\r\n\r\n	this.wireframe = source.wireframe;\r\n	this.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n	this.fog = source.fog;\r\n\r\n	this.lights = source.lights;\r\n\r\n	this.vertexColors = source.vertexColors;\r\n\r\n	this.skinning = source.skinning;\r\n\r\n	this.morphTargets = source.morphTargets;\r\n	this.morphNormals = source.morphNormals;\r\n\r\n	this.extensions = source.extensions;\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\r\n	data.uniforms = this.uniforms;\r\n	data.vertexShader = this.vertexShader;\r\n	data.fragmentShader = this.fragmentShader;\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.ShaderMaterial.call( this, parameters );\r\n\r\n	this.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *	uvOffset: new THREE.Vector2(),\r\n *	uvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'SpriteMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n	this.map = null;\r\n\r\n	this.rotation = 0;\r\n\r\n	this.fog = false;\r\n\r\n	// set parameters\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n	THREE.Material.prototype.copy.call( this, source );\r\n\r\n	this.color.copy( source.color );\r\n	this.map = source.map;\r\n\r\n	this.rotation = source.rotation;\r\n\r\n	this.fog = source.fog;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.sourceFile = '';\r\n\r\n	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n	this.mipmaps = [];\r\n\r\n	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n	this.format = format !== undefined ? format : THREE.RGBAFormat;\r\n	this.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n	this.offset = new THREE.Vector2( 0, 0 );\r\n	this.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n	this.generateMipmaps = true;\r\n	this.premultiplyAlpha = false;\r\n	this.flipY = true;\r\n	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n	this.version = 0;\r\n	this.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n	constructor: THREE.Texture,\r\n\r\n	set needsUpdate ( value ) {\r\n\r\n		if ( value === true ) this.version ++;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.image = source.image;\r\n		this.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n		this.mapping = source.mapping;\r\n\r\n		this.wrapS = source.wrapS;\r\n		this.wrapT = source.wrapT;\r\n\r\n		this.magFilter = source.magFilter;\r\n		this.minFilter = source.minFilter;\r\n\r\n		this.anisotropy = source.anisotropy;\r\n\r\n		this.format = source.format;\r\n		this.type = source.type;\r\n\r\n		this.offset.copy( source.offset );\r\n		this.repeat.copy( source.repeat );\r\n\r\n		this.generateMipmaps = source.generateMipmaps;\r\n		this.premultiplyAlpha = source.premultiplyAlpha;\r\n		this.flipY = source.flipY;\r\n		this.unpackAlignment = source.unpackAlignment;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toJSON: function ( meta ) {\r\n\r\n		if ( meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n			return meta.textures[ this.uuid ];\r\n\r\n		}\r\n\r\n		function getDataURL( image ) {\r\n\r\n			var canvas;\r\n\r\n			if ( image.toDataURL !== undefined ) {\r\n\r\n				canvas = image;\r\n\r\n			} else {\r\n\r\n				canvas = document.createElement( 'canvas' );\r\n				canvas.width = image.width;\r\n				canvas.height = image.height;\r\n\r\n				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\r\n			}\r\n\r\n			if ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n				return canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n			} else {\r\n\r\n				return canvas.toDataURL( 'image/png' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.4,\r\n				type: 'Texture',\r\n				generator: 'Texture.toJSON'\r\n			},\r\n\r\n			uuid: this.uuid,\r\n			name: this.name,\r\n\r\n			mapping: this.mapping,\r\n\r\n			repeat: [ this.repeat.x, this.repeat.y ],\r\n			offset: [ this.offset.x, this.offset.y ],\r\n			wrap: [ this.wrapS, this.wrapT ],\r\n\r\n			minFilter: this.minFilter,\r\n			magFilter: this.magFilter,\r\n			anisotropy: this.anisotropy\r\n		};\r\n\r\n		if ( this.image !== undefined ) {\r\n\r\n			// TODO: Move to THREE.Image\r\n\r\n			var image = this.image;\r\n\r\n			if ( image.uuid === undefined ) {\r\n\r\n				image.uuid = THREE.Math.generateUUID(); // UGH\r\n\r\n			}\r\n\r\n			if ( meta.images[ image.uuid ] === undefined ) {\r\n\r\n				meta.images[ image.uuid ] = {\r\n					uuid: image.uuid,\r\n					url: getDataURL( image )\r\n				};\r\n\r\n			}\r\n\r\n			output.image = image.uuid;\r\n\r\n		}\r\n\r\n		meta.textures[ this.uuid ] = output;\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	},\r\n\r\n	transformUv: function ( uv ) {\r\n\r\n		if ( this.mapping !== THREE.UVMapping )  return;\r\n\r\n		uv.multiply( this.repeat );\r\n		uv.add( this.offset );\r\n\r\n		if ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n			switch ( this.wrapS ) {\r\n\r\n				case THREE.RepeatWrapping:\r\n\r\n					uv.x = uv.x - Math.floor( uv.x );\r\n					break;\r\n\r\n				case THREE.ClampToEdgeWrapping:\r\n\r\n					uv.x = uv.x < 0 ? 0 : 1;\r\n					break;\r\n\r\n				case THREE.MirroredRepeatWrapping:\r\n\r\n					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n						uv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n					} else {\r\n\r\n						uv.x = uv.x - Math.floor( uv.x );\r\n\r\n					}\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n			switch ( this.wrapT ) {\r\n\r\n				case THREE.RepeatWrapping:\r\n\r\n					uv.y = uv.y - Math.floor( uv.y );\r\n					break;\r\n\r\n				case THREE.ClampToEdgeWrapping:\r\n\r\n					uv.y = uv.y < 0 ? 0 : 1;\r\n					break;\r\n\r\n				case THREE.MirroredRepeatWrapping:\r\n\r\n					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n						uv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n					} else {\r\n\r\n						uv.y = uv.y - Math.floor( uv.y );\r\n\r\n					}\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.flipY ) {\r\n\r\n			uv.y = 1 - uv.y;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CanvasTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\r\n	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.images = images;\r\n	this.flipY = false;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nTHREE.CubeTexture.prototype.copy = function ( source ) {\r\n\r\n	THREE.Texture.prototype.copy.call( this, source );\r\n\r\n	this.images = source.images;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { width: width, height: height };\r\n	this.mipmaps = mipmaps;\r\n\r\n	// no flipping for cube textures\r\n	// (also flipping doesn't work for compressed textures )\r\n\r\n	this.flipY = false;\r\n\r\n	// can't generate mipmaps for compressed textures\r\n	// mips must be embedded in DDS files\r\n\r\n	this.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { data: data, width: width, height: height };\r\n\r\n	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n	\r\n	this.flipY = false;\r\n	this.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.generateMipmaps = false;\r\n\r\n	var scope = this;\r\n\r\n	function update() {\r\n\r\n		requestAnimationFrame( update );\r\n\r\n		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n			scope.needsUpdate = true;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	update();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n// File:src/objects/Points.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Points = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Points';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Points.prototype.constructor = THREE.Points;\r\n\r\nTHREE.Points.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var object = this;\r\n		var geometry = this.geometry;\r\n		var matrixWorld = this.matrixWorld;\r\n		var threshold = raycaster.params.Points.threshold;\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( matrixWorld );\r\n\r\n		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n		//\r\n\r\n		inverseMatrix.getInverse( matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n		var localThresholdSq = localThreshold * localThreshold;\r\n		var position = new THREE.Vector3();\r\n\r\n		function testPoint( point, index ) {\r\n\r\n			var rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n			if ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n				var intersectPoint = ray.closestPointToPoint( point );\r\n				intersectPoint.applyMatrix4( matrixWorld );\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					distanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n					point: intersectPoint.clone(),\r\n					index: index,\r\n					face: null,\r\n					object: object\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n			var positions = attributes.position.array;\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n\r\n				for ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n					var a = indices[ i ];\r\n\r\n					position.fromArray( positions, a * 3 );\r\n\r\n					testPoint( position, a );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n					position.fromArray( positions, i * 3 );\r\n\r\n					testPoint( position, i );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			var vertices = geometry.vertices;\r\n\r\n			for ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n				testPoint( vertices[ i ], i );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Points.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n	if ( mode === 1 ) {\r\n\r\n		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n		return new THREE.LineSegments( geometry, material );\r\n\r\n	}\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Line';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var precision = raycaster.linePrecision;\r\n		var precisionSq = precision * precision;\r\n\r\n		var geometry = this.geometry;\r\n		var matrixWorld = this.matrixWorld;\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( matrixWorld );\r\n\r\n		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n		//\r\n\r\n		inverseMatrix.getInverse( matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		var vStart = new THREE.Vector3();\r\n		var vEnd = new THREE.Vector3();\r\n		var interSegment = new THREE.Vector3();\r\n		var interRay = new THREE.Vector3();\r\n		var step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n			var positions = attributes.position.array;\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n\r\n				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n					var a = indices[ i ];\r\n					var b = indices[ i + 1 ];\r\n\r\n					vStart.fromArray( positions, a * 3 );\r\n					vEnd.fromArray( positions, b * 3 );\r\n\r\n					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n					if ( distSq > precisionSq ) continue;\r\n\r\n					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						// What do we want? intersection point on the ray or on the segment??\r\n						// point: raycaster.ray.at( distance ),\r\n						point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n						index: i,\r\n						face: null,\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n					vStart.fromArray( positions, 3 * i );\r\n					vEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n					if ( distSq > precisionSq ) continue;\r\n\r\n					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						// What do we want? intersection point on the ray or on the segment??\r\n						// point: raycaster.ray.at( distance ),\r\n						point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n						index: i,\r\n						face: null,\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var vertices = geometry.vertices;\r\n			var nbVertices = vertices.length;\r\n\r\n			for ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n				if ( distSq > precisionSq ) continue;\r\n\r\n				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					// What do we want? intersection point on the ray or on the segment??\r\n					// point: raycaster.ray.at( distance ),\r\n					point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n					index: i,\r\n					face: null,\r\n					faceIndex: null,\r\n					object: this\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// DEPRECATED\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\n// File:src/objects/LineSegments.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LineSegments = function ( geometry, material ) {\r\n\r\n	THREE.Line.call( this, geometry, material );\r\n\r\n	this.type = 'LineSegments';\r\n\r\n};\r\n\r\nTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Mesh';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n	this.drawMode = THREE.TrianglesDrawMode;\r\n\r\n	this.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.setDrawMode = function ( value ) {\r\n\r\n	this.drawMode = value;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n		this.morphTargetBase = - 1;\r\n		this.morphTargetInfluences = [];\r\n		this.morphTargetDictionary = {};\r\n\r\n		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n			this.morphTargetInfluences.push( 0 );\r\n			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n	if ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n		return this.morphTargetDictionary[ name ];\r\n\r\n	}\r\n\r\n	console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n	return 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	var vA = new THREE.Vector3();\r\n	var vB = new THREE.Vector3();\r\n	var vC = new THREE.Vector3();\r\n\r\n	var tempA = new THREE.Vector3();\r\n	var tempB = new THREE.Vector3();\r\n	var tempC = new THREE.Vector3();\r\n\r\n	var uvA = new THREE.Vector2();\r\n	var uvB = new THREE.Vector2();\r\n	var uvC = new THREE.Vector2();\r\n\r\n	var barycoord = new THREE.Vector3();\r\n\r\n	var intersectionPoint = new THREE.Vector3();\r\n	var intersectionPointWorld = new THREE.Vector3();\r\n\r\n	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\r\n		THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\r\n		uv1.multiplyScalar( barycoord.x );\r\n		uv2.multiplyScalar( barycoord.y );\r\n		uv3.multiplyScalar( barycoord.z );\r\n\r\n		uv1.add( uv2 ).add( uv3 );\r\n\r\n		return uv1.clone();\r\n\r\n	}\r\n\r\n	function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n		var intersect;\r\n		var material = object.material;\r\n\r\n		if ( material.side === THREE.BackSide ) {\r\n\r\n			intersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n		} else {\r\n\r\n			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\r\n		}\r\n\r\n		if ( intersect === null ) return null;\r\n\r\n		intersectionPointWorld.copy( point );\r\n		intersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n		var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n		if ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n		return {\r\n			distance: distance,\r\n			point: intersectionPointWorld.clone(),\r\n			object: object\r\n		};\r\n\r\n	}\r\n\r\n	function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\r\n		vA.fromArray( positions, a * 3 );\r\n		vB.fromArray( positions, b * 3 );\r\n		vC.fromArray( positions, c * 3 );\r\n\r\n		var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n		if ( intersection ) {\r\n\r\n			if ( uvs ) {\r\n\r\n				uvA.fromArray( uvs, a * 2 );\r\n				uvB.fromArray( uvs, b * 2 );\r\n				uvC.fromArray( uvs, c * 2 );\r\n\r\n				intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\r\n			}\r\n\r\n			intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n			intersection.faceIndex = a;\r\n\r\n		}\r\n\r\n		return intersection;\r\n\r\n	}\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		var geometry = this.geometry;\r\n		var material = this.material;\r\n		var matrixWorld = this.matrixWorld;\r\n\r\n		if ( material === undefined ) return;\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( matrixWorld );\r\n\r\n		if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n		//\r\n\r\n		inverseMatrix.getInverse( matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		// Check boundingBox before continuing\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\r\n		}\r\n\r\n		var uvs, intersection;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var a, b, c;\r\n			var index = geometry.index;\r\n			var attributes = geometry.attributes;\r\n			var positions = attributes.position.array;\r\n\r\n			if ( attributes.uv !== undefined ) {\r\n\r\n				uvs = attributes.uv.array;\r\n\r\n			}\r\n\r\n			if ( index !== null ) {\r\n\r\n				var indices = index.array;\r\n\r\n				for ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n					a = indices[ i ];\r\n					b = indices[ i + 1 ];\r\n					c = indices[ i + 2 ];\r\n\r\n					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n					if ( intersection ) {\r\n\r\n						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n						intersects.push( intersection );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n\r\n				for ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\r\n					a = i / 3;\r\n					b = a + 1;\r\n					c = a + 2;\r\n\r\n					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n					if ( intersection ) {\r\n\r\n						intersection.index = a; // triangle number in positions buffer semantics\r\n						intersects.push( intersection );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var fvA, fvB, fvC;\r\n			var isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n			var materials = isFaceMaterial === true ? material.materials : null;\r\n\r\n			var vertices = geometry.vertices;\r\n			var faces = geometry.faces;\r\n			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\r\n			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n				var face = faces[ f ];\r\n				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\r\n				if ( faceMaterial === undefined ) continue;\r\n\r\n				fvA = vertices[ face.a ];\r\n				fvB = vertices[ face.b ];\r\n				fvC = vertices[ face.c ];\r\n\r\n				if ( faceMaterial.morphTargets === true ) {\r\n\r\n					var morphTargets = geometry.morphTargets;\r\n					var morphInfluences = this.morphTargetInfluences;\r\n\r\n					vA.set( 0, 0, 0 );\r\n					vB.set( 0, 0, 0 );\r\n					vC.set( 0, 0, 0 );\r\n\r\n					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n						var influence = morphInfluences[ t ];\r\n\r\n						if ( influence === 0 ) continue;\r\n\r\n						var targets = morphTargets[ t ].vertices;\r\n\r\n						vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n						vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n						vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\r\n					}\r\n\r\n					vA.add( fvA );\r\n					vB.add( fvB );\r\n					vC.add( fvC );\r\n\r\n					fvA = vA;\r\n					fvB = vB;\r\n					fvC = vC;\r\n\r\n				}\r\n\r\n				intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\r\n				if ( intersection ) {\r\n\r\n					if ( uvs ) {\r\n\r\n						var uvs_f = uvs[ f ];\r\n						uvA.copy( uvs_f[ 0 ] );\r\n						uvB.copy( uvs_f[ 1 ] );\r\n						uvC.copy( uvs_f[ 2 ] );\r\n\r\n						intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\r\n					}\r\n\r\n					intersection.face = face;\r\n					intersection.faceIndex = f;\r\n					intersects.push( intersection );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Bone';\r\n\r\n	this.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\nTHREE.Bone.prototype.copy = function ( source ) {\r\n	\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n	\r\n	this.skin = source.skin;\r\n	\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n	this.identityMatrix = new THREE.Matrix4();\r\n\r\n	// copy the bone array\r\n\r\n	bones = bones || [];\r\n\r\n	this.bones = bones.slice( 0 );\r\n\r\n	// create a bone texture or an array of floats\r\n\r\n	if ( this.useVertexTexture ) {\r\n\r\n		// layout (1 matrix = 4 pixels)\r\n		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n		\r\n		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n		size = Math.max( size, 4 );\r\n\r\n		this.boneTextureWidth = size;\r\n		this.boneTextureHeight = size;\r\n\r\n		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\r\n	} else {\r\n\r\n		this.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n	}\r\n\r\n	// use the supplied bone inverses or calculate the inverses\r\n\r\n	if ( boneInverses === undefined ) {\r\n\r\n		this.calculateInverses();\r\n\r\n	} else {\r\n\r\n		if ( this.bones.length === boneInverses.length ) {\r\n\r\n			this.boneInverses = boneInverses.slice( 0 );\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n			this.boneInverses = [];\r\n\r\n			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n				this.boneInverses.push( new THREE.Matrix4() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n	this.boneInverses = [];\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		var inverse = new THREE.Matrix4();\r\n\r\n		if ( this.bones[ b ] ) {\r\n\r\n			inverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n		}\r\n\r\n		this.boneInverses.push( inverse );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n	var bone;\r\n\r\n	// recover the bind-time world matrices\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			bone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// compute the local matrices, positions, rotations and scales\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			if ( bone.parent ) {\r\n\r\n				bone.matrix.getInverse( bone.parent.matrixWorld );\r\n				bone.matrix.multiply( bone.matrixWorld );\r\n\r\n			} else {\r\n\r\n				bone.matrix.copy( bone.matrixWorld );\r\n\r\n			}\r\n\r\n			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n	var offsetMatrix = new THREE.Matrix4();\r\n\r\n	return function update() {\r\n\r\n		// flatten bone matrices to array\r\n\r\n		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n			// compute the offset between the current and the original transform\r\n\r\n			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n		}\r\n\r\n		if ( this.useVertexTexture ) {\r\n\r\n			this.boneTexture.needsUpdate = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n} )();\r\n\r\nTHREE.Skeleton.prototype.clone = function () {\r\n\r\n	return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\r\n};\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.type = 'SkinnedMesh';\r\n\r\n	this.bindMode = \"attached\";\r\n	this.bindMatrix = new THREE.Matrix4();\r\n	this.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n	// init bones\r\n\r\n	// TODO: remove bone creation as there is no reason (other than\r\n	// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n	var bones = [];\r\n\r\n	if ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n		var bone, gbone;\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			bone = new THREE.Bone( this );\r\n			bones.push( bone );\r\n\r\n			bone.name = gbone.name;\r\n			bone.position.fromArray( gbone.pos );\r\n			bone.quaternion.fromArray( gbone.rotq );\r\n			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\r\n		}\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			if ( gbone.parent !== - 1 && gbone.parent !== null ) {\r\n\r\n				bones[ gbone.parent ].add( bones[ b ] );\r\n\r\n			} else {\r\n\r\n				this.add( bones[ b ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.normalizeSkinWeights();\r\n\r\n	this.updateMatrixWorld( true );\r\n	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n	this.skeleton = skeleton;\r\n\r\n	if ( bindMatrix === undefined ) {\r\n\r\n		this.updateMatrixWorld( true );\r\n\r\n		this.skeleton.calculateInverses();\r\n\r\n		bindMatrix = this.matrixWorld;\r\n\r\n	}\r\n\r\n	this.bindMatrix.copy( bindMatrix );\r\n	this.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n	this.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n	if ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n		for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\r\n			var sw = this.geometry.skinWeights[ i ];\r\n\r\n			var scale = 1.0 / sw.lengthManhattan();\r\n\r\n			if ( scale !== Infinity ) {\r\n\r\n				sw.multiplyScalar( scale );\r\n\r\n			} else {\r\n\r\n				sw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n			}\r\n\r\n		}\r\n\r\n	} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		var vec = new THREE.Vector4();\r\n\r\n		var skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n		for ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\r\n			vec.x = skinWeight.getX( i );\r\n			vec.y = skinWeight.getY( i );\r\n			vec.z = skinWeight.getZ( i );\r\n			vec.w = skinWeight.getW( i );\r\n\r\n			var scale = 1.0 / vec.lengthManhattan();\r\n\r\n			if ( scale !== Infinity ) {\r\n\r\n				vec.multiplyScalar( scale );\r\n\r\n			} else {\r\n\r\n				vec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n			}\r\n\r\n			skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n	if ( this.bindMode === \"attached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n	} else if ( this.bindMode === \"detached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function() {\r\n\r\n	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'LOD';\r\n\r\n	Object.defineProperties( this, {\r\n		levels: {\r\n			enumerable: true,\r\n			value: []\r\n		},\r\n		objects: {\r\n			get: function () {\r\n\r\n				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n				return this.levels;\r\n\r\n			}\r\n		}\r\n	} );\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n	if ( distance === undefined ) distance = 0;\r\n\r\n	distance = Math.abs( distance );\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n		if ( distance < levels[ l ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	levels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n	this.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n		if ( distance < levels[ i ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return levels[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n		this.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function update( camera ) {\r\n\r\n		var levels = this.levels;\r\n\r\n		if ( levels.length > 1 ) {\r\n\r\n			v1.setFromMatrixPosition( camera.matrixWorld );\r\n			v2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n			var distance = v1.distanceTo( v2 );\r\n\r\n			levels[ 0 ].object.visible = true;\r\n\r\n			for ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n				if ( distance >= levels[ i ].distance ) {\r\n\r\n					levels[ i - 1 ].object.visible = false;\r\n					levels[ i ].object.visible = true;\r\n\r\n				} else {\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( ; i < l; i ++ ) {\r\n\r\n				levels[ i ].object.visible = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source, false );\r\n\r\n	var levels = source.levels;\r\n\r\n	for ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n		var level = levels[ i ];\r\n\r\n		this.addLevel( level.object.clone(), level.distance );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\r\n	var data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n	data.object.levels = [];\r\n\r\n	var levels = this.levels;\r\n\r\n	for ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n		var level = levels[ i ];\r\n\r\n		data.object.levels.push( {\r\n			object: level.object.uuid,\r\n			distance: level.distance\r\n		} );\r\n\r\n	}\r\n\r\n	return data;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n	return function Sprite( material ) {\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		this.type = 'Sprite';\r\n\r\n		this.geometry = geometry;\r\n		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n	};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function raycast( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n		var guessSizeSq = this.scale.x * this.scale.y;\r\n\r\n		if ( distanceSq > guessSizeSq ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		intersects.push( {\r\n\r\n			distance: Math.sqrt( distanceSq ),\r\n			point: this.position,\r\n			face: null,\r\n			object: this\r\n\r\n		} );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function () {\r\n\r\n	return new this.constructor( this.material ).copy( this );\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.lensFlares = [];\r\n\r\n	this.positionScreen = new THREE.Vector3();\r\n	this.customUpdateCallback = undefined;\r\n\r\n	if ( texture !== undefined ) {\r\n\r\n		this.add( texture, size, distance, blending, color );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n	if ( size === undefined ) size = - 1;\r\n	if ( distance === undefined ) distance = 0;\r\n	if ( opacity === undefined ) opacity = 1;\r\n	if ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n	if ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n	distance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n	this.lensFlares.push( {\r\n		texture: texture,	// THREE.Texture\r\n		size: size, 		// size in pixels (-1 = use texture.width)\r\n		distance: distance, 	// distance (0-1) from light source (0=at light source)\r\n		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n		scale: 1, 		// scale\r\n		rotation: 0, 		// rotation\r\n		opacity: opacity,	// opacity\r\n		color: color,		// color\r\n		blending: blending	// blending\r\n	} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n	var f, fl = this.lensFlares.length;\r\n	var flare;\r\n	var vecX = - this.positionScreen.x * 2;\r\n	var vecY = - this.positionScreen.y * 2;\r\n\r\n	for ( f = 0; f < fl; f ++ ) {\r\n\r\n		flare = this.lensFlares[ f ];\r\n\r\n		flare.x = this.positionScreen.x + vecX * flare.distance;\r\n		flare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n		flare.wantedRotation = flare.x * Math.PI * 0.25;\r\n		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	this.positionScreen.copy( source.positionScreen );\r\n	this.customUpdateCallback = source.customUpdateCallback;\r\n\r\n	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\r\n		this.lensFlares.push( source.lensFlares[ i ] );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Scene';\r\n\r\n	this.fog = null;\r\n	this.overrideMaterial = null;\r\n\r\n	this.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.copy = function ( source ) {\r\n\r\n	THREE.Object3D.prototype.copy.call( this, source );\r\n\r\n	if ( source.fog !== null ) this.fog = source.fog.clone();\r\n	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\r\n	this.autoUpdate = source.autoUpdate;\r\n	this.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n\r\n	this.near = ( near !== undefined ) ? near : 1;\r\n	this.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n	return new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n	this.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n	return new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n	uniform sampler2D alphaMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n	if ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/ambient_pars.glsl\r\n\r\nTHREE.ShaderChunk[ 'ambient_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n	return PI * ambientLightColor;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n	reflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n	uniform sampler2D aoMap;\\n	uniform float aoMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\r\nTHREE.ShaderChunk[ 'bsdfs' ] = \"float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n	if ( decayExponent > 0.0 ) {\\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n	}\\n	return 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n	return RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n	float a2 = alpha * alpha;\\n	float gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\\n	float gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\\n	return 1.0 / ( gl * gv );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n	float a2 = alpha * alpha;\\n	float denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0;\\n	return RECIPROCAL_PI * a2 / ( denom * denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n	float alpha = roughness * roughness;\\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n	vec3 F = F_Schlick( specularColor, dotLH );\\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\\n	float D = D_GGX( alpha, dotNH );\\n	return F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n	vec4 r = roughness * c0 + c1;\\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n	return specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n	return 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n	vec3 F = F_Schlick( specularColor, dotLH );\\n	float G = G_BlinnPhong_Implicit( );\\n	float D = D_BlinnPhong( shininess, dotNH );\\n	return F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n	return ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\\n}\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n	uniform sampler2D bumpMap;\\n	uniform float bumpScale;\\n	vec2 dHdxy_fwd() {\\n		vec2 dSTdx = dFdx( vUv );\\n		vec2 dSTdy = dFdy( vUv );\\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n		return vec2( dBx, dBy );\\n	}\\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n		vec3 vSigmaX = dFdx( surf_pos );\\n		vec3 vSigmaY = dFdy( surf_pos );\\n		vec3 vN = surf_norm;\\n		vec3 R1 = cross( vSigmaY, vN );\\n		vec3 R2 = cross( vN, vSigmaX );\\n		float fDet = dot( vSigmaX, R1 );\\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n		return normalize( abs( fDet ) * surf_norm - vGrad );\\n	}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n	diffuseColor.rgb *= vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n	varying vec3 vColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n	varying vec3 vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n	vColor.xyz = color.xyz;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat square( const in float x ) { return x*x; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nstruct IncidentLight {\\n	vec3 color;\\n	vec3 direction;\\n};\\nstruct ReflectedLight {\\n	vec3 directDiffuse;\\n	vec3 directSpecular;\\n	vec3 indirectDiffuse;\\n	vec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n	vec3 position;\\n	vec3 normal;\\n	vec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n	float distance = dot( planeNormal, point - pointOnPlane );\\n	return - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n	return sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nvec3 inputToLinear( in vec3 a ) {\\n	#ifdef GAMMA_INPUT\\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n	#else\\n		return a;\\n	#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n	#ifdef GAMMA_OUTPUT\\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n	#else\\n		return a;\\n	#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n	objectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n	uniform sampler2D displacementMap;\\n	uniform float displacementScale;\\n	uniform float displacementBias;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\\n	totalEmissiveLight *= emissiveColor.rgb;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n	uniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n		#ifdef ENVMAP_MODE_REFLECTION\\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n		#else\\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n		#endif\\n	#else\\n		vec3 reflectVec = vReflect;\\n	#endif\\n	#ifdef DOUBLE_SIDED\\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n	#else\\n		float flipNormal = 1.0;\\n	#endif\\n	#ifdef ENVMAP_TYPE_CUBE\\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n	#elif defined( ENVMAP_TYPE_EQUIREC )\\n		vec2 sampleUV;\\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n		vec4 envColor = texture2D( envMap, sampleUV );\\n	#elif defined( ENVMAP_TYPE_SPHERE )\\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n	#endif\\n	envColor.xyz = inputToLinear( envColor.xyz );\\n	#ifdef ENVMAP_BLENDING_MULTIPLY\\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n	#elif defined( ENVMAP_BLENDING_MIX )\\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n	#elif defined( ENVMAP_BLENDING_ADD )\\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( STANDARD )\\n	uniform float reflectivity;\\n	uniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n	#ifdef ENVMAP_TYPE_CUBE\\n		uniform samplerCube envMap;\\n	#else\\n		uniform sampler2D envMap;\\n	#endif\\n	uniform float flipEnvMap;\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\\n		uniform float refractionRatio;\\n	#else\\n		varying vec3 vReflect;\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n	varying vec3 vReflect;\\n	uniform float refractionRatio;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n	#ifdef ENVMAP_MODE_REFLECTION\\n		vReflect = reflect( cameraToVertex, worldNormal );\\n	#else\\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\\n	#else\\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\\n	#endif\\n	#ifdef FOG_EXP2\\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n	#else\\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\\n	#endif\\n	\\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n	uniform vec3 fogColor;\\n	#ifdef FOG_EXP2\\n		uniform float fogDensity;\\n	#else\\n		uniform float fogNear;\\n		uniform float fogFar;\\n	#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n	uniform sampler2D lightMap;\\n	uniform float lightMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n	vLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n		directLight = getPointDirectLight( pointLights[ i ], geometry );\\n		dotNL = dot( geometry.normal, directLight.direction );\\n		directLightColor_Diffuse = PI * directLight.color;\\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n		#ifdef DOUBLE_SIDED\\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n		#endif\\n	}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n		directLight = getSpotDirectLight( spotLights[ i ], geometry );\\n		dotNL = dot( geometry.normal, directLight.direction );\\n		directLightColor_Diffuse = PI * directLight.color;\\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n		#ifdef DOUBLE_SIDED\\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n		#endif\\n	}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n		directLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\\n		dotNL = dot( geometry.normal, directLight.direction );\\n		directLightColor_Diffuse = PI * directLight.color;\\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n		#ifdef DOUBLE_SIDED\\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n		#endif\\n	}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n		#ifdef DOUBLE_SIDED\\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n		#endif\\n	}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_pars' ] = \"#if NUM_DIR_LIGHTS > 0\\n	struct DirectionalLight {\\n		vec3 direction;\\n		vec3 color;\\n		int shadow;\\n		float shadowBias;\\n		float shadowRadius;\\n		vec2 shadowMapSize;\\n	};\\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n	IncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\\n		IncidentLight directLight;\\n		directLight.color = directionalLight.color;\\n		directLight.direction = directionalLight.direction;\\n		return directLight;\\n	}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n	struct PointLight {\\n		vec3 position;\\n		vec3 color;\\n		float distance;\\n		float decay;\\n		int shadow;\\n		float shadowBias;\\n		float shadowRadius;\\n		vec2 shadowMapSize;\\n	};\\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n	IncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\\n		IncidentLight directLight;\\n		vec3 lVector = pointLight.position - geometry.position;\\n		directLight.direction = normalize( lVector );\\n		directLight.color = pointLight.color;\\n		directLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\\n		return directLight;\\n	}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n	struct SpotLight {\\n		vec3 position;\\n		vec3 direction;\\n		vec3 color;\\n		float distance;\\n		float decay;\\n		float angleCos;\\n		float exponent;\\n		int shadow;\\n		float shadowBias;\\n		float shadowRadius;\\n		vec2 shadowMapSize;\\n	};\\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n	IncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\\n		IncidentLight directLight;\\n		vec3 lVector = spotLight.position - geometry.position;\\n		directLight.direction = normalize( lVector );\\n		float spotEffect = dot( directLight.direction, spotLight.direction );\\n		if ( spotEffect > spotLight.angleCos ) {\\n			float spotEffect = dot( spotLight.direction, directLight.direction );\\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\\n			directLight.color = spotLight.color;\\n			directLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\\n		} else {\\n			directLight.color = vec3( 0.0 );\\n		}\\n		return directLight;\\n	}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n	struct HemisphereLight {\\n		vec3 direction;\\n		vec3 skyColor;\\n		vec3 groundColor;\\n	};\\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n		float dotNL = dot( geometry.normal, hemiLight.direction );\\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n		return PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n	}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( STANDARD )\\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n		#ifdef DOUBLE_SIDED\\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n		#else\\n			float flipNormal = 1.0;\\n		#endif\\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n		#ifdef ENVMAP_TYPE_CUBE\\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n			#ifdef TEXTURE_LOD_EXT\\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n			#else\\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n			#endif\\n		#else\\n			vec3 envMapColor = vec3( 0.0 );\\n		#endif\\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\\n		return PI * envMapColor.rgb * envMapIntensity;\\n	}\\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n		float maxMIPLevelScalar = float( maxMIPLevel );\\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n	}\\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n		#ifdef ENVMAP_MODE_REFLECTION\\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n		#else\\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n		#endif\\n		#ifdef DOUBLE_SIDED\\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n		#else\\n			float flipNormal = 1.0;\\n		#endif\\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n		#ifdef ENVMAP_TYPE_CUBE\\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n			#ifdef TEXTURE_LOD_EXT\\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n			#else\\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n			#endif\\n		#elif defined( ENVMAP_TYPE_EQUIREC )\\n			vec2 sampleUV;\\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n			#ifdef TEXTURE_LOD_EXT\\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n			#else\\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n			#endif\\n		#elif defined( ENVMAP_TYPE_SPHERE )\\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n			#ifdef TEXTURE_LOD_EXT\\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n			#else\\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n			#endif\\n		#endif\\n		envMapColor.rgb = inputToLinear( envMapColor.rgb );\\n		return envMapColor.rgb * envMapIntensity;\\n	}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"#ifdef USE_ENVMAP\\n	varying vec3 vWorldPosition;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n	varying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n	vec3	diffuseColor;\\n	vec3	specularColor;\\n	float	specularShininess;\\n	float	specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n	vec3 irradiance = dotNL * PI * directLight.color;\\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct				RE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )	(0)\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n	varying vec3 vWorldPosition;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex' ] = \"#ifdef USE_ENVMAP\\n	vWorldPosition = worldPosition.xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_standard_fragment' ] = \"StandardMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_standard_pars_fragment' ] = \"struct StandardMaterial {\\n	vec3	diffuseColor;\\n	float	specularRoughness;\\n	vec3	specularColor;\\n};\\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n	vec3 irradiance = dotNL * PI * directLight.color;\\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct				RE_Direct_Standard\\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n	PointLight pointLight;\\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n		pointLight = pointLights[ i ];\\n		directLight = getPointDirectLight( pointLight, geometry );\\n		#ifdef USE_SHADOWMAP\\n		directLight.color *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n		#endif\\n		RE_Direct( directLight, geometry, material, reflectedLight );\\n	}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n	SpotLight spotLight;\\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n		spotLight = spotLights[ i ];\\n		directLight = getSpotDirectLight( spotLight, geometry );\\n		#ifdef USE_SHADOWMAP\\n		directLight.color *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n		#endif\\n		RE_Direct( directLight, geometry, material, reflectedLight );\\n	}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n	DirectionalLight directionalLight;\\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n		directionalLight = directionalLights[ i ];\\n		directLight = getDirectionalDirectLight( directionalLight, geometry );\\n		#ifdef USE_SHADOWMAP\\n		directLight.color *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n		#endif\\n		RE_Direct( directLight, geometry, material, reflectedLight );\\n	}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n	#ifdef USE_LIGHTMAP\\n		irradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n	#endif\\n	#if ( NUM_HEMI_LIGHTS > 0 )\\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n		}\\n	#endif\\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'linear_to_gamma_fragment' ] = \"\\n	outgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n	uniform float logDepthBufFC;\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n		varying float vFragDepth;\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n		varying float vFragDepth;\\n	#endif\\n	uniform float logDepthBufFC;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n		vFragDepth = 1.0 + gl_Position.w;\\n	#else\\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n	vec4 texelColor = texture2D( map, vUv );\\n	texelColor.xyz = inputToLinear( texelColor.xyz );\\n	diffuseColor *= texelColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n	uniform sampler2D map;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n	uniform vec4 offsetRepeat;\\n	uniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\\n	metalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n	uniform sampler2D metalnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n	#ifndef USE_MORPHNORMALS\\n	uniform float morphTargetInfluences[ 8 ];\\n	#else\\n	uniform float morphTargetInfluences[ 4 ];\\n	#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n	#ifndef USE_MORPHNORMALS\\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n	vec3 fdx = dFdx( vViewPosition );\\n	vec3 fdy = dFdy( vViewPosition );\\n	vec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n	vec3 normal = normalize( vNormal );\\n	#ifdef DOUBLE_SIDED\\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n	#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n	normal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n	uniform sampler2D normalMap;\\n	uniform vec2 normalScale;\\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n		vec3 q0 = dFdx( eye_pos.xyz );\\n		vec3 q1 = dFdy( eye_pos.xyz );\\n		vec2 st0 = dFdx( vUv.st );\\n		vec2 st1 = dFdy( vUv.st );\\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n		vec3 N = normalize( surf_norm );\\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n		mapN.xy = normalScale * mapN.xy;\\n		mat3 tsn = mat3( S, T, N );\\n		return normalize( tsn * mapN );\\n	}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n	vec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\\n	roughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n	uniform sampler2D roughnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n	#if NUM_DIR_LIGHTS > 0\\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n	#endif\\n	#if NUM_SPOT_LIGHTS > 0\\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n	#endif\\n	#if NUM_POINT_LIGHTS > 0\\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n	#endif\\n	float unpackDepth( const in vec4 rgba_depth ) {\\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n		return dot( rgba_depth, bit_shift );\\n	}\\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\\n	}\\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n		const vec2 offset = vec2( 0.0, 1.0 );\\n		vec2 texelSize = vec2( 1.0 ) / size;\\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n		vec2 f = fract( uv * size + 0.5 );\\n		float a = mix( lb, lt, f.y );\\n		float b = mix( rb, rt, f.y );\\n		float c = mix( a, b, f.x );\\n		return c;\\n	}\\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n		shadowCoord.xyz /= shadowCoord.w;\\n		shadowCoord.z += shadowBias;\\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n		bool inFrustum = all( inFrustumVec );\\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n		bool frustumTest = all( frustumTestVec );\\n		if ( frustumTest ) {\\n		#if defined( SHADOWMAP_TYPE_PCF )\\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n			float dx0 = - texelSize.x * shadowRadius;\\n			float dy0 = - texelSize.y * shadowRadius;\\n			float dx1 = + texelSize.x * shadowRadius;\\n			float dy1 = + texelSize.y * shadowRadius;\\n			return (\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n			) * ( 1.0 / 9.0 );\\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n			float dx0 = - texelSize.x * shadowRadius;\\n			float dy0 = - texelSize.y * shadowRadius;\\n			float dx1 = + texelSize.x * shadowRadius;\\n			float dy1 = + texelSize.y * shadowRadius;\\n			return (\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n			) * ( 1.0 / 9.0 );\\n		#else\\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n		#endif\\n		}\\n		return 1.0;\\n	}\\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\\n		vec3 absV = abs( v );\\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n		absV *= scaleToCube;\\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n		vec2 planar = v.xy;\\n		float almostATexel = 1.5 * texelSizeY;\\n		float almostOne = 1.0 - almostATexel;\\n		if ( absV.z >= almostOne ) {\\n			if ( v.z > 0.0 )\\n				planar.x = 4.0 - v.x;\\n		} else if ( absV.x >= almostOne ) {\\n			float signX = sign( v.x );\\n			planar.x = v.z * signX + 2.0 * signX;\\n		} else if ( absV.y >= almostOne ) {\\n			float signY = sign( v.y );\\n			planar.x = v.x + 2.0 * signY + 2.0;\\n			planar.y = v.z * signY - 2.0;\\n		}\\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n	}\\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n		vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n		vec3 lightToPosition = shadowCoord.xyz;\\n		vec3 bd3D = normalize( lightToPosition );\\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n			vec3 offset = vec3( - 1, 0, 1 ) * shadowRadius * 2.0 * texelSize.y;\\n			return (\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zzy, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zxy, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xzy, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.zyx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxz, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp ) +\\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yzx, texelSize.y ), dp )\\n			) * ( 1.0 / 21.0 );\\n		#else\\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n		#endif\\n	}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n	#if NUM_DIR_LIGHTS > 0\\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n	#endif\\n	#if NUM_SPOT_LIGHTS > 0\\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n	#endif\\n	#if NUM_POINT_LIGHTS > 0\\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n	#if NUM_DIR_LIGHTS > 0\\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n	}\\n	#endif\\n	#if NUM_SPOT_LIGHTS > 0\\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n	}\\n	#endif\\n	#if NUM_POINT_LIGHTS > 0\\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n	}\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n	float shadow = 1.0;\\n	#ifdef USE_SHADOWMAP\\n	#if NUM_DIR_LIGHTS > 0\\n	DirectionalLight directionalLight;\\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n		directionalLight = directionalLights[ i ];\\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n	}\\n	#endif\\n	#if NUM_SPOT_LIGHTS > 0\\n	SpotLight spotLight;\\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n		spotLight = spotLights[ i ];\\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n	}\\n	#endif\\n	#if NUM_POINT_LIGHTS > 0\\n	PointLight pointLight;\\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n		pointLight = pointLights[ i ];\\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n	}\\n	#endif\\n	#endif\\n	return shadow;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n	uniform mat4 bindMatrix;\\n	uniform mat4 bindMatrixInverse;\\n	#ifdef BONE_TEXTURE\\n		uniform sampler2D boneTexture;\\n		uniform int boneTextureWidth;\\n		uniform int boneTextureHeight;\\n		mat4 getBoneMatrix( const in float i ) {\\n			float j = i * 4.0;\\n			float x = mod( j, float( boneTextureWidth ) );\\n			float y = floor( j / float( boneTextureWidth ) );\\n			float dx = 1.0 / float( boneTextureWidth );\\n			float dy = 1.0 / float( boneTextureHeight );\\n			y = dy * ( y + 0.5 );\\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n			mat4 bone = mat4( v1, v2, v3, v4 );\\n			return bone;\\n		}\\n	#else\\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n		mat4 getBoneMatrix( const in float i ) {\\n			mat4 bone = boneGlobalMatrices[ int(i) ];\\n			return bone;\\n		}\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n	vec4 skinned = vec4( 0.0 );\\n	skinned += boneMatX * skinVertex * skinWeight.x;\\n	skinned += boneMatY * skinVertex * skinWeight.y;\\n	skinned += boneMatZ * skinVertex * skinWeight.z;\\n	skinned += boneMatW * skinVertex * skinWeight.w;\\n	skinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n	mat4 skinMatrix = mat4( 0.0 );\\n	skinMatrix += skinWeight.x * boneMatX;\\n	skinMatrix += skinWeight.y * boneMatY;\\n	skinMatrix += skinWeight.z * boneMatZ;\\n	skinMatrix += skinWeight.w * boneMatW;\\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n	vec4 texelSpecular = texture2D( specularMap, vUv );\\n	specularStrength = texelSpecular.r;\\n#else\\n	specularStrength = 1.0;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n	uniform sampler2D specularMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n	varying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n	attribute vec2 uv2;\\n	varying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n	vUv2 = uv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n	varying vec2 vUv;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n	varying vec2 vUv;\\n	uniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n	#ifdef USE_SKINNING\\n		vec4 worldPosition = modelMatrix * skinned;\\n	#else\\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n	#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n	merge: function ( uniforms ) {\r\n\r\n		var merged = {};\r\n\r\n		for ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n			var tmp = this.clone( uniforms[ u ] );\r\n\r\n			for ( var p in tmp ) {\r\n\r\n				merged[ p ] = tmp[ p ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return merged;\r\n\r\n	},\r\n\r\n	clone: function ( uniforms_src ) {\r\n\r\n		var uniforms_dst = {};\r\n\r\n		for ( var u in uniforms_src ) {\r\n\r\n			uniforms_dst[ u ] = {};\r\n\r\n			for ( var p in uniforms_src[ u ] ) {\r\n\r\n				var parameter_src = uniforms_src[ u ][ p ];\r\n\r\n				if ( parameter_src instanceof THREE.Color ||\r\n					 parameter_src instanceof THREE.Vector2 ||\r\n					 parameter_src instanceof THREE.Vector3 ||\r\n					 parameter_src instanceof THREE.Vector4 ||\r\n					 parameter_src instanceof THREE.Matrix3 ||\r\n					 parameter_src instanceof THREE.Matrix4 ||\r\n					 parameter_src instanceof THREE.Texture ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n				} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n				} else {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return uniforms_dst;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n	common: {\r\n\r\n		\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\": { type: \"f\", value: 1.0 },\r\n\r\n		\"map\": { type: \"t\", value: null },\r\n		\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n		\"specularMap\": { type: \"t\", value: null },\r\n		\"alphaMap\": { type: \"t\", value: null },\r\n\r\n		\"envMap\": { type: \"t\", value: null },\r\n		\"flipEnvMap\": { type: \"f\", value: - 1 },\r\n		\"reflectivity\": { type: \"f\", value: 1.0 },\r\n		\"refractionRatio\": { type: \"f\", value: 0.98 }\r\n\r\n	},\r\n\r\n	aomap: {\r\n\r\n		\"aoMap\": { type: \"t\", value: null },\r\n		\"aoMapIntensity\": { type: \"f\", value: 1 }\r\n\r\n	},\r\n\r\n	lightmap: {\r\n\r\n		\"lightMap\": { type: \"t\", value: null },\r\n		\"lightMapIntensity\": { type: \"f\", value: 1 }\r\n\r\n	},\r\n\r\n	emissivemap: {\r\n\r\n		\"emissiveMap\": { type: \"t\", value: null }\r\n\r\n	},\r\n\r\n	bumpmap: {\r\n\r\n		\"bumpMap\": { type: \"t\", value: null },\r\n		\"bumpScale\": { type: \"f\", value: 1 }\r\n\r\n	},\r\n\r\n	normalmap: {\r\n\r\n		\"normalMap\": { type: \"t\", value: null },\r\n		\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\r\n	},\r\n\r\n	displacementmap: {\r\n\r\n		\"displacementMap\": { type: \"t\", value: null },\r\n		\"displacementScale\": { type: \"f\", value: 1 },\r\n		\"displacementBias\": { type: \"f\", value: 0 }\r\n\r\n	},\r\n\r\n	roughnessmap: {\r\n\r\n		\"roughnessMap\": { type: \"t\", value: null }\r\n\r\n	},\r\n\r\n	metalnessmap: {\r\n\r\n		\"metalnessMap\": { type: \"t\", value: null }\r\n\r\n	},\r\n\r\n	fog: {\r\n\r\n		\"fogDensity\": { type: \"f\", value: 0.00025 },\r\n		\"fogNear\": { type: \"f\", value: 1 },\r\n		\"fogFar\": { type: \"f\", value: 2000 },\r\n		\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n	},\r\n\r\n	ambient: {\r\n\r\n		\"ambientLightColor\": { type: \"fv\", value: [] }\r\n\r\n	},\r\n\r\n	lights: {\r\n\r\n		\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n			\"direction\": { type: \"v3\" },\r\n			\"color\": { type: \"c\" },\r\n\r\n			\"shadow\": { type: \"i\" },\r\n			\"shadowBias\": { type: \"f\" },\r\n			\"shadowRadius\": { type: \"f\" },\r\n			\"shadowMapSize\": { type: \"v2\" }\r\n		} },\r\n\r\n		\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n		\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n		\"spotLights\": { type: \"sa\", value: [], properties: {\r\n			\"color\": { type: \"c\" },\r\n			\"position\": { type: \"v3\" },\r\n			\"direction\": { type: \"v3\" },\r\n			\"distance\": { type: \"f\" },\r\n			\"angleCos\": { type: \"f\" },\r\n			\"exponent\": { type: \"f\" },\r\n			\"decay\": { type: \"f\" },\r\n\r\n			\"shadow\": { type: \"i\" },\r\n			\"shadowBias\": { type: \"f\" },\r\n			\"shadowRadius\": { type: \"f\" },\r\n			\"shadowMapSize\": { type: \"v2\" }\r\n		} },\r\n\r\n		\"spotShadowMap\": { type: \"tv\", value: [] },\r\n		\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n		\"pointLights\": { type: \"sa\", value: [], properties: {\r\n			\"color\": { type: \"c\" },\r\n			\"position\": { type: \"v3\" },\r\n			\"decay\": { type: \"f\" },\r\n			\"distance\": { type: \"f\" },\r\n\r\n			\"shadow\": { type: \"i\" },\r\n			\"shadowBias\": { type: \"f\" },\r\n			\"shadowRadius\": { type: \"f\" },\r\n			\"shadowMapSize\": { type: \"v2\" }\r\n		} },\r\n\r\n		\"pointShadowMap\": { type: \"tv\", value: [] },\r\n		\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n		\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n			\"direction\": { type: \"v3\" },\r\n			\"skyColor\": { type: \"c\" },\r\n			\"groundColor\": { type: \"c\" }\r\n		} }\r\n\r\n	},\r\n\r\n	points: {\r\n\r\n		\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\": { type: \"f\", value: 1.0 },\r\n		\"size\": { type: \"f\", value: 1.0 },\r\n		\"scale\": { type: \"f\", value: 1.0 },\r\n		\"map\": { type: \"t\", value: null },\r\n		\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n	'basic': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"fog\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n			\"	#ifdef USE_ENVMAP\",\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"#ifndef FLAT_SHADED\",\r\n\r\n			\"	varying vec3 vNormal;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n			\"	ReflectedLight reflectedLight;\",\r\n			\"	reflectedLight.directDiffuse = vec3( 0.0 );\",\r\n			\"	reflectedLight.directSpecular = vec3( 0.0 );\",\r\n			\"	reflectedLight.indirectDiffuse = diffuseColor.rgb;\",\r\n			\"	reflectedLight.indirectSpecular = vec3( 0.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n\r\n			\"	vec3 outgoingLight = reflectedLight.indirectDiffuse;\",\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'lambert': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"lightmap\" ],\r\n			THREE.UniformsLib[ \"emissivemap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"ambient\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n\r\n			{\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define LAMBERT\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"bsdfs\" ],\r\n			THREE.ShaderChunk[ \"lights_pars\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bsdfs\" ],\r\n			THREE.ShaderChunk[ \"ambient_pars\" ],\r\n			THREE.ShaderChunk[ \"lights_pars\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmask_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n			\"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n			\"	vec3 totalEmissiveLight = emissive;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"emissivemap_fragment\" ],\r\n\r\n				// accumulation\r\n			\"	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\",\r\n\r\n				THREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\r\n			\"	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\",\r\n\r\n			\"	#ifdef DOUBLE_SIDED\",\r\n\r\n			\"		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		reflectedLight.directDiffuse = vLightFront;\",\r\n\r\n			\"	#endif\",\r\n\r\n			\"	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\",\r\n\r\n				// modulation\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n\r\n			\"	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveLight;\",\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'phong': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"lightmap\" ],\r\n			THREE.UniformsLib[ \"emissivemap\" ],\r\n			THREE.UniformsLib[ \"bumpmap\" ],\r\n			THREE.UniformsLib[ \"normalmap\" ],\r\n			THREE.UniformsLib[ \"displacementmap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"ambient\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n\r\n			{\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n				\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n				\"shininess\": { type: \"f\", value: 30 }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"varying vec3 vViewPosition;\",\r\n\r\n			\"#ifndef FLAT_SHADED\",\r\n\r\n			\"	varying vec3 vNormal;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"displacementmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n			\"	vNormal = normalize( transformedNormal );\",\r\n\r\n			\"#endif\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"displacementmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"	vViewPosition = - mvPosition.xyz;\",\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform vec3 specular;\",\r\n			\"uniform float shininess;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bsdfs\" ],\r\n			THREE.ShaderChunk[ \"ambient_pars\" ],\r\n			THREE.ShaderChunk[ \"lights_pars\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n			\"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n			\"	vec3 totalEmissiveLight = emissive;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"normal_fragment\" ],\r\n				THREE.ShaderChunk[ \"emissivemap_fragment\" ],\r\n\r\n				// accumulation\r\n				THREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n				THREE.ShaderChunk[ \"lights_template\" ],\r\n\r\n				// modulation\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n\r\n				\"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\",\r\n\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'standard': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"aomap\" ],\r\n			THREE.UniformsLib[ \"lightmap\" ],\r\n			THREE.UniformsLib[ \"emissivemap\" ],\r\n			THREE.UniformsLib[ \"bumpmap\" ],\r\n			THREE.UniformsLib[ \"normalmap\" ],\r\n			THREE.UniformsLib[ \"displacementmap\" ],\r\n			THREE.UniformsLib[ \"roughnessmap\" ],\r\n			THREE.UniformsLib[ \"metalnessmap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"ambient\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n\r\n			{\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n				\"roughness\": { type: \"f\", value: 0.5 },\r\n				\"metalness\": { type: \"f\", value: 0 },\r\n				\"envMapIntensity\" : { type: \"f\", value: 1 } // temporary\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define STANDARD\",\r\n\r\n			\"varying vec3 vViewPosition;\",\r\n\r\n			\"#ifndef FLAT_SHADED\",\r\n\r\n			\"	varying vec3 vNormal;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"displacementmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\", // STANDARD\r\n\r\n				THREE.ShaderChunk[ \"uv_vertex\" ],\r\n				THREE.ShaderChunk[ \"uv2_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"beginnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n			\"	vNormal = normalize( transformedNormal );\",\r\n\r\n			\"#endif\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"displacementmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"	vViewPosition = - mvPosition.xyz;\",\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"#define STANDARD\",\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform float roughness;\",\r\n			\"uniform float metalness;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"uniform float envMapIntensity;\", // temporary\r\n\r\n			\"varying vec3 vViewPosition;\",\r\n\r\n			\"#ifndef FLAT_SHADED\",\r\n\r\n			\"	varying vec3 vNormal;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bsdfs\" ],\r\n			THREE.ShaderChunk[ \"ambient_pars\" ],\r\n			THREE.ShaderChunk[ \"lights_pars\" ],\r\n			THREE.ShaderChunk[ \"lights_standard_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"roughnessmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"metalnessmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n			\"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n			\"	vec3 totalEmissiveLight = emissive;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"roughnessmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"metalnessmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"normal_fragment\" ],\r\n				THREE.ShaderChunk[ \"emissivemap_fragment\" ],\r\n\r\n				// accumulation\r\n				THREE.ShaderChunk[ \"lights_standard_fragment\" ],\r\n				THREE.ShaderChunk[ \"lights_template\" ],\r\n\r\n				// modulation\r\n				THREE.ShaderChunk[ \"aomap_fragment\" ],\r\n\r\n				\"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;\",\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'points': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"points\" ],\r\n			THREE.UniformsLib[ \"fog\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float size;\",\r\n			\"uniform float scale;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n\r\n			\"	#ifdef USE_SIZEATTENUATION\",\r\n			\"		gl_PointSize = size * ( scale / - mvPosition.z );\",\r\n			\"	#else\",\r\n			\"		gl_PointSize = size;\",\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\r\n			\"	outgoingLight = diffuseColor.rgb;\",\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'dashed': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n\r\n			{\r\n				\"scale\"    : { type: \"f\", value: 1 },\r\n				\"dashSize\" : { type: \"f\", value: 1 },\r\n				\"totalSize\": { type: \"f\", value: 2 }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float scale;\",\r\n			\"attribute float lineDistance;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n			\"	vLineDistance = scale * lineDistance;\",\r\n\r\n			\"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n			\"	gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"uniform float dashSize;\",\r\n			\"uniform float totalSize;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n			\"		discard;\",\r\n\r\n			\"	}\",\r\n\r\n			\"	vec3 outgoingLight = vec3( 0.0 );\",\r\n			\"	vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n\r\n			\"	outgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'depth': {\r\n\r\n		uniforms: {\r\n\r\n			\"mNear\": { type: \"f\", value: 1.0 },\r\n			\"mFar\" : { type: \"f\", value: 2000.0 },\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float mNear;\",\r\n			\"uniform float mFar;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		float depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n			\"	#endif\",\r\n\r\n			\"	float color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n			\"	gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	'normal': {\r\n\r\n		uniforms: {\r\n\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vNormal = normalize( normalMatrix * normal );\",\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float opacity;\",\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'cube': {\r\n\r\n		uniforms: {\r\n			\"tCube\": { type: \"t\", value: null },\r\n			\"tFlip\": { type: \"f\", value: - 1 }\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform samplerCube tCube;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'equirect': {\r\n\r\n		uniforms: {\r\n			\"tEquirect\": { type: \"t\", value: null },\r\n			\"tFlip\": { type: \"f\", value: - 1 }\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform sampler2D tEquirect;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				// \"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n				\"vec3 direction = normalize( vWorldPosition );\",\r\n				\"vec2 sampleUV;\",\r\n				\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n				\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n				\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n	/* Depth encoding into RGBA texture\r\n	 *\r\n	 * based on SpiderGL shadow map example\r\n	 * http://spidergl.org/example.php?id=6\r\n	 *\r\n	 * originally from\r\n	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n	 *\r\n	 * see also\r\n	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n	 */\r\n\r\n	'depthRGBA': {\r\n\r\n		uniforms: {},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n			\"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n			\"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n			\"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\",\r\n			\"	res -= res.xxyz * bit_mask;\",\r\n			\"	return res;\",\r\n\r\n			\"}\",\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n			\"	#endif\",\r\n\r\n				//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n				//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n				//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n				//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	},\r\n\r\n\r\n	'distanceRGBA': {\r\n\r\n		uniforms: {\r\n\r\n			\"lightPos\": { type: \"v3\", value: new THREE.Vector3( 0, 0, 0 ) }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec4 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"begin_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"project_vertex\" ],\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\r\n				\"vWorldPosition = worldPosition;\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" ),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 lightPos;\",\r\n			\"varying vec4 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"common\" ],\r\n\r\n			\"vec4 pack1K ( float depth ) {\",\r\n\r\n			\"	depth /= 1000.0;\",\r\n			\"	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n			\"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n			\"	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\",\r\n			\"	res -= res.xxyz * bitMsk;\",\r\n			\"	return res; \",\r\n\r\n			\"}\",\r\n\r\n			\"float unpack1K ( vec4 color ) {\",\r\n\r\n			\"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n			\"	return dot( color, bitSh ) * 1000.0;\",\r\n\r\n			\"}\",\r\n\r\n			\"void main () {\",\r\n\r\n			\"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\",\r\n\r\n			\"}\"\r\n\r\n		].join( \"\\n\" )\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n	console.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n	parameters = parameters || {};\r\n\r\n	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n	_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n	_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\r\n	var lights = [];\r\n\r\n	var opaqueObjects = [];\r\n	var opaqueObjectsLastIndex = - 1;\r\n	var transparentObjects = [];\r\n	var transparentObjectsLastIndex = - 1;\r\n\r\n	var morphInfluences = new Float32Array( 8 );\r\n\r\n	var sprites = [];\r\n	var lensFlares = [];\r\n\r\n	// public properties\r\n\r\n	this.domElement = _canvas;\r\n	this.context = null;\r\n\r\n	// clearing\r\n\r\n	this.autoClear = true;\r\n	this.autoClearColor = true;\r\n	this.autoClearDepth = true;\r\n	this.autoClearStencil = true;\r\n\r\n	// scene graph\r\n\r\n	this.sortObjects = true;\r\n\r\n	// physically based shading\r\n\r\n	this.gammaFactor = 2.0;	// for backwards compatibility\r\n	this.gammaInput = false;\r\n	this.gammaOutput = false;\r\n\r\n	// morphs\r\n\r\n	this.maxMorphTargets = 8;\r\n	this.maxMorphNormals = 4;\r\n\r\n	// flags\r\n\r\n	this.autoScaleCubemaps = true;\r\n\r\n	// internal properties\r\n\r\n	var _this = this,\r\n\r\n	// internal state cache\r\n\r\n	_currentProgram = null,\r\n	_currentRenderTarget = null,\r\n	_currentFramebuffer = null,\r\n	_currentMaterialId = - 1,\r\n	_currentGeometryProgram = '',\r\n	_currentCamera = null,\r\n\r\n	_currentScissor = new THREE.Vector4(),\r\n	_currentScissorTest = null,\r\n\r\n	_currentViewport = new THREE.Vector4(),\r\n\r\n	//\r\n\r\n	_usedTextureUnits = 0,\r\n\r\n	//\r\n\r\n	_clearColor = new THREE.Color( 0x000000 ),\r\n	_clearAlpha = 0,\r\n\r\n	_width = _canvas.width,\r\n	_height = _canvas.height,\r\n\r\n	_pixelRatio = 1,\r\n\r\n	_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n	_scissorTest = false,\r\n\r\n	_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\r\n	// frustum\r\n\r\n	_frustum = new THREE.Frustum(),\r\n\r\n	// camera matrices cache\r\n\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n	_vector3 = new THREE.Vector3(),\r\n\r\n	// light arrays cache\r\n\r\n	_lights = {\r\n\r\n		hash: '',\r\n\r\n		ambient: [ 0, 0, 0 ],\r\n		directional: [],\r\n		directionalShadowMap: [],\r\n		directionalShadowMatrix: [],\r\n		spot: [],\r\n		spotShadowMap: [],\r\n		spotShadowMatrix: [],\r\n		point: [],\r\n		pointShadowMap: [],\r\n		pointShadowMatrix: [],\r\n		hemi: [],\r\n\r\n		shadows: [],\r\n		shadowsPointLight: 0\r\n\r\n	},\r\n\r\n	// info\r\n\r\n	_infoMemory = {\r\n\r\n		geometries: 0,\r\n		textures: 0\r\n\r\n	},\r\n\r\n	_infoRender = {\r\n\r\n		calls: 0,\r\n		vertices: 0,\r\n		faces: 0,\r\n		points: 0\r\n\r\n	};\r\n\r\n	this.info = {\r\n\r\n		render: _infoRender,\r\n		memory: _infoMemory,\r\n		programs: null\r\n\r\n	};\r\n\r\n\r\n	// initialize\r\n\r\n	var _gl;\r\n\r\n	try {\r\n\r\n		var attributes = {\r\n			alpha: _alpha,\r\n			depth: _depth,\r\n			stencil: _stencil,\r\n			antialias: _antialias,\r\n			premultipliedAlpha: _premultipliedAlpha,\r\n			preserveDrawingBuffer: _preserveDrawingBuffer\r\n		};\r\n\r\n		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n		if ( _gl === null ) {\r\n\r\n			if ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n				throw 'Error creating WebGL context with your selected attributes.';\r\n\r\n			} else {\r\n\r\n				throw 'Error creating WebGL context.';\r\n\r\n			}\r\n\r\n		}\r\n\r\n		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n	} catch ( error ) {\r\n\r\n		console.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n	}\r\n\r\n	var extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n	extensions.get( 'OES_texture_float' );\r\n	extensions.get( 'OES_texture_float_linear' );\r\n	extensions.get( 'OES_texture_half_float' );\r\n	extensions.get( 'OES_texture_half_float_linear' );\r\n	extensions.get( 'OES_standard_derivatives' );\r\n	extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n	if ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n		THREE.BufferGeometry.MaxIndex = 4294967296;\r\n\r\n	}\r\n\r\n	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n	var properties = new THREE.WebGLProperties();\r\n	var objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n	var programCache = new THREE.WebGLPrograms( this, capabilities );\r\n	var lightCache = new THREE.WebGLLights();\r\n\r\n	this.info.programs = programCache.programs;\r\n\r\n	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\r\n	//\r\n\r\n	function getTargetPixelRatio() {\r\n\r\n		return _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n	}\r\n\r\n	function glClearColor( r, g, b, a ) {\r\n\r\n		if ( _premultipliedAlpha === true ) {\r\n\r\n			r *= a; g *= a; b *= a;\r\n\r\n		}\r\n\r\n		state.clearColor( r, g, b, a );\r\n\r\n	}\r\n\r\n	function setDefaultGLState() {\r\n\r\n		state.init();\r\n\r\n		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	}\r\n\r\n	function resetGLState() {\r\n\r\n		_currentProgram = null;\r\n		_currentCamera = null;\r\n\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n\r\n		state.reset();\r\n\r\n	}\r\n\r\n	setDefaultGLState();\r\n\r\n	this.context = _gl;\r\n	this.capabilities = capabilities;\r\n	this.extensions = extensions;\r\n	this.properties = properties;\r\n	this.state = state;\r\n\r\n	// shadow map\r\n\r\n	var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\r\n	this.shadowMap = shadowMap;\r\n\r\n\r\n	// Plugins\r\n\r\n	var spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n	// API\r\n\r\n	this.getContext = function () {\r\n\r\n		return _gl;\r\n\r\n	};\r\n\r\n	this.getContextAttributes = function () {\r\n\r\n		return _gl.getContextAttributes();\r\n\r\n	};\r\n\r\n	this.forceContextLoss = function () {\r\n\r\n		extensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n	};\r\n\r\n	this.getMaxAnisotropy = ( function () {\r\n\r\n		var value;\r\n\r\n		return function getMaxAnisotropy() {\r\n\r\n			if ( value !== undefined ) return value;\r\n\r\n			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n			if ( extension !== null ) {\r\n\r\n				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n			} else {\r\n\r\n				value = 0;\r\n\r\n			}\r\n\r\n			return value;\r\n\r\n		};\r\n\r\n	} )();\r\n\r\n	this.getPrecision = function () {\r\n\r\n		return capabilities.precision;\r\n\r\n	};\r\n\r\n	this.getPixelRatio = function () {\r\n\r\n		return _pixelRatio;\r\n\r\n	};\r\n\r\n	this.setPixelRatio = function ( value ) {\r\n\r\n		if ( value === undefined ) return;\r\n\r\n		_pixelRatio = value;\r\n\r\n		this.setSize( _viewport.z, _viewport.w, false );\r\n\r\n	};\r\n\r\n	this.getSize = function () {\r\n\r\n		return {\r\n			width: _width,\r\n			height: _height\r\n		};\r\n\r\n	};\r\n\r\n	this.setSize = function ( width, height, updateStyle ) {\r\n\r\n		_width = width;\r\n		_height = height;\r\n\r\n		_canvas.width = width * _pixelRatio;\r\n		_canvas.height = height * _pixelRatio;\r\n\r\n		if ( updateStyle !== false ) {\r\n\r\n			_canvas.style.width = width + 'px';\r\n			_canvas.style.height = height + 'px';\r\n\r\n		}\r\n\r\n		this.setViewport( 0, 0, width, height );\r\n\r\n	};\r\n\r\n	this.setViewport = function ( x, y, width, height ) {\r\n\r\n		state.viewport( _viewport.set( x, y, width, height ) );\r\n\r\n	};\r\n\r\n	this.setScissor = function ( x, y, width, height ) {\r\n\r\n		state.scissor( _scissor.set( x, y, width, height ) );\r\n\r\n	};\r\n\r\n	this.setScissorTest = function ( boolean ) {\r\n\r\n		state.setScissorTest( _scissorTest = boolean );\r\n\r\n	};\r\n\r\n	// Clearing\r\n\r\n	this.getClearColor = function () {\r\n\r\n		return _clearColor;\r\n\r\n	};\r\n\r\n	this.setClearColor = function ( color, alpha ) {\r\n\r\n		_clearColor.set( color );\r\n\r\n		_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.getClearAlpha = function () {\r\n\r\n		return _clearAlpha;\r\n\r\n	};\r\n\r\n	this.setClearAlpha = function ( alpha ) {\r\n\r\n		_clearAlpha = alpha;\r\n\r\n		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.clear = function ( color, depth, stencil ) {\r\n\r\n		var bits = 0;\r\n\r\n		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n		_gl.clear( bits );\r\n\r\n	};\r\n\r\n	this.clearColor = function () {\r\n\r\n		this.clear( true, false, false );\r\n\r\n	};\r\n\r\n	this.clearDepth = function () {\r\n\r\n		this.clear( false, true, false );\r\n\r\n	};\r\n\r\n	this.clearStencil = function () {\r\n\r\n		this.clear( false, false, true );\r\n\r\n	};\r\n\r\n	this.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n		this.setRenderTarget( renderTarget );\r\n		this.clear( color, depth, stencil );\r\n\r\n	};\r\n\r\n	// Reset\r\n\r\n	this.resetGLState = resetGLState;\r\n\r\n	this.dispose = function() {\r\n\r\n		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n	};\r\n\r\n	// Events\r\n\r\n	function onContextLost( event ) {\r\n\r\n		event.preventDefault();\r\n\r\n		resetGLState();\r\n		setDefaultGLState();\r\n\r\n		properties.clear();\r\n\r\n	}\r\n\r\n	function onTextureDispose( event ) {\r\n\r\n		var texture = event.target;\r\n\r\n		texture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n		deallocateTexture( texture );\r\n\r\n		_infoMemory.textures --;\r\n\r\n\r\n	}\r\n\r\n	function onRenderTargetDispose( event ) {\r\n\r\n		var renderTarget = event.target;\r\n\r\n		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n		deallocateRenderTarget( renderTarget );\r\n\r\n		_infoMemory.textures --;\r\n\r\n	}\r\n\r\n	function onMaterialDispose( event ) {\r\n\r\n		var material = event.target;\r\n\r\n		material.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n		deallocateMaterial( material );\r\n\r\n	}\r\n\r\n	// Buffer deallocation\r\n\r\n	function deallocateTexture( texture ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n			// cube texture\r\n\r\n			_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n		} else {\r\n\r\n			// 2D texture\r\n\r\n			if ( textureProperties.__webglInit === undefined ) return;\r\n\r\n			_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n		}\r\n\r\n		// remove all webgl properties\r\n		properties.delete( texture );\r\n\r\n	}\r\n\r\n	function deallocateRenderTarget( renderTarget ) {\r\n\r\n		var renderTargetProperties = properties.get( renderTarget );\r\n		var textureProperties = properties.get( renderTarget.texture );\r\n\r\n		if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;\r\n\r\n		_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n				_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n			_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\r\n		}\r\n\r\n		properties.delete( renderTarget.texture );\r\n		properties.delete( renderTarget );\r\n\r\n	}\r\n\r\n	function deallocateMaterial( material ) {\r\n\r\n		releaseMaterialProgramReference( material );\r\n\r\n		properties.delete( material );\r\n\r\n	}\r\n\r\n\r\n	function releaseMaterialProgramReference( material ) {\r\n\r\n		var programInfo = properties.get( material ).program;\r\n\r\n		material.program = undefined;\r\n\r\n		if ( programInfo !== undefined ) {\r\n\r\n			programCache.releaseProgram( programInfo );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Buffer rendering\r\n\r\n	this.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n		state.initAttributes();\r\n\r\n		var buffers = properties.get( object );\r\n\r\n		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\r\n		var attributes = program.getAttributes();\r\n\r\n		if ( object.hasPositions ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.position );\r\n			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasNormals ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\r\n			if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {\r\n\r\n				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\r\n					var array = object.normalArray;\r\n\r\n					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\r\n					array[ i + 0 ] = nx;\r\n					array[ i + 1 ] = ny;\r\n					array[ i + 2 ] = nz;\r\n\r\n					array[ i + 3 ] = nx;\r\n					array[ i + 4 ] = ny;\r\n					array[ i + 5 ] = nz;\r\n\r\n					array[ i + 6 ] = nx;\r\n					array[ i + 7 ] = ny;\r\n					array[ i + 8 ] = nz;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.normal );\r\n\r\n			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasUvs && material.map ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.uv );\r\n\r\n			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n			state.enableAttribute( attributes.color );\r\n\r\n			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		state.disableUnusedAttributes();\r\n\r\n		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n		object.count = 0;\r\n\r\n	};\r\n\r\n	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\r\n		setMaterial( material );\r\n\r\n		var program = setProgram( camera, fog, material, object );\r\n\r\n		var updateBuffers = false;\r\n		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\r\n		if ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n			_currentGeometryProgram = geometryProgram;\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		// morph targets\r\n\r\n		var morphTargetInfluences = object.morphTargetInfluences;\r\n\r\n		if ( morphTargetInfluences !== undefined ) {\r\n\r\n			var activeInfluences = [];\r\n\r\n			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\r\n				var influence = morphTargetInfluences[ i ];\r\n				activeInfluences.push( [ influence, i ] );\r\n\r\n			}\r\n\r\n			activeInfluences.sort( absNumericalSort );\r\n\r\n			if ( activeInfluences.length > 8 ) {\r\n\r\n				activeInfluences.length = 8;\r\n\r\n			}\r\n\r\n			var morphAttributes = geometry.morphAttributes;\r\n\r\n			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\r\n				var influence = activeInfluences[ i ];\r\n				morphInfluences[ i ] = influence[ 0 ];\r\n\r\n				if ( influence[ 0 ] !== 0 ) {\r\n\r\n					var index = influence[ 1 ];\r\n\r\n					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\r\n				} else {\r\n\r\n					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var uniforms = program.getUniforms();\r\n\r\n			if ( uniforms.morphTargetInfluences !== null ) {\r\n\r\n				_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );\r\n\r\n			}\r\n\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		//\r\n\r\n		var index = geometry.index;\r\n		var position = geometry.attributes.position;\r\n\r\n		if ( material.wireframe === true ) {\r\n\r\n			index = objects.getWireframeAttribute( geometry );\r\n\r\n		}\r\n\r\n		var renderer;\r\n\r\n		if ( index !== null ) {\r\n\r\n			renderer = indexedBufferRenderer;\r\n			renderer.setIndex( index );\r\n\r\n		} else {\r\n\r\n			renderer = bufferRenderer;\r\n\r\n		}\r\n\r\n		if ( updateBuffers ) {\r\n\r\n			setupVertexAttributes( material, program, geometry );\r\n\r\n			if ( index !== null ) {\r\n\r\n				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		//\r\n\r\n		var dataStart = 0;\r\n		var dataCount = Infinity;\r\n\r\n		if ( index !== null ) {\r\n\r\n			dataCount = index.count;\r\n\r\n		} else if ( position !== undefined ) {\r\n\r\n			dataCount = position.count;\r\n\r\n		}\r\n\r\n		var rangeStart = geometry.drawRange.start;\r\n		var rangeCount = geometry.drawRange.count;\r\n\r\n		var groupStart = group !== null ? group.start : 0;\r\n		var groupCount = group !== null ? group.count : Infinity;\r\n\r\n		var drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n		//\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			if ( material.wireframe === true ) {\r\n\r\n				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n				renderer.setMode( _gl.LINES );\r\n\r\n			} else {\r\n\r\n				switch ( object.drawMode ) {\r\n\r\n					case THREE.TrianglesDrawMode:\r\n						renderer.setMode( _gl.TRIANGLES );\r\n						break;\r\n\r\n					case THREE.TriangleStripDrawMode:\r\n						renderer.setMode( _gl.TRIANGLE_STRIP );\r\n						break;\r\n\r\n					case THREE.TriangleFanDrawMode:\r\n						renderer.setMode( _gl.TRIANGLE_FAN );\r\n						break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n		} else if ( object instanceof THREE.Line ) {\r\n\r\n			var lineWidth = material.linewidth;\r\n\r\n			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n			state.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n			if ( object instanceof THREE.LineSegments ) {\r\n\r\n				renderer.setMode( _gl.LINES );\r\n\r\n			} else {\r\n\r\n				renderer.setMode( _gl.LINE_STRIP );\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Points ) {\r\n\r\n			renderer.setMode( _gl.POINTS );\r\n\r\n		}\r\n\r\n		if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {\r\n\r\n			renderer.renderInstances( geometry, drawStart, drawCount );\r\n\r\n		} else {\r\n\r\n			renderer.render( drawStart, drawCount );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n		var extension;\r\n\r\n		if ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n			extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n			if ( extension === null ) {\r\n\r\n				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( startIndex === undefined ) startIndex = 0;\r\n\r\n		state.initAttributes();\r\n\r\n		var geometryAttributes = geometry.attributes;\r\n\r\n		var programAttributes = program.getAttributes();\r\n\r\n		var materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n		for ( var name in programAttributes ) {\r\n\r\n			var programAttribute = programAttributes[ name ];\r\n\r\n			if ( programAttribute >= 0 ) {\r\n\r\n				var geometryAttribute = geometryAttributes[ name ];\r\n\r\n				if ( geometryAttribute !== undefined ) {\r\n\r\n					var size = geometryAttribute.itemSize;\r\n					var buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\r\n					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n						var data = geometryAttribute.data;\r\n						var stride = data.stride;\r\n						var offset = geometryAttribute.offset;\r\n\r\n						if ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\r\n							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\r\n							if ( geometry.maxInstancedCount === undefined ) {\r\n\r\n								geometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n							}\r\n\r\n						} else {\r\n\r\n							state.enableAttribute( programAttribute );\r\n\r\n						}\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\r\n					} else {\r\n\r\n						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\r\n							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\r\n							if ( geometry.maxInstancedCount === undefined ) {\r\n\r\n								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n							}\r\n\r\n						} else {\r\n\r\n							state.enableAttribute( programAttribute );\r\n\r\n						}\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n					}\r\n\r\n				} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n					var value = materialDefaultAttributeValues[ name ];\r\n\r\n					if ( value !== undefined ) {\r\n\r\n						switch ( value.length ) {\r\n\r\n							case 2:\r\n								_gl.vertexAttrib2fv( programAttribute, value );\r\n								break;\r\n\r\n							case 3:\r\n								_gl.vertexAttrib3fv( programAttribute, value );\r\n								break;\r\n\r\n							case 4:\r\n								_gl.vertexAttrib4fv( programAttribute, value );\r\n								break;\r\n\r\n							default:\r\n								_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		state.disableUnusedAttributes();\r\n\r\n	}\r\n\r\n	// Sorting\r\n\r\n	function absNumericalSort( a, b ) {\r\n\r\n		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\r\n	}\r\n\r\n	function painterSortStable ( a, b ) {\r\n\r\n		if ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n			return a.object.renderOrder - b.object.renderOrder;\r\n\r\n		} else if ( a.material.id !== b.material.id ) {\r\n\r\n			return a.material.id - b.material.id;\r\n\r\n		} else if ( a.z !== b.z ) {\r\n\r\n			return a.z - b.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function reversePainterSortStable ( a, b ) {\r\n\r\n		if ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n			return a.object.renderOrder - b.object.renderOrder;\r\n\r\n		} if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Rendering\r\n\r\n	this.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n		if ( camera instanceof THREE.Camera === false ) {\r\n\r\n			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var fog = scene.fog;\r\n\r\n		// reset caching for this frame\r\n\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n		_currentCamera = null;\r\n\r\n		// update scene graph\r\n\r\n		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n		// update camera matrices and frustum\r\n\r\n		if ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n		camera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n		_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n		lights.length = 0;\r\n\r\n		opaqueObjectsLastIndex = - 1;\r\n		transparentObjectsLastIndex = - 1;\r\n\r\n		sprites.length = 0;\r\n		lensFlares.length = 0;\r\n\r\n		projectObject( scene, camera );\r\n\r\n		opaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n		transparentObjects.length = transparentObjectsLastIndex + 1;\r\n\r\n		if ( _this.sortObjects === true ) {\r\n\r\n			opaqueObjects.sort( painterSortStable );\r\n			transparentObjects.sort( reversePainterSortStable );\r\n\r\n		}\r\n\r\n		setupLights( lights, camera );\r\n\r\n		//\r\n\r\n		shadowMap.render( scene, camera );\r\n\r\n		//\r\n\r\n		_infoRender.calls = 0;\r\n		_infoRender.vertices = 0;\r\n		_infoRender.faces = 0;\r\n		_infoRender.points = 0;\r\n\r\n		if ( renderTarget === undefined ) {\r\n\r\n			renderTarget = null;\r\n\r\n		}\r\n\r\n		this.setRenderTarget( renderTarget );\r\n\r\n		if ( this.autoClear || forceClear ) {\r\n\r\n			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( scene.overrideMaterial ) {\r\n\r\n			var overrideMaterial = scene.overrideMaterial;\r\n\r\n			renderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n			renderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\r\n		} else {\r\n\r\n			// opaque pass (front-to-back order)\r\n\r\n			state.setBlending( THREE.NoBlending );\r\n			renderObjects( opaqueObjects, camera, fog );\r\n\r\n			// transparent pass (back-to-front order)\r\n\r\n			renderObjects( transparentObjects, camera, fog );\r\n\r\n		}\r\n\r\n		// custom render plugins (post pass)\r\n\r\n		spritePlugin.render( scene, camera );\r\n		lensFlarePlugin.render( scene, camera, _currentViewport );\r\n\r\n		// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n		if ( renderTarget ) {\r\n\r\n			var texture = renderTarget.texture;\r\n\r\n			if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n					texture.minFilter !== THREE.NearestFilter &&\r\n					texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n				updateRenderTargetMipmap( renderTarget );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n		state.setDepthTest( true );\r\n		state.setDepthWrite( true );\r\n		state.setColorWrite( true );\r\n\r\n		// _gl.finish();\r\n\r\n	};\r\n\r\n	function pushRenderItem( object, geometry, material, z, group ) {\r\n\r\n		var array, index;\r\n\r\n		// allocate the next position in the appropriate array\r\n\r\n		if ( material.transparent ) {\r\n\r\n			array = transparentObjects;\r\n			index = ++ transparentObjectsLastIndex;\r\n\r\n		} else {\r\n\r\n			array = opaqueObjects;\r\n			index = ++ opaqueObjectsLastIndex;\r\n\r\n		}\r\n\r\n		// recycle existing render item or grow the array\r\n\r\n		var renderItem = array[ index ];\r\n\r\n		if ( renderItem !== undefined ) {\r\n\r\n			renderItem.id = object.id;\r\n			renderItem.object = object;\r\n			renderItem.geometry = geometry;\r\n			renderItem.material = material;\r\n			renderItem.z = _vector3.z;\r\n			renderItem.group = group;\r\n\r\n		} else {\r\n\r\n			renderItem = {\r\n				id: object.id,\r\n				object: object,\r\n				geometry: geometry,\r\n				material: material,\r\n				z: _vector3.z,\r\n				group: group\r\n			};\r\n\r\n			// assert( index === array.length );\r\n			array.push( renderItem );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function projectObject( object, camera ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		if ( object.layers.test( camera.layers ) ) {\r\n\r\n			if ( object instanceof THREE.Light ) {\r\n\r\n				lights.push( object );\r\n\r\n			} else if ( object instanceof THREE.Sprite ) {\r\n\r\n				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n					sprites.push( object );\r\n\r\n				}\r\n\r\n			} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n				lensFlares.push( object );\r\n\r\n			} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n				if ( _this.sortObjects === true ) {\r\n\r\n					_vector3.setFromMatrixPosition( object.matrixWorld );\r\n					_vector3.applyProjection( _projScreenMatrix );\r\n\r\n				}\r\n\r\n				pushRenderItem( object, null, object.material, _vector3.z, null );\r\n\r\n			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n				if ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n					object.skeleton.update();\r\n\r\n				}\r\n\r\n				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n					var material = object.material;\r\n\r\n					if ( material.visible === true ) {\r\n\r\n						if ( _this.sortObjects === true ) {\r\n\r\n							_vector3.setFromMatrixPosition( object.matrixWorld );\r\n							_vector3.applyProjection( _projScreenMatrix );\r\n\r\n						}\r\n\r\n						var geometry = objects.update( object );\r\n\r\n						if ( material instanceof THREE.MultiMaterial ) {\r\n\r\n							var groups = geometry.groups;\r\n							var materials = material.materials;\r\n\r\n							for ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n								var group = groups[ i ];\r\n								var groupMaterial = materials[ group.materialIndex ];\r\n\r\n								if ( groupMaterial.visible === true ) {\r\n\r\n									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n								}\r\n\r\n							}\r\n\r\n						} else {\r\n\r\n							pushRenderItem( object, geometry, material, _vector3.z, null );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var children = object.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			projectObject( children[ i ], camera );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\r\n		for ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n			var renderItem = renderList[ i ];\r\n\r\n			var object = renderItem.object;\r\n			var geometry = renderItem.geometry;\r\n			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n			var group = renderItem.group;\r\n\r\n			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n			if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n				setMaterial( material );\r\n\r\n				var program = setProgram( camera, fog, material, object );\r\n\r\n				_currentGeometryProgram = '';\r\n\r\n				object.render( function ( object ) {\r\n\r\n					_this.renderBufferImmediate( object, program, material );\r\n\r\n				} );\r\n\r\n			} else {\r\n\r\n				_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function initMaterial( material, fog, object ) {\r\n\r\n		var materialProperties = properties.get( material );\r\n\r\n		var parameters = programCache.getParameters( material, _lights, fog, object );\r\n		var code = programCache.getProgramCode( material, parameters );\r\n\r\n		var program = materialProperties.program;\r\n		var programChange = true;\r\n\r\n		if ( program === undefined ) {\r\n\r\n			// new material\r\n			material.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n		} else if ( program.code !== code ) {\r\n\r\n			// changed glsl or parameters\r\n			releaseMaterialProgramReference( material );\r\n\r\n		} else if ( parameters.shaderID !== undefined ) {\r\n\r\n			// same glsl and uniform list\r\n			return;\r\n\r\n		} else {\r\n\r\n			// only rebuild uniform list\r\n			programChange = false;\r\n\r\n		}\r\n\r\n		if ( programChange ) {\r\n\r\n			if ( parameters.shaderID ) {\r\n\r\n				var shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\r\n				materialProperties.__webglShader = {\r\n					name: material.type,\r\n					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n					vertexShader: shader.vertexShader,\r\n					fragmentShader: shader.fragmentShader\r\n				};\r\n\r\n			} else {\r\n\r\n				materialProperties.__webglShader = {\r\n					name: material.type,\r\n					uniforms: material.uniforms,\r\n					vertexShader: material.vertexShader,\r\n					fragmentShader: material.fragmentShader\r\n				};\r\n\r\n			}\r\n\r\n			material.__webglShader = materialProperties.__webglShader;\r\n\r\n			program = programCache.acquireProgram( material, parameters, code );\r\n\r\n			materialProperties.program = program;\r\n			material.program = program;\r\n\r\n		}\r\n\r\n		var attributes = program.getAttributes();\r\n\r\n		if ( material.morphTargets ) {\r\n\r\n			material.numSupportedMorphTargets = 0;\r\n\r\n			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n				if ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n					material.numSupportedMorphTargets ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( material.morphNormals ) {\r\n\r\n			material.numSupportedMorphNormals = 0;\r\n\r\n			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n				if ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n					material.numSupportedMorphNormals ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		materialProperties.uniformsList = [];\r\n\r\n		var uniforms = materialProperties.__webglShader.uniforms,\r\n			uniformLocations = materialProperties.program.getUniforms();\r\n\r\n		for ( var u in uniforms ) {\r\n\r\n			var location = uniformLocations[ u ];\r\n\r\n			if ( location ) {\r\n\r\n				materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( material instanceof THREE.MeshPhongMaterial ||\r\n				material instanceof THREE.MeshLambertMaterial ||\r\n				material instanceof THREE.MeshStandardMaterial ||\r\n				material.lights ) {\r\n\r\n			// store the light setup it was created for\r\n\r\n			materialProperties.lightsHash = _lights.hash;\r\n\r\n			// wire up the material to this renderer's lighting state\r\n\r\n			uniforms.ambientLightColor.value = _lights.ambient;\r\n			uniforms.directionalLights.value = _lights.directional;\r\n			uniforms.spotLights.value = _lights.spot;\r\n			uniforms.pointLights.value = _lights.point;\r\n			uniforms.hemisphereLights.value = _lights.hemi;\r\n\r\n			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n			uniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n			uniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\r\n		}\r\n\r\n		// detect dynamic uniforms\r\n\r\n		materialProperties.hasDynamicUniforms = false;\r\n\r\n		for ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {\r\n\r\n			var uniform = materialProperties.uniformsList[ j ][ 0 ];\r\n\r\n			if ( uniform.dynamic === true ) {\r\n\r\n				materialProperties.hasDynamicUniforms = true;\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setMaterial( material ) {\r\n\r\n		setMaterialFaces( material );\r\n\r\n		if ( material.transparent === true ) {\r\n\r\n			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\r\n		} else {\r\n\r\n			state.setBlending( THREE.NoBlending );\r\n\r\n		}\r\n\r\n		state.setDepthFunc( material.depthFunc );\r\n		state.setDepthTest( material.depthTest );\r\n		state.setDepthWrite( material.depthWrite );\r\n		state.setColorWrite( material.colorWrite );\r\n		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n	}\r\n\r\n	function setMaterialFaces( material ) {\r\n\r\n		material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n		state.setFlipSided( material.side === THREE.BackSide );\r\n\r\n	}\r\n\r\n	function setProgram( camera, fog, material, object ) {\r\n\r\n		_usedTextureUnits = 0;\r\n\r\n		var materialProperties = properties.get( material );\r\n\r\n		if ( materialProperties.program === undefined ) {\r\n\r\n			material.needsUpdate = true;\r\n\r\n		}\r\n\r\n		if ( materialProperties.lightsHash !== undefined &&\r\n			materialProperties.lightsHash !== _lights.hash ) {\r\n\r\n			material.needsUpdate = true;\r\n\r\n		}\r\n\r\n		if ( material.needsUpdate ) {\r\n\r\n			initMaterial( material, fog, object );\r\n			material.needsUpdate = false;\r\n\r\n		}\r\n\r\n		var refreshProgram = false;\r\n		var refreshMaterial = false;\r\n		var refreshLights = false;\r\n\r\n		var program = materialProperties.program,\r\n			p_uniforms = program.getUniforms(),\r\n			m_uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n		if ( program.id !== _currentProgram ) {\r\n\r\n			_gl.useProgram( program.program );\r\n			_currentProgram = program.id;\r\n\r\n			refreshProgram = true;\r\n			refreshMaterial = true;\r\n			refreshLights = true;\r\n\r\n		}\r\n\r\n		if ( material.id !== _currentMaterialId ) {\r\n\r\n			_currentMaterialId = material.id;\r\n\r\n			refreshMaterial = true;\r\n\r\n		}\r\n\r\n		if ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n			if ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n			}\r\n\r\n\r\n			if ( camera !== _currentCamera ) {\r\n\r\n				_currentCamera = camera;\r\n\r\n				// lighting uniforms depend on the camera so enforce an update\r\n				// now, in case this material supports lights - or later, when\r\n				// the next material that does gets activated:\r\n\r\n				refreshMaterial = true;		// set to true on material change\r\n				refreshLights = true;		// remains set until update done\r\n\r\n			}\r\n\r\n			// load material specific uniforms\r\n			// (shader material also gets them for the sake of genericity)\r\n\r\n			if ( material instanceof THREE.ShaderMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshStandardMaterial ||\r\n				 material.envMap ) {\r\n\r\n				if ( p_uniforms.cameraPosition !== undefined ) {\r\n\r\n					_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.MeshStandardMaterial ||\r\n				 material instanceof THREE.ShaderMaterial ||\r\n				 material.skinning ) {\r\n\r\n				if ( p_uniforms.viewMatrix !== undefined ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// skinning uniforms must be set even if material didn't change\r\n		// auto-setting of texture unit for bone texture must go before other textures\r\n		// not sure why, but otherwise weird things happen\r\n\r\n		if ( material.skinning ) {\r\n\r\n			if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n			}\r\n\r\n			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n			}\r\n\r\n			if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n				if ( p_uniforms.boneTexture !== undefined ) {\r\n\r\n					var textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n					_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureWidth !== undefined ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureHeight !== undefined ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n				}\r\n\r\n			} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n				if ( p_uniforms.boneGlobalMatrices !== undefined ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( refreshMaterial ) {\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshStandardMaterial ||\r\n				 material.lights ) {\r\n\r\n				// the current material requires lighting info\r\n\r\n				// note: all lighting uniforms are always set correctly\r\n				// they simply reference the renderer's state for their\r\n				// values\r\n				//\r\n				// use the current material's .needsUpdate flags to set\r\n				// the GL state when required\r\n\r\n				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n			}\r\n\r\n			// refresh uniforms common to several materials\r\n\r\n			if ( fog && material.fog ) {\r\n\r\n				refreshUniformsFog( m_uniforms, fog );\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n				refreshUniformsCommon( m_uniforms, material );\r\n\r\n			}\r\n\r\n			// refresh single material specific uniforms\r\n\r\n			if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n				refreshUniformsDash( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.PointsMaterial ) {\r\n\r\n				refreshUniformsPoints( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n				refreshUniformsLambert( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n				refreshUniformsPhong( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n				refreshUniformsStandard( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n				m_uniforms.mNear.value = camera.near;\r\n				m_uniforms.mFar.value = camera.far;\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			}\r\n\r\n			// load common uniforms\r\n\r\n			loadUniformsGeneric( materialProperties.uniformsList );\r\n\r\n		}\r\n\r\n		loadUniformsMatrices( p_uniforms, object );\r\n\r\n		if ( p_uniforms.modelMatrix !== undefined ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n		}\r\n\r\n		if ( materialProperties.hasDynamicUniforms === true ) {\r\n\r\n			updateDynamicUniforms( materialProperties.uniformsList, object, camera );\r\n\r\n		}\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n	function updateDynamicUniforms ( uniforms, object, camera ) {\r\n\r\n		var dynamicUniforms = [];\r\n\r\n		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n			var uniform = uniforms[ j ][ 0 ];\r\n			var onUpdateCallback = uniform.onUpdateCallback;\r\n\r\n			if ( onUpdateCallback !== undefined ) {\r\n\r\n				onUpdateCallback.bind( uniform )( object, camera );\r\n				dynamicUniforms.push( uniforms[ j ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		loadUniformsGeneric( dynamicUniforms );\r\n\r\n	}\r\n\r\n	// Uniforms (refresh uniforms objects)\r\n\r\n	function refreshUniformsCommon ( uniforms, material ) {\r\n\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n		uniforms.diffuse.value = material.color;\r\n\r\n		if ( material.emissive ) {\r\n\r\n			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n		}\r\n\r\n		uniforms.map.value = material.map;\r\n		uniforms.specularMap.value = material.specularMap;\r\n		uniforms.alphaMap.value = material.alphaMap;\r\n\r\n		if ( material.aoMap ) {\r\n\r\n			uniforms.aoMap.value = material.aoMap;\r\n			uniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n		}\r\n\r\n		// uv repeat and offset setting priorities\r\n		// 1. color map\r\n		// 2. specular map\r\n		// 3. normal map\r\n		// 4. bump map\r\n		// 5. alpha map\r\n		// 6. emissive map\r\n\r\n		var uvScaleMap;\r\n\r\n		if ( material.map ) {\r\n\r\n			uvScaleMap = material.map;\r\n\r\n		} else if ( material.specularMap ) {\r\n\r\n			uvScaleMap = material.specularMap;\r\n\r\n		} else if ( material.displacementMap ) {\r\n\r\n			uvScaleMap = material.displacementMap;\r\n\r\n		} else if ( material.normalMap ) {\r\n\r\n			uvScaleMap = material.normalMap;\r\n\r\n		} else if ( material.bumpMap ) {\r\n\r\n			uvScaleMap = material.bumpMap;\r\n\r\n		} else if ( material.roughnessMap ) {\r\n\r\n			uvScaleMap = material.roughnessMap;\r\n\r\n		} else if ( material.metalnessMap ) {\r\n\r\n			uvScaleMap = material.metalnessMap;\r\n\r\n		} else if ( material.alphaMap ) {\r\n\r\n			uvScaleMap = material.alphaMap;\r\n\r\n		} else if ( material.emissiveMap ) {\r\n\r\n			uvScaleMap = material.emissiveMap;\r\n\r\n		}\r\n\r\n		if ( uvScaleMap !== undefined ) {\r\n\r\n			if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\r\n				uvScaleMap = uvScaleMap.texture;\r\n\r\n			}\r\n\r\n			var offset = uvScaleMap.offset;\r\n			var repeat = uvScaleMap.repeat;\r\n\r\n			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n		}\r\n\r\n		uniforms.envMap.value = material.envMap;\r\n		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n		uniforms.reflectivity.value = material.reflectivity;\r\n		uniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n	}\r\n\r\n	function refreshUniformsLine ( uniforms, material ) {\r\n\r\n		uniforms.diffuse.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n	}\r\n\r\n	function refreshUniformsDash ( uniforms, material ) {\r\n\r\n		uniforms.dashSize.value = material.dashSize;\r\n		uniforms.totalSize.value = material.dashSize + material.gapSize;\r\n		uniforms.scale.value = material.scale;\r\n\r\n	}\r\n\r\n	function refreshUniformsPoints ( uniforms, material ) {\r\n\r\n		uniforms.diffuse.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n		uniforms.size.value = material.size * _pixelRatio;\r\n		uniforms.scale.value = _canvas.clientHeight / 2.0; // TODO: Cache this.\r\n\r\n		uniforms.map.value = material.map;\r\n\r\n		if ( material.map !== null ) {\r\n\r\n			var offset = material.map.offset;\r\n			var repeat = material.map.repeat;\r\n\r\n			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsFog ( uniforms, fog ) {\r\n\r\n		uniforms.fogColor.value = fog.color;\r\n\r\n		if ( fog instanceof THREE.Fog ) {\r\n\r\n			uniforms.fogNear.value = fog.near;\r\n			uniforms.fogFar.value = fog.far;\r\n\r\n		} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n			uniforms.fogDensity.value = fog.density;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsLambert ( uniforms, material ) {\r\n\r\n		if ( material.lightMap ) {\r\n\r\n			uniforms.lightMap.value = material.lightMap;\r\n			uniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n		}\r\n\r\n		if ( material.emissiveMap ) {\r\n\r\n			uniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsPhong ( uniforms, material ) {\r\n\r\n		uniforms.specular.value = material.specular;\r\n		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\r\n		if ( material.lightMap ) {\r\n\r\n			uniforms.lightMap.value = material.lightMap;\r\n			uniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n		}\r\n\r\n		if ( material.emissiveMap ) {\r\n\r\n			uniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n		}\r\n\r\n		if ( material.bumpMap ) {\r\n\r\n			uniforms.bumpMap.value = material.bumpMap;\r\n			uniforms.bumpScale.value = material.bumpScale;\r\n\r\n		}\r\n\r\n		if ( material.normalMap ) {\r\n\r\n			uniforms.normalMap.value = material.normalMap;\r\n			uniforms.normalScale.value.copy( material.normalScale );\r\n\r\n		}\r\n\r\n		if ( material.displacementMap ) {\r\n\r\n			uniforms.displacementMap.value = material.displacementMap;\r\n			uniforms.displacementScale.value = material.displacementScale;\r\n			uniforms.displacementBias.value = material.displacementBias;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsStandard ( uniforms, material ) {\r\n\r\n		uniforms.roughness.value = material.roughness;\r\n		uniforms.metalness.value = material.metalness;\r\n\r\n		if ( material.roughnessMap ) {\r\n\r\n			uniforms.roughnessMap.value = material.roughnessMap;\r\n\r\n		}\r\n\r\n		if ( material.metalnessMap ) {\r\n\r\n			uniforms.metalnessMap.value = material.metalnessMap;\r\n\r\n		}\r\n\r\n		if ( material.lightMap ) {\r\n\r\n			uniforms.lightMap.value = material.lightMap;\r\n			uniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n		}\r\n\r\n		if ( material.emissiveMap ) {\r\n\r\n			uniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n		}\r\n\r\n		if ( material.bumpMap ) {\r\n\r\n			uniforms.bumpMap.value = material.bumpMap;\r\n			uniforms.bumpScale.value = material.bumpScale;\r\n\r\n		}\r\n\r\n		if ( material.normalMap ) {\r\n\r\n			uniforms.normalMap.value = material.normalMap;\r\n			uniforms.normalScale.value.copy( material.normalScale );\r\n\r\n		}\r\n\r\n		if ( material.displacementMap ) {\r\n\r\n			uniforms.displacementMap.value = material.displacementMap;\r\n			uniforms.displacementScale.value = material.displacementScale;\r\n			uniforms.displacementBias.value = material.displacementBias;\r\n\r\n		}\r\n\r\n		if ( material.envMap ) {\r\n\r\n			//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n			uniforms.envMapIntensity.value = material.envMapIntensity;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n	function markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n		uniforms.ambientLightColor.needsUpdate = value;\r\n\r\n		uniforms.directionalLights.needsUpdate = value;\r\n		uniforms.pointLights.needsUpdate = value;\r\n		uniforms.spotLights.needsUpdate = value;\r\n		uniforms.hemisphereLights.needsUpdate = value;\r\n\r\n	}\r\n\r\n	// Uniforms (load to GPU)\r\n\r\n	function loadUniformsMatrices ( uniforms, object ) {\r\n\r\n		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );\r\n\r\n		if ( uniforms.normalMatrix ) {\r\n\r\n			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function getTextureUnit() {\r\n\r\n		var textureUnit = _usedTextureUnits;\r\n\r\n		if ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n		}\r\n\r\n		_usedTextureUnits += 1;\r\n\r\n		return textureUnit;\r\n\r\n	}\r\n\r\n	function loadUniformsGeneric ( uniforms ) {\r\n\r\n		var texture, textureUnit;\r\n\r\n		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n			var uniform = uniforms[ j ][ 0 ];\r\n\r\n			// needsUpdate property is not added to all uniforms.\r\n			if ( uniform.needsUpdate === false ) continue;\r\n\r\n			var type = uniform.type;\r\n			var value = uniform.value;\r\n			var location = uniforms[ j ][ 1 ];\r\n\r\n			switch ( type ) {\r\n\r\n				case '1i':\r\n					_gl.uniform1i( location, value );\r\n					break;\r\n\r\n				case '1f':\r\n					_gl.uniform1f( location, value );\r\n					break;\r\n\r\n				case '2f':\r\n					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n					break;\r\n\r\n				case '3f':\r\n					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n					break;\r\n\r\n				case '4f':\r\n					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n					break;\r\n\r\n				case '1iv':\r\n					_gl.uniform1iv( location, value );\r\n					break;\r\n\r\n				case '3iv':\r\n					_gl.uniform3iv( location, value );\r\n					break;\r\n\r\n				case '1fv':\r\n					_gl.uniform1fv( location, value );\r\n					break;\r\n\r\n				case '2fv':\r\n					_gl.uniform2fv( location, value );\r\n					break;\r\n\r\n				case '3fv':\r\n					_gl.uniform3fv( location, value );\r\n					break;\r\n\r\n				case '4fv':\r\n					_gl.uniform4fv( location, value );\r\n					break;\r\n\r\n				case 'Matrix2fv':\r\n					_gl.uniformMatrix2fv( location, false, value );\r\n					break;\r\n\r\n				case 'Matrix3fv':\r\n					_gl.uniformMatrix3fv( location, false, value );\r\n					break;\r\n\r\n				case 'Matrix4fv':\r\n					_gl.uniformMatrix4fv( location, false, value );\r\n					break;\r\n\r\n				//\r\n\r\n				case 'i':\r\n\r\n					// single integer\r\n					_gl.uniform1i( location, value );\r\n\r\n					break;\r\n\r\n				case 'f':\r\n\r\n					// single float\r\n					_gl.uniform1f( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2':\r\n\r\n					// single THREE.Vector2\r\n					_gl.uniform2f( location, value.x, value.y );\r\n\r\n					break;\r\n\r\n				case 'v3':\r\n\r\n					// single THREE.Vector3\r\n					_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n					break;\r\n\r\n				case 'v4':\r\n\r\n					// single THREE.Vector4\r\n					_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n					break;\r\n\r\n				case 'c':\r\n\r\n					// single THREE.Color\r\n					_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n					break;\r\n\r\n				/*\r\n				case 's':\r\n\r\n					// TODO: Optimize this.\r\n					for( var propertyName in uniform.properties ) {\r\n\r\n						var property = uniform.properties[ propertyName ];\r\n						var locationProperty =  location[ propertyName ];\r\n						var valueProperty = value[ propertyName ];\r\n\r\n						switch( property.type ) {\r\n							case 'i':\r\n								_gl.uniform1i( locationProperty, valueProperty );\r\n								break;\r\n							case 'f':\r\n								_gl.uniform1f( locationProperty, valueProperty );\r\n								break;\r\n							case 'v2':\r\n								_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );\r\n								break;\r\n							case 'v3':\r\n								_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );\r\n								break;\r\n							case 'v4':\r\n								_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );\r\n								break;\r\n							case 'c':\r\n								_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );\r\n								break;\r\n						};\r\n\r\n					}\r\n\r\n					break;\r\n				*/\r\n\r\n				case 'sa':\r\n\r\n					// TODO: Optimize this.\r\n					for ( var i = 0; i < value.length; i ++ ) {\r\n\r\n						for ( var propertyName in uniform.properties ) {\r\n\r\n							var property = uniform.properties[ propertyName ];\r\n							var locationProperty =  location[ i ][ propertyName ];\r\n							var valueProperty = value[ i ][ propertyName ];\r\n\r\n							switch ( property.type ) {\r\n								case 'i':\r\n									_gl.uniform1i( locationProperty, valueProperty );\r\n									break;\r\n								case 'f':\r\n									_gl.uniform1f( locationProperty, valueProperty );\r\n									break;\r\n								case 'v2':\r\n									_gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );\r\n									break;\r\n								case 'v3':\r\n									_gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );\r\n									break;\r\n								case 'v4':\r\n									_gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );\r\n									break;\r\n								case 'c':\r\n									_gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );\r\n									break;\r\n								case 'm4':\r\n									_gl.uniformMatrix4fv( locationProperty, false, valueProperty.elements );\r\n									break;\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'iv1':\r\n\r\n					// flat array of integers (JS or typed array)\r\n					_gl.uniform1iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'iv':\r\n\r\n					// flat array of integers with 3 x N size (JS or typed array)\r\n					_gl.uniform3iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv1':\r\n\r\n					// flat array of floats (JS or typed array)\r\n					_gl.uniform1fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv':\r\n\r\n					// flat array of floats with 3 x N size (JS or typed array)\r\n					_gl.uniform3fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2v':\r\n\r\n					// array of THREE.Vector2\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 2 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {\r\n\r\n						uniform._array[ i2 + 0 ] = value[ i ].x;\r\n						uniform._array[ i2 + 1 ] = value[ i ].y;\r\n\r\n					}\r\n\r\n					_gl.uniform2fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v3v':\r\n\r\n					// array of THREE.Vector3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 3 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {\r\n\r\n						uniform._array[ i3 + 0 ] = value[ i ].x;\r\n						uniform._array[ i3 + 1 ] = value[ i ].y;\r\n						uniform._array[ i3 + 2 ] = value[ i ].z;\r\n\r\n					}\r\n\r\n					_gl.uniform3fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v4v':\r\n\r\n					// array of THREE.Vector4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 4 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {\r\n\r\n						uniform._array[ i4 + 0 ] = value[ i ].x;\r\n						uniform._array[ i4 + 1 ] = value[ i ].y;\r\n						uniform._array[ i4 + 2 ] = value[ i ].z;\r\n						uniform._array[ i4 + 3 ] = value[ i ].w;\r\n\r\n					}\r\n\r\n					_gl.uniform4fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm2':\r\n\r\n					// single THREE.Matrix2\r\n					_gl.uniformMatrix2fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm3':\r\n\r\n					// single THREE.Matrix3\r\n					_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm3v':\r\n\r\n					// array of THREE.Matrix3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 9 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm4':\r\n\r\n					// single THREE.Matrix4\r\n					_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm4v':\r\n\r\n					// array of THREE.Matrix4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 16 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 't':\r\n\r\n					// single THREE.Texture (2d or cube)\r\n\r\n					texture = value;\r\n					textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( location, textureUnit );\r\n\r\n					if ( ! texture ) continue;\r\n\r\n					if ( texture instanceof THREE.CubeTexture ||\r\n						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n						// CompressedTexture can have Array in image :/\r\n\r\n						setCubeTexture( texture, textureUnit );\r\n\r\n					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n						setCubeTextureDynamic( texture.texture, textureUnit );\r\n\r\n					} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\r\n						_this.setTexture( texture.texture, textureUnit );\r\n\r\n					} else {\r\n\r\n						_this.setTexture( texture, textureUnit );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'tv':\r\n\r\n					// array of THREE.Texture (2d or cube)\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = [];\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						uniform._array[ i ] = getTextureUnit();\r\n\r\n					}\r\n\r\n					_gl.uniform1iv( location, uniform._array );\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						texture = uniform.value[ i ];\r\n						textureUnit = uniform._array[ i ];\r\n\r\n						if ( ! texture ) continue;\r\n\r\n						if ( texture instanceof THREE.CubeTexture ||\r\n							 ( texture.image instanceof Array && texture.image.length === 6 ) ) {\r\n\r\n							// CompressedTexture can have Array in image :/\r\n\r\n							setCubeTexture( texture, textureUnit );\r\n\r\n						} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\r\n							_this.setTexture( texture.texture, textureUnit );\r\n\r\n						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n							setCubeTextureDynamic( texture.texture, textureUnit );\r\n\r\n						} else {\r\n\r\n							_this.setTexture( texture, textureUnit );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setupLights ( lights, camera ) {\r\n\r\n		var l, ll, light,\r\n		r = 0, g = 0, b = 0,\r\n		color,\r\n		intensity,\r\n		distance,\r\n\r\n		viewMatrix = camera.matrixWorldInverse,\r\n\r\n		directionalLength = 0,\r\n		pointLength = 0,\r\n		spotLength = 0,\r\n		hemiLength = 0,\r\n\r\n		shadowsLength = 0;\r\n\r\n		_lights.shadowsPointLight = 0;\r\n\r\n		for ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			light = lights[ l ];\r\n\r\n			color = light.color;\r\n			intensity = light.intensity;\r\n			distance = light.distance;\r\n\r\n			if ( light instanceof THREE.AmbientLight ) {\r\n\r\n				r += color.r * intensity;\r\n				g += color.g * intensity;\r\n				b += color.b * intensity;\r\n\r\n			} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n				var uniforms = lightCache.get( light );\r\n\r\n				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n				uniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				uniforms.direction.sub( _vector3 );\r\n				uniforms.direction.transformDirection( viewMatrix );\r\n\r\n				uniforms.shadow = light.castShadow;\r\n\r\n				if ( light.castShadow ) {\r\n\r\n					uniforms.shadowBias = light.shadow.bias;\r\n					uniforms.shadowRadius = light.shadow.radius;\r\n					uniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n					_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n				}\r\n\r\n				_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;\r\n				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n				_lights.directional[ directionalLength ++ ] = uniforms;\r\n\r\n			} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n				var uniforms = lightCache.get( light );\r\n\r\n				uniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n				uniforms.position.applyMatrix4( viewMatrix );\r\n\r\n				uniforms.color.copy( color ).multiplyScalar( intensity );\r\n				uniforms.distance = distance;\r\n\r\n				uniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				uniforms.direction.sub( _vector3 );\r\n				uniforms.direction.transformDirection( viewMatrix );\r\n\r\n				uniforms.angleCos = Math.cos( light.angle );\r\n				uniforms.exponent = light.exponent;\r\n				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n				uniforms.shadow = light.castShadow;\r\n\r\n				if ( light.castShadow ) {\r\n\r\n					uniforms.shadowBias = light.shadow.bias;\r\n					uniforms.shadowRadius = light.shadow.radius;\r\n					uniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n					_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n				}\r\n\r\n				_lights.spotShadowMap[ spotLength ] = light.shadow.map;\r\n				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n				_lights.spot[ spotLength ++ ] = uniforms;\r\n\r\n			} else if ( light instanceof THREE.PointLight ) {\r\n\r\n				var uniforms = lightCache.get( light );\r\n\r\n				uniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n				uniforms.position.applyMatrix4( viewMatrix );\r\n\r\n				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n				uniforms.distance = light.distance;\r\n				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n				uniforms.shadow = light.castShadow;\r\n\r\n				if ( light.castShadow ) {\r\n\r\n					uniforms.shadowBias = light.shadow.bias;\r\n					uniforms.shadowRadius = light.shadow.radius;\r\n					uniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n					_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n				}\r\n\r\n				_lights.pointShadowMap[ pointLength ] = light.shadow.map;\r\n\r\n				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\r\n					_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\r\n				}\r\n\r\n				// for point lights we set the shadow matrix to be a translation-only matrix\r\n				// equal to inverse of the light's position\r\n				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\r\n				_lights.point[ pointLength ++ ] = uniforms;\r\n\r\n			} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n				var uniforms = lightCache.get( light );\r\n\r\n				uniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n				uniforms.direction.transformDirection( viewMatrix );\r\n				uniforms.direction.normalize();\r\n\r\n				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\r\n				_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		_lights.ambient[ 0 ] = r;\r\n		_lights.ambient[ 1 ] = g;\r\n		_lights.ambient[ 2 ] = b;\r\n\r\n		_lights.directional.length = directionalLength;\r\n		_lights.spot.length = spotLength;\r\n		_lights.point.length = pointLength;\r\n		_lights.hemi.length = hemiLength;\r\n\r\n		_lights.shadows.length = shadowsLength;\r\n\r\n		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;\r\n\r\n	}\r\n\r\n	// GL state setting\r\n\r\n	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n		if ( cullFace === THREE.CullFaceNone ) {\r\n\r\n			state.disable( _gl.CULL_FACE );\r\n\r\n		} else {\r\n\r\n			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n				_gl.frontFace( _gl.CW );\r\n\r\n			} else {\r\n\r\n				_gl.frontFace( _gl.CCW );\r\n\r\n			}\r\n\r\n			if ( cullFace === THREE.CullFaceBack ) {\r\n\r\n				_gl.cullFace( _gl.BACK );\r\n\r\n			} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n				_gl.cullFace( _gl.FRONT );\r\n\r\n			} else {\r\n\r\n				_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n			}\r\n\r\n			state.enable( _gl.CULL_FACE );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Textures\r\n\r\n	function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\r\n		var extension;\r\n\r\n		if ( isPowerOfTwoImage ) {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n		} else {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\r\n			}\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n		if ( extension ) {\r\n\r\n			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\r\n			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n				properties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function uploadTexture( textureProperties, texture, slot ) {\r\n\r\n		if ( textureProperties.__webglInit === undefined ) {\r\n\r\n			textureProperties.__webglInit = true;\r\n\r\n			texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n			textureProperties.__webglTexture = _gl.createTexture();\r\n\r\n			_infoMemory.textures ++;\r\n\r\n		}\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\r\n			image = makePowerOfTwo( image );\r\n\r\n		}\r\n\r\n		var isPowerOfTwoImage = isPowerOfTwo( image ),\r\n		glFormat = paramThreeToGL( texture.format ),\r\n		glType = paramThreeToGL( texture.type );\r\n\r\n		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\r\n		var mipmap, mipmaps = texture.mipmaps;\r\n\r\n		if ( texture instanceof THREE.DataTexture ) {\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n			}\r\n\r\n		} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n				mipmap = mipmaps[ i ];\r\n\r\n				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n					} else {\r\n\r\n						console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// regular Texture (image, video, canvas)\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n		textureProperties.__version = texture.version;\r\n\r\n		if ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n	}\r\n\r\n	this.setTexture = function ( texture, slot ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n			var image = texture.image;\r\n\r\n			if ( image === undefined ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n				return;\r\n\r\n			}\r\n\r\n			if ( image.complete === false ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n				return;\r\n\r\n			}\r\n\r\n			uploadTexture( textureProperties, texture, slot );\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n	};\r\n\r\n	function clampToMaxSize ( image, maxSize ) {\r\n\r\n		if ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n			// Warning: Scaling through the canvas will only work with images that use\r\n			// premultiplied alpha.\r\n\r\n			var scale = maxSize / Math.max( image.width, image.height );\r\n\r\n			var canvas = document.createElement( 'canvas' );\r\n			canvas.width = Math.floor( image.width * scale );\r\n			canvas.height = Math.floor( image.height * scale );\r\n\r\n			var context = canvas.getContext( '2d' );\r\n			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n			return canvas;\r\n\r\n		}\r\n\r\n		return image;\r\n\r\n	}\r\n\r\n	function isPowerOfTwo( image ) {\r\n\r\n		return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\r\n	}\r\n\r\n	function textureNeedsPowerOfTwo( texture ) {\r\n\r\n		if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n		if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n	function makePowerOfTwo( image ) {\r\n\r\n		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\r\n			var canvas = document.createElement( 'canvas' );\r\n			canvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n			canvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\r\n			var context = canvas.getContext( '2d' );\r\n			context.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n			return canvas;\r\n\r\n		}\r\n\r\n		return image;\r\n\r\n	}\r\n\r\n	function setCubeTexture ( texture, slot ) {\r\n\r\n		var textureProperties = properties.get( texture );\r\n\r\n		if ( texture.image.length === 6 ) {\r\n\r\n			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n				if ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n					texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n					textureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n					_infoMemory.textures ++;\r\n\r\n				}\r\n\r\n				state.activeTexture( _gl.TEXTURE0 + slot );\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n				var isCompressed = texture instanceof THREE.CompressedTexture;\r\n				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n				var cubeImage = [];\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n					} else {\r\n\r\n						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n					}\r\n\r\n				}\r\n\r\n				var image = cubeImage[ 0 ],\r\n				isPowerOfTwoImage = isPowerOfTwo( image ),\r\n				glFormat = paramThreeToGL( texture.format ),\r\n				glType = paramThreeToGL( texture.type );\r\n\r\n				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( ! isCompressed ) {\r\n\r\n						if ( isDataTexture ) {\r\n\r\n							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n						} else {\r\n\r\n							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						var mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n							mipmap = mipmaps[ j ];\r\n\r\n							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n								} else {\r\n\r\n									console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n								}\r\n\r\n							} else {\r\n\r\n								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\r\n					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n				}\r\n\r\n				textureProperties.__version = texture.version;\r\n\r\n				if ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n			} else {\r\n\r\n				state.activeTexture( _gl.TEXTURE0 + slot );\r\n				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setCubeTextureDynamic ( texture, slot ) {\r\n\r\n		state.activeTexture( _gl.TEXTURE0 + slot );\r\n		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n	}\r\n\r\n	// Render targets\r\n\r\n	// Setup storage for target texture and bind it to correct framebuffer\r\n	function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\r\n		var glFormat = paramThreeToGL( renderTarget.texture.format );\r\n		var glType = paramThreeToGL( renderTarget.texture.type );\r\n		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n	}\r\n\r\n	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n	function setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\r\n		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		} else {\r\n\r\n			// FIXME: We don't support !depth !stencil\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n		}\r\n\r\n		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\r\n	}\r\n\r\n	// Setup GL resources for a non-texture depth buffer\r\n	function setupDepthRenderbuffer( renderTarget ) {\r\n\r\n		var renderTargetProperties = properties.get( renderTarget );\r\n\r\n		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n		if ( isCube ) {\r\n\r\n			renderTargetProperties.__webglDepthbuffer = [];\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n				renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n			renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n			setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\r\n		}\r\n\r\n		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n	}\r\n\r\n	// Set up GL resources for the render target\r\n	function setupRenderTarget( renderTarget ) {\r\n\r\n		var renderTargetProperties = properties.get( renderTarget );\r\n		var textureProperties = properties.get( renderTarget.texture );\r\n\r\n		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n		textureProperties.__webglTexture = _gl.createTexture();\r\n\r\n		_infoMemory.textures ++;\r\n\r\n		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n		var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\r\n		// Setup framebuffer\r\n\r\n		if ( isCube ) {\r\n\r\n			renderTargetProperties.__webglFramebuffer = [];\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n		}\r\n\r\n		// Setup color buffer\r\n\r\n		if ( isCube ) {\r\n\r\n			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\r\n			}\r\n\r\n			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n		} else {\r\n\r\n			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\r\n			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n			state.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n		}\r\n\r\n		// Setup depth and stencil buffers\r\n\r\n		if ( renderTarget.depthBuffer ) {\r\n\r\n			setupDepthRenderbuffer( renderTarget );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setRenderTarget = function ( renderTarget ) {\r\n\r\n		_currentRenderTarget = renderTarget;\r\n\r\n		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n			setupRenderTarget( renderTarget );\r\n\r\n		}\r\n\r\n		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n		var framebuffer;\r\n\r\n		if ( renderTarget ) {\r\n\r\n			var renderTargetProperties = properties.get( renderTarget );\r\n\r\n			if ( isCube ) {\r\n\r\n				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n			} else {\r\n\r\n				framebuffer = renderTargetProperties.__webglFramebuffer;\r\n\r\n			}\r\n\r\n			_currentScissor.copy( renderTarget.scissor );\r\n			_currentScissorTest = renderTarget.scissorTest;\r\n\r\n			_currentViewport.copy( renderTarget.viewport );\r\n\r\n		} else {\r\n\r\n			framebuffer = null;\r\n\r\n			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n			_currentScissorTest = _scissorTest;\r\n\r\n			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\r\n		}\r\n\r\n		if ( _currentFramebuffer !== framebuffer ) {\r\n\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n			_currentFramebuffer = framebuffer;\r\n\r\n		}\r\n\r\n		state.scissor( _currentScissor );\r\n		state.setScissorTest( _currentScissorTest );\r\n\r\n		state.viewport( _currentViewport );\r\n\r\n		if ( isCube ) {\r\n\r\n			var textureProperties = properties.get( renderTarget.texture );\r\n			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\r\n			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n		if ( framebuffer ) {\r\n\r\n			var restore = false;\r\n\r\n			if ( framebuffer !== _currentFramebuffer ) {\r\n\r\n				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n				restore = true;\r\n\r\n			}\r\n\r\n			try {\r\n\r\n				var texture = renderTarget.texture;\r\n\r\n				if ( texture.format !== THREE.RGBAFormat\r\n					&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n					return;\r\n\r\n				}\r\n\r\n				if ( texture.type !== THREE.UnsignedByteType\r\n					&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )\r\n					&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )\r\n					&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\r\n					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n					return;\r\n\r\n				}\r\n\r\n				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n					_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\r\n				} else {\r\n\r\n					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n				}\r\n\r\n			} finally {\r\n\r\n				if ( restore ) {\r\n\r\n					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function updateRenderTargetMipmap( renderTarget ) {\r\n\r\n		var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n		var texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\r\n		state.bindTexture( target, texture );\r\n		_gl.generateMipmap( target );\r\n		state.bindTexture( target, null );\r\n\r\n	}\r\n\r\n	// Fallback filters for non-power-of-2 textures\r\n\r\n	function filterFallback ( f ) {\r\n\r\n		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n			return _gl.NEAREST;\r\n\r\n		}\r\n\r\n		return _gl.LINEAR;\r\n\r\n	}\r\n\r\n	// Map three.js constants to WebGL constants\r\n\r\n	function paramThreeToGL ( p ) {\r\n\r\n		var extension;\r\n\r\n		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n		if ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n		if ( p === THREE.ByteType ) return _gl.BYTE;\r\n		if ( p === THREE.ShortType ) return _gl.SHORT;\r\n		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n		if ( p === THREE.IntType ) return _gl.INT;\r\n		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n		if ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n		extension = extensions.get( 'OES_texture_half_float' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n		}\r\n\r\n		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n		if ( p === THREE.RGBFormat ) return _gl.RGB;\r\n		if ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n		if ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n		if ( p === THREE.OneFactor ) return _gl.ONE;\r\n		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n		}\r\n\r\n		return 0;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Marius Kintel / https://github.com/kintel\r\n */\r\n\r\n/*\r\n In options, we can specify:\r\n * Texture parameters for an auto-generated target texture\r\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n*/\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	this.scissor = new THREE.Vector4( 0, 0, width, height );\r\n	this.scissorTest = false;\r\n\r\n	this.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\r\n	options = options || {};\r\n\r\n	if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\r\n	this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );\r\n\r\n	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n	constructor: THREE.WebGLRenderTarget,\r\n\r\n	setSize: function ( width, height ) {\r\n\r\n		if ( this.width !== width || this.height !== height ) {\r\n\r\n			this.width = width;\r\n			this.height = height;\r\n\r\n			this.dispose();\r\n\r\n		}\r\n\r\n		this.viewport.set( 0, 0, width, height );\r\n		this.scissor.set( 0, 0, width, height );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new this.constructor().copy( this );\r\n\r\n	},\r\n\r\n	copy: function ( source ) {\r\n\r\n		this.width = source.width;\r\n		this.height = source.height;\r\n\r\n		this.viewport.copy( source.viewport );\r\n\r\n		this.texture = source.texture.clone();\r\n\r\n		this.depthBuffer = source.depthBuffer;\r\n		this.stencilBuffer = source.stencilBuffer;\r\n\r\n		this.shareDepthFrom = source.shareDepthFrom;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n	THREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n	var mode;\r\n\r\n	function setMode( value ) {\r\n\r\n		mode = value;\r\n\r\n	}\r\n\r\n	function render( start, count ) {\r\n\r\n		_gl.drawArrays( mode, start, count );\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n	}\r\n\r\n	function renderInstances( geometry ) {\r\n\r\n		var extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var position = geometry.attributes.position;\r\n\r\n		var count = 0;\r\n\r\n		if ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			count = position.data.count;\r\n\r\n			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n		} else {\r\n\r\n			count = position.count;\r\n\r\n			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n		}\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count * geometry.maxInstancedCount;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\r\n	}\r\n\r\n	this.setMode = setMode;\r\n	this.render = render;\r\n	this.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n	var mode;\r\n\r\n	function setMode( value ) {\r\n\r\n		mode = value;\r\n\r\n	}\r\n\r\n	var type, size;\r\n\r\n	function setIndex( index ) {\r\n\r\n		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n			type = _gl.UNSIGNED_INT;\r\n			size = 4;\r\n\r\n		} else {\r\n\r\n			type = _gl.UNSIGNED_SHORT;\r\n			size = 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function render( start, count ) {\r\n\r\n		_gl.drawElements( mode, count, type, start * size );\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n	}\r\n\r\n	function renderInstances( geometry, start, count ) {\r\n\r\n		var extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n			return;\r\n\r\n		}\r\n\r\n		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\r\n		_infoRender.calls ++;\r\n		_infoRender.vertices += count * geometry.maxInstancedCount;\r\n		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n	}\r\n\r\n	this.setMode = setMode;\r\n	this.setIndex = setIndex;\r\n	this.render = render;\r\n	this.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n	var extensions = {};\r\n\r\n	this.get = function ( name ) {\r\n\r\n		if ( extensions[ name ] !== undefined ) {\r\n\r\n			return extensions[ name ];\r\n\r\n		}\r\n\r\n		var extension;\r\n\r\n		switch ( name ) {\r\n\r\n			case 'EXT_texture_filter_anisotropic':\r\n				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_s3tc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_pvrtc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_etc1':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n				break;\r\n\r\n			default:\r\n				extension = gl.getExtension( name );\r\n\r\n		}\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n		}\r\n\r\n		extensions[ name ] = extension;\r\n\r\n		return extension;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLCapabilities.js\r\n\r\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\r\n	function getMaxPrecision( precision ) {\r\n\r\n		if ( precision === 'highp' ) {\r\n\r\n			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n				return 'highp';\r\n\r\n			}\r\n\r\n			precision = 'mediump';\r\n\r\n		}\r\n\r\n		if ( precision === 'mediump' ) {\r\n\r\n			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n				return 'mediump';\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return 'lowp';\r\n\r\n	}\r\n\r\n	this.getMaxPrecision = getMaxPrecision;\r\n\r\n	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\r\n	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n	this.vertexTextures = this.maxVertexTextures > 0;\r\n	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\r\n	var _maxPrecision = getMaxPrecision( this.precision );\r\n\r\n	if ( _maxPrecision !== this.precision ) {\r\n\r\n		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n		this.precision = _maxPrecision;\r\n\r\n	}\r\n\r\n	if ( this.logarithmicDepthBuffer ) {\r\n\r\n		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLGeometries.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\r\n	var geometries = {};\r\n\r\n	function get( object ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( geometries[ geometry.id ] !== undefined ) {\r\n\r\n			return geometries[ geometry.id ];\r\n\r\n		}\r\n\r\n		geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n		var buffergeometry;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			buffergeometry = geometry;\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			if ( geometry._bufferGeometry === undefined ) {\r\n\r\n				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\r\n			}\r\n\r\n			buffergeometry = geometry._bufferGeometry;\r\n\r\n		}\r\n\r\n		geometries[ geometry.id ] = buffergeometry;\r\n\r\n		info.memory.geometries ++;\r\n\r\n		return buffergeometry;\r\n\r\n	}\r\n\r\n	function onGeometryDispose( event ) {\r\n\r\n		var geometry = event.target;\r\n		var buffergeometry = geometries[ geometry.id ];\r\n\r\n		if ( buffergeometry.index !== null ) {\r\n\r\n			deleteAttribute( buffergeometry.index );\r\n\r\n		}\r\n\r\n		deleteAttributes( buffergeometry.attributes );\r\n\r\n		geometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n		delete geometries[ geometry.id ];\r\n\r\n		// TODO\r\n\r\n		var property = properties.get( geometry );\r\n\r\n		if ( property.wireframe ) {\r\n\r\n			deleteAttribute( property.wireframe );\r\n\r\n		}\r\n\r\n		properties.delete( geometry );\r\n\r\n		var bufferproperty = properties.get( buffergeometry );\r\n\r\n		if ( bufferproperty.wireframe ) {\r\n\r\n			deleteAttribute( bufferproperty.wireframe );\r\n\r\n		}\r\n\r\n		properties.delete( buffergeometry );\r\n\r\n		//\r\n\r\n		info.memory.geometries --;\r\n\r\n	}\r\n\r\n	function getAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			return properties.get( attribute.data ).__webglBuffer;\r\n\r\n		}\r\n\r\n		return properties.get( attribute ).__webglBuffer;\r\n\r\n	}\r\n\r\n	function deleteAttribute( attribute ) {\r\n\r\n		var buffer = getAttributeBuffer( attribute );\r\n\r\n		if ( buffer !== undefined ) {\r\n\r\n			gl.deleteBuffer( buffer );\r\n			removeAttributeBuffer( attribute );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function deleteAttributes( attributes ) {\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			deleteAttribute( attributes[ name ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function removeAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			properties.delete( attribute.data );\r\n\r\n		} else {\r\n\r\n			properties.delete( attribute );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.get = get;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLLights.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLLights = function () {\r\n\r\n	var lights = {};\r\n\r\n	this.get = function ( light ) {\r\n\r\n		if ( lights[ light.id ] !== undefined ) {\r\n\r\n			return lights[ light.id ];\r\n\r\n		}\r\n\r\n		var uniforms;\r\n\r\n		switch ( light.type ) {\r\n\r\n			case 'DirectionalLight':\r\n				uniforms = {\r\n					direction: new THREE.Vector3(),\r\n					color: new THREE.Color(),\r\n\r\n					shadow: false,\r\n					shadowBias: 0,\r\n					shadowRadius: 1,\r\n					shadowMapSize: new THREE.Vector2()\r\n				};\r\n				break;\r\n\r\n			case 'SpotLight':\r\n				uniforms = {\r\n					position: new THREE.Vector3(),\r\n					direction: new THREE.Vector3(),\r\n					color: new THREE.Color(),\r\n					distance: 0,\r\n					angleCos: 0,\r\n					exponent: 0,\r\n					decay: 0,\r\n\r\n					shadow: false,\r\n					shadowBias: 0,\r\n					shadowRadius: 1,\r\n					shadowMapSize: new THREE.Vector2()\r\n				};\r\n				break;\r\n\r\n			case 'PointLight':\r\n				uniforms = {\r\n					position: new THREE.Vector3(),\r\n					color: new THREE.Color(),\r\n					distance: 0,\r\n					decay: 0,\r\n\r\n					shadow: false,\r\n					shadowBias: 0,\r\n					shadowRadius: 1,\r\n					shadowMapSize: new THREE.Vector2()\r\n				};\r\n				break;\r\n\r\n			case 'HemisphereLight':\r\n				uniforms = {\r\n					direction: new THREE.Vector3(),\r\n					skyColor: new THREE.Color(),\r\n					groundColor: new THREE.Color()\r\n				};\r\n				break;\r\n\r\n		}\r\n\r\n		lights[ light.id ] = uniforms;\r\n\r\n		return uniforms;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLObjects.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\r\n	var geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\r\n	//\r\n\r\n	function update( object ) {\r\n\r\n		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\r\n		var geometry = geometries.get( object );\r\n\r\n		if ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n			geometry.updateFromObject( object );\r\n\r\n		}\r\n\r\n		var index = geometry.index;\r\n		var attributes = geometry.attributes;\r\n\r\n		if ( index !== null ) {\r\n\r\n			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n		}\r\n\r\n		for ( var name in attributes ) {\r\n\r\n			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n		}\r\n\r\n		// morph targets\r\n\r\n		var morphAttributes = geometry.morphAttributes;\r\n\r\n		for ( var name in morphAttributes ) {\r\n\r\n			var array = morphAttributes[ name ];\r\n\r\n			for ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n				updateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	}\r\n\r\n	function updateAttribute( attribute, bufferType ) {\r\n\r\n		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\r\n		var attributeProperties = properties.get( data );\r\n\r\n		if ( attributeProperties.__webglBuffer === undefined ) {\r\n\r\n			createBuffer( attributeProperties, data, bufferType );\r\n\r\n		} else if ( attributeProperties.version !== data.version ) {\r\n\r\n			updateBuffer( attributeProperties, data, bufferType );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function createBuffer( attributeProperties, data, bufferType ) {\r\n\r\n		attributeProperties.__webglBuffer = gl.createBuffer();\r\n		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n		gl.bufferData( bufferType, data.array, usage );\r\n\r\n		attributeProperties.version = data.version;\r\n\r\n	}\r\n\r\n	function updateBuffer( attributeProperties, data, bufferType ) {\r\n\r\n		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n		if ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\r\n			// Not using update ranges\r\n\r\n			gl.bufferSubData( bufferType, 0, data.array );\r\n\r\n		} else if ( data.updateRange.count === 0 ) {\r\n\r\n			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n		} else {\r\n\r\n			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\r\n			data.updateRange.count = 0; // reset range\r\n\r\n		}\r\n\r\n		attributeProperties.version = data.version;\r\n\r\n	}\r\n\r\n	function getAttributeBuffer( attribute ) {\r\n\r\n		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n			return properties.get( attribute.data ).__webglBuffer;\r\n\r\n		}\r\n\r\n		return properties.get( attribute ).__webglBuffer;\r\n\r\n	}\r\n\r\n	function getWireframeAttribute( geometry ) {\r\n\r\n		var property = properties.get( geometry );\r\n\r\n		if ( property.wireframe !== undefined ) {\r\n\r\n			return property.wireframe;\r\n\r\n		}\r\n\r\n		var indices = [];\r\n\r\n		var index = geometry.index;\r\n		var attributes = geometry.attributes;\r\n		var position = attributes.position;\r\n\r\n		// console.time( 'wireframe' );\r\n\r\n		if ( index !== null ) {\r\n\r\n			var edges = {};\r\n			var array = index.array;\r\n\r\n			for ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n				var a = array[ i + 0 ];\r\n				var b = array[ i + 1 ];\r\n				var c = array[ i + 2 ];\r\n\r\n				if ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n				if ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n				if ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			var array = attributes.position.array;\r\n\r\n			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n				var a = i + 0;\r\n				var b = i + 1;\r\n				var c = i + 2;\r\n\r\n				indices.push( a, b, b, c, c, a );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// console.timeEnd( 'wireframe' );\r\n\r\n		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\r\n		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n		property.wireframe = attribute;\r\n\r\n		return attribute;\r\n\r\n	}\r\n\r\n	function checkEdge( edges, a, b ) {\r\n\r\n		if ( a > b ) {\r\n\r\n			var tmp = a;\r\n			a = b;\r\n			b = tmp;\r\n\r\n		}\r\n\r\n		var list = edges[ a ];\r\n\r\n		if ( list === undefined ) {\r\n\r\n			edges[ a ] = [ b ];\r\n			return true;\r\n\r\n		} else if ( list.indexOf( b ) === -1 ) {\r\n\r\n			list.push( b );\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n	this.getAttributeBuffer = getAttributeBuffer;\r\n	this.getWireframeAttribute = getWireframeAttribute;\r\n\r\n	this.update = update;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n	var programIdCount = 0;\r\n\r\n	// TODO: Combine the regex\r\n	var structRe = /^([\\w\\d_]+)\\.([\\w\\d_]+)$/;\r\n	var arrayStructRe = /^([\\w\\d_]+)\\[(\\d+)\\]\\.([\\w\\d_]+)$/;\r\n	var arrayRe = /^([\\w\\d_]+)\\[0\\]$/;\r\n\r\n	function generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\r\n		extensions = extensions || {};\r\n\r\n		var chunks = [\r\n			( extensions.derivatives || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n		];\r\n\r\n		return chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\r\n	}\r\n\r\n	function generateDefines( defines ) {\r\n\r\n		var chunks = [];\r\n\r\n		for ( var name in defines ) {\r\n\r\n			var value = defines[ name ];\r\n\r\n			if ( value === false ) continue;\r\n\r\n			chunks.push( '#define ' + name + ' ' + value );\r\n\r\n		}\r\n\r\n		return chunks.join( '\\n' );\r\n\r\n	}\r\n\r\n	function fetchUniformLocations( gl, program, identifiers ) {\r\n\r\n		var uniforms = {};\r\n\r\n		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n		for ( var i = 0; i < n; i ++ ) {\r\n\r\n			var info = gl.getActiveUniform( program, i );\r\n			var name = info.name;\r\n			var location = gl.getUniformLocation( program, name );\r\n\r\n			//console.log(\"THREE.WebGLProgram: ACTIVE UNIFORM:\", name);\r\n\r\n			var matches = structRe.exec( name );\r\n			if ( matches ) {\r\n\r\n				var structName = matches[ 1 ];\r\n				var structProperty = matches[ 2 ];\r\n\r\n				var uniformsStruct = uniforms[ structName ];\r\n\r\n				if ( ! uniformsStruct ) {\r\n\r\n					uniformsStruct = uniforms[ structName ] = {};\r\n\r\n				}\r\n\r\n				uniformsStruct[ structProperty ] = location;\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			matches = arrayStructRe.exec( name );\r\n\r\n			if ( matches ) {\r\n\r\n				var arrayName = matches[ 1 ];\r\n				var arrayIndex = matches[ 2 ];\r\n				var arrayProperty = matches[ 3 ];\r\n\r\n				var uniformsArray = uniforms[ arrayName ];\r\n\r\n				if ( ! uniformsArray ) {\r\n\r\n					uniformsArray = uniforms[ arrayName ] = [];\r\n\r\n				}\r\n\r\n				var uniformsArrayIndex = uniformsArray[ arrayIndex ];\r\n\r\n				if ( ! uniformsArrayIndex ) {\r\n\r\n					uniformsArrayIndex = uniformsArray[ arrayIndex ] = {};\r\n\r\n				}\r\n\r\n				uniformsArrayIndex[ arrayProperty ] = location;\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			matches = arrayRe.exec( name );\r\n\r\n			if ( matches ) {\r\n\r\n				var arrayName = matches[ 1 ];\r\n\r\n				uniforms[ arrayName ] = location;\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			uniforms[ name ] = location;\r\n\r\n		}\r\n\r\n		return uniforms;\r\n\r\n	}\r\n\r\n	function fetchAttributeLocations( gl, program, identifiers ) {\r\n\r\n		var attributes = {};\r\n\r\n		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n		for ( var i = 0; i < n; i ++ ) {\r\n\r\n			var info = gl.getActiveAttrib( program, i );\r\n			var name = info.name;\r\n\r\n			// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\r\n			attributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n		}\r\n\r\n		return attributes;\r\n\r\n	}\r\n\r\n	function filterEmptyLine( string ) {\r\n\r\n		return string !== '';\r\n\r\n	}\r\n\r\n	function replaceLightNums( string, parameters ) {\r\n\r\n		return string\r\n			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\r\n	}\r\n\r\n	function unrollLoops( string ) {\r\n\r\n		var pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\r\n		function replace( match, start, end, snippet ) {\r\n\r\n			var unroll = '';\r\n\r\n			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\r\n				unroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\r\n			}\r\n\r\n			return unroll;\r\n\r\n		}\r\n\r\n		return string.replace( pattern, replace );\r\n\r\n	}\r\n\r\n	return function WebGLProgram( renderer, code, material, parameters ) {\r\n\r\n		var gl = renderer.context;\r\n\r\n		var extensions = material.extensions;\r\n		var defines = material.defines;\r\n\r\n		var vertexShader = material.__webglShader.vertexShader;\r\n		var fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n		}\r\n\r\n		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n		if ( parameters.envMap ) {\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeReflectionMapping:\r\n				case THREE.CubeRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n					break;\r\n\r\n				case THREE.EquirectangularReflectionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n					break;\r\n\r\n				case THREE.SphericalReflectionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeRefractionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.combine ) {\r\n\r\n				case THREE.MultiplyOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n					break;\r\n\r\n				case THREE.MixOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n					break;\r\n\r\n				case THREE.AddOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n		// console.log( 'building new program ' );\r\n\r\n		//\r\n\r\n		var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\r\n		var customDefines = generateDefines( defines );\r\n\r\n		//\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var prefixVertex, prefixFragment;\r\n\r\n		if ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n			prefixVertex = '';\r\n			prefixFragment = '';\r\n\r\n		} else {\r\n\r\n			prefixVertex = [\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n				customDefines,\r\n\r\n				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n				renderer.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n				'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n				'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.aoMap ? '#define USE_AOMAP' : '',\r\n				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n				parameters.skinning ? '#define USE_SKINNING' : '',\r\n				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\r\n				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n				'uniform mat4 modelMatrix;',\r\n				'uniform mat4 modelViewMatrix;',\r\n				'uniform mat4 projectionMatrix;',\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform mat3 normalMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n\r\n				'attribute vec3 position;',\r\n				'attribute vec3 normal;',\r\n				'attribute vec2 uv;',\r\n\r\n				'#ifdef USE_COLOR',\r\n\r\n				'	attribute vec3 color;',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_MORPHTARGETS',\r\n\r\n				'	attribute vec3 morphTarget0;',\r\n				'	attribute vec3 morphTarget1;',\r\n				'	attribute vec3 morphTarget2;',\r\n				'	attribute vec3 morphTarget3;',\r\n\r\n				'	#ifdef USE_MORPHNORMALS',\r\n\r\n				'		attribute vec3 morphNormal0;',\r\n				'		attribute vec3 morphNormal1;',\r\n				'		attribute vec3 morphNormal2;',\r\n				'		attribute vec3 morphNormal3;',\r\n\r\n				'	#else',\r\n\r\n				'		attribute vec3 morphTarget4;',\r\n				'		attribute vec3 morphTarget5;',\r\n				'		attribute vec3 morphTarget6;',\r\n				'		attribute vec3 morphTarget7;',\r\n\r\n				'	#endif',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_SKINNING',\r\n\r\n				'	attribute vec4 skinIndex;',\r\n				'	attribute vec4 skinWeight;',\r\n\r\n				'#endif',\r\n\r\n				'\\n'\r\n\r\n			].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\r\n			prefixFragment = [\r\n\r\n				customExtensions,\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n				customDefines,\r\n\r\n				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n				renderer.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n				'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.aoMap ? '#define USE_AOMAP' : '',\r\n				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n				parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n\r\n				'\\n'\r\n\r\n			].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n		}\r\n\r\n		vertexShader = replaceLightNums( vertexShader, parameters );\r\n		fragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\r\n		if ( material instanceof THREE.ShaderMaterial === false ) {\r\n\r\n			vertexShader = unrollLoops( vertexShader );\r\n			fragmentShader = unrollLoops( fragmentShader );\r\n\r\n		}\r\n\r\n		var vertexGlsl = prefixVertex + vertexShader;\r\n		var fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n		// console.log( '*VERTEX*', vertexGlsl );\r\n		// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\r\n		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n		gl.attachShader( program, glVertexShader );\r\n		gl.attachShader( program, glFragmentShader );\r\n\r\n		// Force a particular attribute to index 0.\r\n\r\n		if ( material.index0AttributeName !== undefined ) {\r\n\r\n			gl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n		} else if ( parameters.morphTargets === true ) {\r\n\r\n			// programs with morphTargets displace position out of attribute 0\r\n			gl.bindAttribLocation( program, 0, 'position' );\r\n\r\n		}\r\n\r\n		gl.linkProgram( program );\r\n\r\n		var programLog = gl.getProgramInfoLog( program );\r\n		var vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\r\n		var runnable = true;\r\n		var haveDiagnostics = true;\r\n\r\n		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n			runnable = false;\r\n\r\n			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n		} else if ( programLog !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n		} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n			haveDiagnostics = false;\r\n\r\n		}\r\n\r\n		if ( haveDiagnostics ) {\r\n\r\n			this.diagnostics = {\r\n\r\n				runnable: runnable,\r\n				material: material,\r\n\r\n				programLog: programLog,\r\n\r\n				vertexShader: {\r\n\r\n					log: vertexLog,\r\n					prefix: prefixVertex\r\n\r\n				},\r\n\r\n				fragmentShader: {\r\n\r\n					log: fragmentLog,\r\n					prefix: prefixFragment\r\n\r\n				}\r\n\r\n			};\r\n\r\n		}\r\n\r\n		// clean up\r\n\r\n		gl.deleteShader( glVertexShader );\r\n		gl.deleteShader( glFragmentShader );\r\n\r\n		// set up caching for uniform locations\r\n\r\n		var cachedUniforms;\r\n\r\n		this.getUniforms = function() {\r\n\r\n			if ( cachedUniforms === undefined ) {\r\n\r\n				cachedUniforms = fetchUniformLocations( gl, program );\r\n\r\n			}\r\n\r\n			return cachedUniforms;\r\n\r\n		};\r\n\r\n		// set up caching for attribute locations\r\n\r\n		var cachedAttributes;\r\n\r\n		this.getAttributes = function() {\r\n\r\n			if ( cachedAttributes === undefined ) {\r\n\r\n				cachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n			}\r\n\r\n			return cachedAttributes;\r\n\r\n		};\r\n\r\n		// free resource\r\n\r\n		this.destroy = function() {\r\n\r\n			gl.deleteProgram( program );\r\n			this.program = undefined;\r\n\r\n		};\r\n\r\n		// DEPRECATED\r\n\r\n		Object.defineProperties( this, {\r\n\r\n			uniforms: {\r\n				get: function() {\r\n\r\n					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n					return this.getUniforms();\r\n\r\n				}\r\n			},\r\n\r\n			attributes: {\r\n				get: function() {\r\n\r\n					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n					return this.getAttributes();\r\n\r\n				}\r\n			}\r\n\r\n		} );\r\n\r\n\r\n		//\r\n\r\n		this.id = programIdCount ++;\r\n		this.code = code;\r\n		this.usedTimes = 1;\r\n		this.program = program;\r\n		this.vertexShader = glVertexShader;\r\n		this.fragmentShader = glFragmentShader;\r\n\r\n		return this;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLPrograms.js\r\n\r\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\r\n	var programs = [];\r\n\r\n	var shaderIDs = {\r\n		MeshDepthMaterial: 'depth',\r\n		MeshNormalMaterial: 'normal',\r\n		MeshBasicMaterial: 'basic',\r\n		MeshLambertMaterial: 'lambert',\r\n		MeshPhongMaterial: 'phong',\r\n		MeshStandardMaterial: 'standard',\r\n		LineBasicMaterial: 'basic',\r\n		LineDashedMaterial: 'dashed',\r\n		PointsMaterial: 'points'\r\n	};\r\n\r\n	var parameterNames = [\r\n		\"precision\", \"supportsVertexTextures\", \"map\", \"envMap\", \"envMapMode\",\r\n		\"lightMap\", \"aoMap\", \"emissiveMap\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n		\"roughnessMap\", \"metalnessMap\",\r\n		\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n		\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n		\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n		\"maxMorphTargets\", \"maxMorphNormals\",\r\n		\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n		\"shadowMapEnabled\", \"pointLightShadows\",\r\n		\"shadowMapType\",\r\n		\"alphaTest\", \"doubleSided\", \"flipSided\"\r\n	];\r\n\r\n\r\n	function allocateBones ( object ) {\r\n\r\n		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n			return 1024;\r\n\r\n		} else {\r\n\r\n			// default for when object is not specified\r\n			// ( for example when prebuilding shader to be used with multiple objects )\r\n			//\r\n			//  - leave some extra space for other uniforms\r\n			//  - limit here is ANGLE's 254 max uniform vectors\r\n			//    (up to 54 should be safe)\r\n\r\n			var nVertexUniforms = capabilities.maxVertexUniforms;\r\n			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n			var maxBones = nVertexMatrices;\r\n\r\n			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n				maxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n				if ( maxBones < object.skeleton.bones.length ) {\r\n\r\n					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return maxBones;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.getParameters = function ( material, lights, fog, object ) {\r\n\r\n		var shaderID = shaderIDs[ material.type ];\r\n		// heuristics to create shader parameters according to lights in the scene\r\n		// (not to blow over maxLights budget)\r\n\r\n		var maxBones = allocateBones( object );\r\n		var precision = renderer.getPrecision();\r\n\r\n		if ( material.precision !== null ) {\r\n\r\n			precision = capabilities.getMaxPrecision( material.precision );\r\n\r\n			if ( precision !== material.precision ) {\r\n\r\n				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var parameters = {\r\n\r\n			shaderID: shaderID,\r\n\r\n			precision: precision,\r\n			supportsVertexTextures: capabilities.vertexTextures,\r\n\r\n			map: !! material.map,\r\n			envMap: !! material.envMap,\r\n			envMapMode: material.envMap && material.envMap.mapping,\r\n			lightMap: !! material.lightMap,\r\n			aoMap: !! material.aoMap,\r\n			emissiveMap: !! material.emissiveMap,\r\n			bumpMap: !! material.bumpMap,\r\n			normalMap: !! material.normalMap,\r\n			displacementMap: !! material.displacementMap,\r\n			roughnessMap: !! material.roughnessMap,\r\n			metalnessMap: !! material.metalnessMap,\r\n			specularMap: !! material.specularMap,\r\n			alphaMap: !! material.alphaMap,\r\n\r\n			combine: material.combine,\r\n\r\n			vertexColors: material.vertexColors,\r\n\r\n			fog: fog,\r\n			useFog: material.fog,\r\n			fogExp: fog instanceof THREE.FogExp2,\r\n\r\n			flatShading: material.shading === THREE.FlatShading,\r\n\r\n			sizeAttenuation: material.sizeAttenuation,\r\n			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n			skinning: material.skinning,\r\n			maxBones: maxBones,\r\n			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n			morphTargets: material.morphTargets,\r\n			morphNormals: material.morphNormals,\r\n			maxMorphTargets: renderer.maxMorphTargets,\r\n			maxMorphNormals: renderer.maxMorphNormals,\r\n\r\n			numDirLights: lights.directional.length,\r\n			numPointLights: lights.point.length,\r\n			numSpotLights: lights.spot.length,\r\n			numHemiLights: lights.hemi.length,\r\n\r\n			pointLightShadows: lights.shadowsPointLight,\r\n\r\n			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n			shadowMapType: renderer.shadowMap.type,\r\n\r\n			alphaTest: material.alphaTest,\r\n			doubleSided: material.side === THREE.DoubleSide,\r\n			flipSided: material.side === THREE.BackSide\r\n\r\n		};\r\n\r\n		return parameters;\r\n\r\n	};\r\n\r\n	this.getProgramCode = function ( material, parameters ) {\r\n\r\n		var chunks = [];\r\n\r\n		if ( parameters.shaderID ) {\r\n\r\n			chunks.push( parameters.shaderID );\r\n\r\n		} else {\r\n\r\n			chunks.push( material.fragmentShader );\r\n			chunks.push( material.vertexShader );\r\n\r\n		}\r\n\r\n		if ( material.defines !== undefined ) {\r\n\r\n			for ( var name in material.defines ) {\r\n\r\n				chunks.push( name );\r\n				chunks.push( material.defines[ name ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n			var parameterName = parameterNames[ i ];\r\n			chunks.push( parameterName );\r\n			chunks.push( parameters[ parameterName ] );\r\n\r\n		}\r\n\r\n		return chunks.join();\r\n\r\n	};\r\n\r\n	this.acquireProgram = function ( material, parameters, code ) {\r\n\r\n		var program;\r\n\r\n		// Check if code has been already compiled\r\n		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n			var programInfo = programs[ p ];\r\n\r\n			if ( programInfo.code === code ) {\r\n\r\n				program = programInfo;\r\n				++ program.usedTimes;\r\n\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( program === undefined ) {\r\n\r\n			program = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n			programs.push( program );\r\n\r\n		}\r\n\r\n		return program;\r\n\r\n	};\r\n\r\n	this.releaseProgram = function( program ) {\r\n\r\n		if ( -- program.usedTimes === 0 ) {\r\n\r\n			// Remove from unordered set\r\n			var i = programs.indexOf( program );\r\n			programs[ i ] = programs[ programs.length - 1 ];\r\n			programs.pop();\r\n\r\n			// Free WebGL resources\r\n			program.destroy();\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Exposed for resource monitoring & error feedback via renderer.info:\r\n	this.programs = programs;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProperties.js\r\n\r\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\r\n\r\nTHREE.WebGLProperties = function () {\r\n\r\n	var properties = {};\r\n\r\n	this.get = function ( object ) {\r\n\r\n		var uuid = object.uuid;\r\n		var map = properties[ uuid ];\r\n\r\n		if ( map === undefined ) {\r\n\r\n			map = {};\r\n			properties[ uuid ] = map;\r\n\r\n		}\r\n\r\n		return map;\r\n\r\n	};\r\n\r\n	this.delete = function ( object ) {\r\n\r\n		delete properties[ object.uuid ];\r\n\r\n	};\r\n\r\n	this.clear = function () {\r\n\r\n		properties = {};\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n	function addLineNumbers( string ) {\r\n\r\n		var lines = string.split( '\\n' );\r\n\r\n		for ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n		}\r\n\r\n		return lines.join( '\\n' );\r\n\r\n	}\r\n\r\n	return function WebGLShader( gl, type, string ) {\r\n\r\n		var shader = gl.createShader( type );\r\n\r\n		gl.shaderSource( shader, string );\r\n		gl.compileShader( shader );\r\n\r\n		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n			console.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n		}\r\n\r\n		if ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n		}\r\n\r\n		// --enable-privileged-webgl-extension\r\n		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n		return shader;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShadowMap.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\r\n	var _gl = _renderer.context,\r\n	_state = _renderer.state,\r\n	_frustum = new THREE.Frustum(),\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n	_lookTarget = new THREE.Vector3(),\r\n	_lightPositionWorld = new THREE.Vector3(),\r\n\r\n	_renderList = [],\r\n\r\n	_MorphingFlag = 1,\r\n	_SkinningFlag = 2,\r\n\r\n	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\r\n	_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n	_distanceMaterials = new Array( _NumberOfMaterialVariants );\r\n\r\n	var cubeDirections = [\r\n		new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n		new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n	];\r\n\r\n	var cubeUps = [\r\n		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )\r\n	];\r\n\r\n	var cube2DViewPorts = [\r\n		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n	];\r\n\r\n	// init\r\n\r\n	var depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n	var distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n	var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\r\n	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\r\n		var useMorphing = ( i & _MorphingFlag ) !== 0;\r\n		var useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\r\n		var depthMaterial = new THREE.ShaderMaterial( {\r\n			uniforms: depthUniforms,\r\n			vertexShader: depthShader.vertexShader,\r\n			fragmentShader: depthShader.fragmentShader,\r\n			morphTargets: useMorphing,\r\n			skinning: useSkinning\r\n		} );\r\n\r\n		depthMaterial._shadowPass = true;\r\n\r\n		_depthMaterials[ i ] = depthMaterial;\r\n\r\n		var distanceMaterial = new THREE.ShaderMaterial( {\r\n			uniforms: distanceUniforms,\r\n			vertexShader: distanceShader.vertexShader,\r\n			fragmentShader: distanceShader.fragmentShader,\r\n			morphTargets: useMorphing,\r\n			skinning: useSkinning\r\n		} );\r\n\r\n		distanceMaterial._shadowPass = true;\r\n\r\n		_distanceMaterials[ i ] = distanceMaterial;\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var scope = this;\r\n\r\n	this.enabled = false;\r\n\r\n	this.autoUpdate = true;\r\n	this.needsUpdate = false;\r\n\r\n	this.type = THREE.PCFShadowMap;\r\n	this.cullFace = THREE.CullFaceFront;\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		var faceCount, isPointLight;\r\n\r\n		if ( scope.enabled === false ) return;\r\n		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n		// Set GL state for depth map.\r\n		_state.clearColor( 1, 1, 1, 1 );\r\n		_state.disable( _gl.BLEND );\r\n		_state.enable( _gl.CULL_FACE );\r\n		_gl.frontFace( _gl.CCW );\r\n		_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );\r\n		_state.setDepthTest( true );\r\n		_state.setScissorTest( false );\r\n\r\n		// render depth map\r\n\r\n		var shadows = _lights.shadows;\r\n\r\n		for ( var i = 0, il = shadows.length; i < il; i ++ ) {\r\n\r\n			var light = shadows[ i ];\r\n\r\n			var shadow = light.shadow;\r\n			var shadowCamera = shadow.camera;\r\n			var shadowMapSize = shadow.mapSize;\r\n\r\n			if ( light instanceof THREE.PointLight ) {\r\n\r\n				faceCount = 6;\r\n				isPointLight = true;\r\n\r\n				var vpWidth = shadowMapSize.x / 4.0;\r\n				var vpHeight = shadowMapSize.y / 2.0;\r\n\r\n				// These viewports map a cube-map onto a 2D texture with the\r\n				// following orientation:\r\n				//\r\n				//  xzXZ\r\n				//   y Y\r\n				//\r\n				// X - Positive x direction\r\n				// x - Negative x direction\r\n				// Y - Positive y direction\r\n				// y - Negative y direction\r\n				// Z - Positive z direction\r\n				// z - Negative z direction\r\n\r\n				// positive X\r\n				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n				// negative X\r\n				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n				// positive Z\r\n				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n				// negative Z\r\n				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n				// positive Y\r\n				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n				// negative Y\r\n				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\r\n			} else {\r\n\r\n				faceCount = 1;\r\n				isPointLight = false;\r\n\r\n			}\r\n\r\n			if ( shadow.map === null ) {\r\n\r\n				var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\r\n\r\n				shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );\r\n\r\n				//\r\n\r\n				if ( light instanceof THREE.SpotLight ) {\r\n\r\n					shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;\r\n\r\n				}\r\n\r\n				shadowCamera.updateProjectionMatrix();\r\n\r\n			}\r\n\r\n			var shadowMap = shadow.map;\r\n			var shadowMatrix = shadow.matrix;\r\n\r\n			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n			shadowCamera.position.copy( _lightPositionWorld );\r\n\r\n			_renderer.setRenderTarget( shadowMap );\r\n			_renderer.clear();\r\n\r\n			// render shadow map for each cube face (if omni-directional) or\r\n			// run a single pass if not\r\n\r\n			for ( var face = 0; face < faceCount; face ++ ) {\r\n\r\n				if ( isPointLight ) {\r\n\r\n					_lookTarget.copy( shadowCamera.position );\r\n					_lookTarget.add( cubeDirections[ face ] );\r\n					shadowCamera.up.copy( cubeUps[ face ] );\r\n					shadowCamera.lookAt( _lookTarget );\r\n\r\n					var vpDimensions = cube2DViewPorts[ face ];\r\n					_state.viewport( vpDimensions );\r\n\r\n				} else {\r\n\r\n					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n					shadowCamera.lookAt( _lookTarget );\r\n\r\n				}\r\n\r\n				shadowCamera.updateMatrixWorld();\r\n				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n				// compute shadow matrix\r\n\r\n				shadowMatrix.set(\r\n					0.5, 0.0, 0.0, 0.5,\r\n					0.0, 0.5, 0.0, 0.5,\r\n					0.0, 0.0, 0.5, 0.5,\r\n					0.0, 0.0, 0.0, 1.0\r\n				);\r\n\r\n				shadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n				// update camera matrices and frustum\r\n\r\n				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n				_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n				// set object matrices & frustum culling\r\n\r\n				_renderList.length = 0;\r\n\r\n				projectObject( scene, camera, shadowCamera );\r\n\r\n				// render shadow map\r\n				// render regular objects\r\n\r\n				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n					var object = _renderList[ j ];\r\n					var geometry = _objects.update( object );\r\n					var material = object.material;\r\n\r\n					if ( material instanceof THREE.MultiMaterial ) {\r\n\r\n						var groups = geometry.groups;\r\n						var materials = material.materials;\r\n\r\n						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n							var group = groups[ k ];\r\n							var groupMaterial = materials[ group.materialIndex ];\r\n\r\n							if ( groupMaterial.visible === true ) {\r\n\r\n								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// We must call _renderer.resetGLState() at the end of each iteration of\r\n			// the light loop in order to force material updates for each light.\r\n			_renderer.resetGLState();\r\n\r\n		}\r\n\r\n		// Restore GL state.\r\n		var clearColor = _renderer.getClearColor(),\r\n		clearAlpha = _renderer.getClearAlpha();\r\n		_renderer.setClearColor( clearColor, clearAlpha );\r\n\r\n		_state.enable( _gl.BLEND );\r\n\r\n		if ( scope.cullFace === THREE.CullFaceFront ) {\r\n\r\n			_gl.cullFace( _gl.BACK );\r\n\r\n		}\r\n\r\n		_renderer.resetGLState();\r\n\r\n		scope.needsUpdate = false;\r\n\r\n	};\r\n\r\n	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		var newMaterial = null;\r\n\r\n		var materialVariants = _depthMaterials;\r\n		var customMaterial = object.customDepthMaterial;\r\n\r\n		if ( isPointLight ) {\r\n\r\n			materialVariants = _distanceMaterials;\r\n			customMaterial = object.customDistanceMaterial;\r\n\r\n		}\r\n\r\n		if ( ! customMaterial ) {\r\n\r\n			var useMorphing = geometry.morphTargets !== undefined &&\r\n					geometry.morphTargets.length > 0 && material.morphTargets;\r\n\r\n			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\r\n			var variantIndex = 0;\r\n\r\n			if ( useMorphing ) variantIndex |= _MorphingFlag;\r\n			if ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\r\n			newMaterial = materialVariants[ variantIndex ];\r\n\r\n		} else {\r\n\r\n			newMaterial = customMaterial;\r\n\r\n		}\r\n\r\n		newMaterial.visible = material.visible;\r\n		newMaterial.wireframe = material.wireframe;\r\n		newMaterial.wireframeLinewidth = material.wireframeLinewidth;\r\n\r\n		if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {\r\n\r\n			newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\r\n		}\r\n\r\n		return newMaterial;\r\n\r\n	}\r\n\r\n	function projectObject( object, camera, shadowCamera ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\r\n			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n				var material = object.material;\r\n\r\n				if ( material.visible === true ) {\r\n\r\n					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n					_renderList.push( object );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var children = object.children;\r\n\r\n		for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n			projectObject( children[ i ], camera, shadowCamera );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\r\n	var _this = this;\r\n\r\n	var color = new THREE.Vector4();\r\n\r\n	var newAttributes = new Uint8Array( 16 );\r\n	var enabledAttributes = new Uint8Array( 16 );\r\n	var attributeDivisors = new Uint8Array( 16 );\r\n\r\n	var capabilities = {};\r\n\r\n	var compressedTextureFormats = null;\r\n\r\n	var currentBlending = null;\r\n	var currentBlendEquation = null;\r\n	var currentBlendSrc = null;\r\n	var currentBlendDst = null;\r\n	var currentBlendEquationAlpha = null;\r\n	var currentBlendSrcAlpha = null;\r\n	var currentBlendDstAlpha = null;\r\n\r\n	var currentDepthFunc = null;\r\n	var currentDepthWrite = null;\r\n\r\n	var currentColorWrite = null;\r\n\r\n	var currentStencilWrite = null;\r\n	var currentStencilFunc = null;\r\n	var currentStencilRef = null;\r\n	var currentStencilMask = null;\r\n	var currentStencilFail  = null;\r\n	var currentStencilZFail = null;\r\n	var currentStencilZPass = null;\r\n\r\n	var currentFlipSided = null;\r\n\r\n	var currentLineWidth = null;\r\n\r\n	var currentPolygonOffsetFactor = null;\r\n	var currentPolygonOffsetUnits = null;\r\n\r\n	var currentScissorTest = null;\r\n\r\n	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\r\n	var currentTextureSlot = undefined;\r\n	var currentBoundTextures = {};\r\n\r\n	var currentClearColor = new THREE.Vector4();\r\n	var currentClearDepth = null;\r\n	var currentClearStencil = null;\r\n\r\n	var currentScissor = new THREE.Vector4();\r\n	var currentViewport = new THREE.Vector4();\r\n\r\n	this.init = function () {\r\n\r\n		this.clearColor( 0, 0, 0, 1 );\r\n		this.clearDepth( 1 );\r\n		this.clearStencil( 0 );\r\n\r\n		this.enable( gl.DEPTH_TEST );\r\n		gl.depthFunc( gl.LEQUAL );\r\n\r\n		gl.frontFace( gl.CCW );\r\n		gl.cullFace( gl.BACK );\r\n		this.enable( gl.CULL_FACE );\r\n\r\n		this.enable( gl.BLEND );\r\n		gl.blendEquation( gl.FUNC_ADD );\r\n		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n	};\r\n\r\n	this.initAttributes = function () {\r\n\r\n		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n			newAttributes[ i ] = 0;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.enableAttribute = function ( attribute ) {\r\n\r\n		newAttributes[ attribute ] = 1;\r\n\r\n		if ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n			gl.enableVertexAttribArray( attribute );\r\n			enabledAttributes[ attribute ] = 1;\r\n\r\n		}\r\n\r\n		if ( attributeDivisors[ attribute ] !== 0 ) {\r\n\r\n			var extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n			extension.vertexAttribDivisorANGLE( attribute, 0 );\r\n			attributeDivisors[ attribute ] = 0;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\r\n		newAttributes[ attribute ] = 1;\r\n\r\n		if ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n			gl.enableVertexAttribArray( attribute );\r\n			enabledAttributes[ attribute ] = 1;\r\n\r\n		}\r\n\r\n		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n			attributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.disableUnusedAttributes = function () {\r\n\r\n		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n				gl.disableVertexAttribArray( i );\r\n				enabledAttributes[ i ] = 0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.enable = function ( id ) {\r\n\r\n		if ( capabilities[ id ] !== true ) {\r\n\r\n			gl.enable( id );\r\n			capabilities[ id ] = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.disable = function ( id ) {\r\n\r\n		if ( capabilities[ id ] !== false ) {\r\n\r\n			gl.disable( id );\r\n			capabilities[ id ] = false;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getCompressedTextureFormats = function () {\r\n\r\n		if ( compressedTextureFormats === null ) {\r\n\r\n			compressedTextureFormats = [];\r\n\r\n			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n			     extensions.get( 'WEBGL_compressed_texture_etc1' )) {\r\n\r\n				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n				for ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n					compressedTextureFormats.push( formats[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return compressedTextureFormats;\r\n\r\n	};\r\n\r\n	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\r\n		if ( blending === THREE.NoBlending ) {\r\n\r\n			this.disable( gl.BLEND );\r\n\r\n		} else {\r\n\r\n			this.enable( gl.BLEND );\r\n\r\n		}\r\n\r\n		if ( blending !== currentBlending ) {\r\n\r\n			if ( blending === THREE.AdditiveBlending ) {\r\n\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n			} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n			} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n\r\n				gl.blendEquation( gl.FUNC_ADD );\r\n				gl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n			} else {\r\n\r\n				gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n				gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n			}\r\n\r\n			currentBlending = blending;\r\n\r\n		}\r\n\r\n		if ( blending === THREE.CustomBlending ) {\r\n\r\n			blendEquationAlpha = blendEquationAlpha || blendEquation;\r\n			blendSrcAlpha = blendSrcAlpha || blendSrc;\r\n			blendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n				currentBlendEquation = blendEquation;\r\n				currentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n			}\r\n\r\n			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n				currentBlendSrc = blendSrc;\r\n				currentBlendDst = blendDst;\r\n				currentBlendSrcAlpha = blendSrcAlpha;\r\n				currentBlendDstAlpha = blendDstAlpha;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			currentBlendEquation = null;\r\n			currentBlendSrc = null;\r\n			currentBlendDst = null;\r\n			currentBlendEquationAlpha = null;\r\n			currentBlendSrcAlpha = null;\r\n			currentBlendDstAlpha = null;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthFunc = function ( depthFunc ) {\r\n\r\n		if ( currentDepthFunc !== depthFunc ) {\r\n\r\n			if ( depthFunc ) {\r\n\r\n				switch ( depthFunc ) {\r\n\r\n					case THREE.NeverDepth:\r\n\r\n						gl.depthFunc( gl.NEVER );\r\n						break;\r\n\r\n					case THREE.AlwaysDepth:\r\n\r\n						gl.depthFunc( gl.ALWAYS );\r\n						break;\r\n\r\n					case THREE.LessDepth:\r\n\r\n						gl.depthFunc( gl.LESS );\r\n						break;\r\n\r\n					case THREE.LessEqualDepth:\r\n\r\n						gl.depthFunc( gl.LEQUAL );\r\n						break;\r\n\r\n					case THREE.EqualDepth:\r\n\r\n						gl.depthFunc( gl.EQUAL );\r\n						break;\r\n\r\n					case THREE.GreaterEqualDepth:\r\n\r\n						gl.depthFunc( gl.GEQUAL );\r\n						break;\r\n\r\n					case THREE.GreaterDepth:\r\n\r\n						gl.depthFunc( gl.GREATER );\r\n						break;\r\n\r\n					case THREE.NotEqualDepth:\r\n\r\n						gl.depthFunc( gl.NOTEQUAL );\r\n						break;\r\n\r\n					default:\r\n\r\n						gl.depthFunc( gl.LEQUAL );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				gl.depthFunc( gl.LEQUAL );\r\n\r\n			}\r\n\r\n			currentDepthFunc = depthFunc;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthTest = function ( depthTest ) {\r\n\r\n		if ( depthTest ) {\r\n\r\n			this.enable( gl.DEPTH_TEST );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.DEPTH_TEST );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthWrite = function ( depthWrite ) {\r\n\r\n		// TODO: Rename to setDepthMask\r\n\r\n		if ( currentDepthWrite !== depthWrite ) {\r\n\r\n			gl.depthMask( depthWrite );\r\n			currentDepthWrite = depthWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setColorWrite = function ( colorWrite ) {\r\n\r\n		// TODO: Rename to setColorMask\r\n\r\n		if ( currentColorWrite !== colorWrite ) {\r\n\r\n			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n			currentColorWrite = colorWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n		if ( currentStencilFunc !== stencilFunc ||\r\n				 currentStencilRef 	!== stencilRef 	||\r\n				 currentStencilMask !== stencilMask ) {\r\n\r\n			gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\r\n			currentStencilFunc = stencilFunc;\r\n			currentStencilRef  = stencilRef;\r\n			currentStencilMask = stencilMask;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n		if ( currentStencilFail	 !== stencilFail 	||\r\n				 currentStencilZFail !== stencilZFail ||\r\n				 currentStencilZPass !== stencilZPass ) {\r\n\r\n			gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\r\n			currentStencilFail  = stencilFail;\r\n			currentStencilZFail = stencilZFail;\r\n			currentStencilZPass = stencilZPass;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setStencilTest = function ( stencilTest ) {\r\n\r\n		if ( stencilTest ) {\r\n\r\n			this.enable( gl.STENCIL_TEST );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.STENCIL_TEST );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setStencilWrite = function ( stencilWrite ) {\r\n\r\n		// TODO: Rename to setStencilMask\r\n\r\n		if ( currentStencilWrite !== stencilWrite ) {\r\n\r\n			gl.stencilMask( stencilWrite );\r\n			currentStencilWrite = stencilWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setFlipSided = function ( flipSided ) {\r\n\r\n		if ( currentFlipSided !== flipSided ) {\r\n\r\n			if ( flipSided ) {\r\n\r\n				gl.frontFace( gl.CW );\r\n\r\n			} else {\r\n\r\n				gl.frontFace( gl.CCW );\r\n\r\n			}\r\n\r\n			currentFlipSided = flipSided;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setLineWidth = function ( width ) {\r\n\r\n		if ( width !== currentLineWidth ) {\r\n\r\n			gl.lineWidth( width );\r\n\r\n			currentLineWidth = width;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\r\n		if ( polygonOffset ) {\r\n\r\n			this.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n		}\r\n\r\n		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n			gl.polygonOffset( factor, units );\r\n\r\n			currentPolygonOffsetFactor = factor;\r\n			currentPolygonOffsetUnits = units;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getScissorTest = function () {\r\n\r\n		return currentScissorTest;\r\n\r\n	};\r\n\r\n	this.setScissorTest = function ( scissorTest ) {\r\n\r\n		currentScissorTest = scissorTest;\r\n\r\n		if ( scissorTest ) {\r\n\r\n			this.enable( gl.SCISSOR_TEST );\r\n\r\n		} else {\r\n\r\n			this.disable( gl.SCISSOR_TEST );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// texture\r\n\r\n	this.activeTexture = function ( webglSlot ) {\r\n\r\n		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\r\n		if ( currentTextureSlot !== webglSlot ) {\r\n\r\n			gl.activeTexture( webglSlot );\r\n			currentTextureSlot = webglSlot;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.bindTexture = function ( webglType, webglTexture ) {\r\n\r\n		if ( currentTextureSlot === undefined ) {\r\n\r\n			_this.activeTexture();\r\n\r\n		}\r\n\r\n		var boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n		if ( boundTexture === undefined ) {\r\n\r\n			boundTexture = { type: undefined, texture: undefined };\r\n			currentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n		}\r\n\r\n		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n			gl.bindTexture( webglType, webglTexture );\r\n\r\n			boundTexture.type = webglType;\r\n			boundTexture.texture = webglTexture;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.compressedTexImage2D = function () {\r\n\r\n		try {\r\n\r\n			gl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n		} catch ( error ) {\r\n\r\n			console.error( error );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.texImage2D = function () {\r\n\r\n		try {\r\n\r\n			gl.texImage2D.apply( gl, arguments );\r\n\r\n		} catch ( error ) {\r\n\r\n			console.error( error );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// clear values\r\n\r\n	this.clearColor = function ( r, g, b, a ) {\r\n\r\n		color.set( r, g, b, a );\r\n\r\n		if ( currentClearColor.equals( color ) === false ) {\r\n\r\n			gl.clearColor( r, g, b, a );\r\n			currentClearColor.copy( color );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.clearDepth = function ( depth ) {\r\n\r\n		if ( currentClearDepth !== depth ) {\r\n\r\n			gl.clearDepth( depth );\r\n			currentClearDepth = depth;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.clearStencil = function ( stencil ) {\r\n\r\n		if ( currentClearStencil !== stencil ) {\r\n\r\n			gl.clearStencil( stencil );\r\n			currentClearStencil = stencil;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	//\r\n\r\n	this.scissor = function ( scissor ) {\r\n\r\n		if ( currentScissor.equals( scissor ) === false ) {\r\n\r\n			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n			currentScissor.copy( scissor );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.viewport = function ( viewport ) {\r\n\r\n		if ( currentViewport.equals( viewport ) === false ) {\r\n\r\n			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n			currentViewport.copy( viewport );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	//\r\n\r\n	this.reset = function () {\r\n\r\n		for ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n			if ( enabledAttributes[ i ] === 1 ) {\r\n\r\n				gl.disableVertexAttribArray( i );\r\n				enabledAttributes[ i ] = 0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		capabilities = {};\r\n\r\n		compressedTextureFormats = null;\r\n\r\n		currentBlending = null;\r\n\r\n		currentColorWrite = null;\r\n		currentDepthWrite = null;\r\n		currentStencilWrite = null;\r\n\r\n		currentFlipSided = null;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n	var gl = renderer.context;\r\n	var state = renderer.state;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n	var hasVertexTexture;\r\n\r\n	var tempTexture, occlusionTexture;\r\n\r\n	function init() {\r\n\r\n		var vertices = new Float32Array( [\r\n			- 1, - 1,  0, 0,\r\n			 1, - 1,  1, 0,\r\n			 1,  1,  1, 1,\r\n			- 1,  1,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		// buffers\r\n\r\n		vertexBuffer     = gl.createBuffer();\r\n		elementBuffer    = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		// textures\r\n\r\n		tempTexture      = gl.createTexture();\r\n		occlusionTexture = gl.createTexture();\r\n\r\n		state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n		var shader;\r\n\r\n		if ( hasVertexTexture ) {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"uniform sampler2D occlusionMap;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if ( renderType == 2 ) {\",\r\n\r\n							\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n							\"vVisibility =        visibility.r / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n							\"vVisibility *=       visibility.b / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if ( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if ( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * vVisibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		} else {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if ( renderType == 2 ) {\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"precision mediump float;\",\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform sampler2D occlusionMap;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if ( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if ( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n							\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * visibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		}\r\n\r\n		program = createProgram( shader );\r\n\r\n		attributes = {\r\n			vertex: gl.getAttribLocation ( program, \"position\" ),\r\n			uv:     gl.getAttribLocation ( program, \"uv\" )\r\n		};\r\n\r\n		uniforms = {\r\n			renderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n			map:            gl.getUniformLocation( program, \"map\" ),\r\n			occlusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n			opacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n			color:          gl.getUniformLocation( program, \"color\" ),\r\n			scale:          gl.getUniformLocation( program, \"scale\" ),\r\n			rotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n			screenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n		};\r\n\r\n	}\r\n\r\n	/*\r\n	 * Render lens flares\r\n	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n	 *         reads these back and calculates occlusion.\r\n	 */\r\n\r\n	this.render = function ( scene, camera, viewport ) {\r\n\r\n		if ( flares.length === 0 ) return;\r\n\r\n		var tempPosition = new THREE.Vector3();\r\n\r\n		var invAspect = viewport.w / viewport.z,\r\n			halfViewportWidth = viewport.z * 0.5,\r\n			halfViewportHeight = viewport.w * 0.5;\r\n\r\n		var size = 16 / viewport.w,\r\n			scale = new THREE.Vector2( size * invAspect, size );\r\n\r\n		var screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n			screenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		state.initAttributes();\r\n		state.enableAttribute( attributes.vertex );\r\n		state.enableAttribute( attributes.uv );\r\n		state.disableUnusedAttributes();\r\n\r\n		// loop through all lens flares to update their occlusion and positions\r\n		// setup gl and common used attribs/uniforms\r\n\r\n		gl.uniform1i( uniforms.occlusionMap, 0 );\r\n		gl.uniform1i( uniforms.map, 1 );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		state.disable( gl.CULL_FACE );\r\n		state.setDepthWrite( false );\r\n\r\n		for ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n			size = 16 / viewport.w;\r\n			scale.set( size * invAspect, size );\r\n\r\n			// calc object screen position\r\n\r\n			var flare = flares[ i ];\r\n\r\n			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\r\n			tempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n			tempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n			// setup arrays for gl programs\r\n\r\n			screenPosition.copy( tempPosition );\r\n\r\n			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n			// screen cull\r\n\r\n			if ( hasVertexTexture || (\r\n				screenPositionPixels.x > 0 &&\r\n				screenPositionPixels.x < viewport.z &&\r\n				screenPositionPixels.y > 0 &&\r\n				screenPositionPixels.y < viewport.w ) ) {\r\n\r\n				// save current RGB to temp texture\r\n\r\n				state.activeTexture( gl.TEXTURE0 );\r\n				state.bindTexture( gl.TEXTURE_2D, null );\r\n				state.activeTexture( gl.TEXTURE1 );\r\n				state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// render pink quad\r\n\r\n				gl.uniform1i( uniforms.renderType, 0 );\r\n				gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n				state.disable( gl.BLEND );\r\n				state.enable( gl.DEPTH_TEST );\r\n\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// copy result to occlusionMap\r\n\r\n				state.activeTexture( gl.TEXTURE0 );\r\n				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// restore graphics\r\n\r\n				gl.uniform1i( uniforms.renderType, 1 );\r\n				state.disable( gl.DEPTH_TEST );\r\n\r\n				state.activeTexture( gl.TEXTURE1 );\r\n				state.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// update object positions\r\n\r\n				flare.positionScreen.copy( screenPosition );\r\n\r\n				if ( flare.customUpdateCallback ) {\r\n\r\n					flare.customUpdateCallback( flare );\r\n\r\n				} else {\r\n\r\n					flare.updateLensFlares();\r\n\r\n				}\r\n\r\n				// render flares\r\n\r\n				gl.uniform1i( uniforms.renderType, 2 );\r\n				state.enable( gl.BLEND );\r\n\r\n				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n					var sprite = flare.lensFlares[ j ];\r\n\r\n					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n						screenPosition.x = sprite.x;\r\n						screenPosition.y = sprite.y;\r\n						screenPosition.z = sprite.z;\r\n\r\n						size = sprite.size * sprite.scale / viewport.w;\r\n\r\n						scale.x = size * invAspect;\r\n						scale.y = size;\r\n\r\n						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n						gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n						gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n						gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n						renderer.setTexture( sprite.texture, 1 );\r\n\r\n						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		state.enable( gl.CULL_FACE );\r\n		state.enable( gl.DEPTH_TEST );\r\n		state.setDepthWrite( true );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram ( shader ) {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n		var prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n		gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n		gl.compileShader( fragmentShader );\r\n		gl.compileShader( vertexShader );\r\n\r\n		gl.attachShader( program, fragmentShader );\r\n		gl.attachShader( program, vertexShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n	var gl = renderer.context;\r\n	var state = renderer.state;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n\r\n	var texture;\r\n\r\n	// decompose matrixWorld\r\n\r\n	var spritePosition = new THREE.Vector3();\r\n	var spriteRotation = new THREE.Quaternion();\r\n	var spriteScale = new THREE.Vector3();\r\n\r\n	function init() {\r\n\r\n		var vertices = new Float32Array( [\r\n			- 0.5, - 0.5,  0, 0,\r\n			  0.5, - 0.5,  1, 0,\r\n			  0.5,   0.5,  1, 1,\r\n			- 0.5,   0.5,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		vertexBuffer  = gl.createBuffer();\r\n		elementBuffer = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		program = createProgram();\r\n\r\n		attributes = {\r\n			position:			gl.getAttribLocation ( program, 'position' ),\r\n			uv:					gl.getAttribLocation ( program, 'uv' )\r\n		};\r\n\r\n		uniforms = {\r\n			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),\r\n			uvScale:			gl.getUniformLocation( program, 'uvScale' ),\r\n\r\n			rotation:			gl.getUniformLocation( program, 'rotation' ),\r\n			scale:				gl.getUniformLocation( program, 'scale' ),\r\n\r\n			color:				gl.getUniformLocation( program, 'color' ),\r\n			map:				gl.getUniformLocation( program, 'map' ),\r\n			opacity:			gl.getUniformLocation( program, 'opacity' ),\r\n\r\n			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),\r\n			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n			fogType:			gl.getUniformLocation( program, 'fogType' ),\r\n			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),\r\n			fogNear:			gl.getUniformLocation( program, 'fogNear' ),\r\n			fogFar:				gl.getUniformLocation( program, 'fogFar' ),\r\n			fogColor:			gl.getUniformLocation( program, 'fogColor' ),\r\n\r\n			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )\r\n		};\r\n\r\n		var canvas = document.createElement( 'canvas' );\r\n		canvas.width = 8;\r\n		canvas.height = 8;\r\n\r\n		var context = canvas.getContext( '2d' );\r\n		context.fillStyle = 'white';\r\n		context.fillRect( 0, 0, 8, 8 );\r\n\r\n		texture = new THREE.Texture( canvas );\r\n		texture.needsUpdate = true;\r\n\r\n	}\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		if ( sprites.length === 0 ) return;\r\n\r\n		// setup gl\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		state.initAttributes();\r\n		state.enableAttribute( attributes.position );\r\n		state.enableAttribute( attributes.uv );\r\n		state.disableUnusedAttributes();\r\n\r\n		state.disable( gl.CULL_FACE );\r\n		state.enable( gl.BLEND );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n		state.activeTexture( gl.TEXTURE0 );\r\n		gl.uniform1i( uniforms.map, 0 );\r\n\r\n		var oldFogType = 0;\r\n		var sceneFogType = 0;\r\n		var fog = scene.fog;\r\n\r\n		if ( fog ) {\r\n\r\n			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n			if ( fog instanceof THREE.Fog ) {\r\n\r\n				gl.uniform1f( uniforms.fogNear, fog.near );\r\n				gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n				gl.uniform1i( uniforms.fogType, 1 );\r\n				oldFogType = 1;\r\n				sceneFogType = 1;\r\n\r\n			} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n				gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n				gl.uniform1i( uniforms.fogType, 2 );\r\n				oldFogType = 2;\r\n				sceneFogType = 2;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			gl.uniform1i( uniforms.fogType, 0 );\r\n			oldFogType = 0;\r\n			sceneFogType = 0;\r\n\r\n		}\r\n\r\n\r\n		// update positions and sort\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n\r\n			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\r\n		}\r\n\r\n		sprites.sort( painterSortStable );\r\n\r\n		// render all sprites\r\n\r\n		var scale = [];\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n			var material = sprite.material;\r\n\r\n			gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\r\n			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n			scale[ 0 ] = spriteScale.x;\r\n			scale[ 1 ] = spriteScale.y;\r\n\r\n			var fogType = 0;\r\n\r\n			if ( scene.fog && material.fog ) {\r\n\r\n				fogType = sceneFogType;\r\n\r\n			}\r\n\r\n			if ( oldFogType !== fogType ) {\r\n\r\n				gl.uniform1i( uniforms.fogType, fogType );\r\n				oldFogType = fogType;\r\n\r\n			}\r\n\r\n			if ( material.map !== null ) {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n			} else {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n				gl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n			}\r\n\r\n			gl.uniform1f( uniforms.opacity, material.opacity );\r\n			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n			gl.uniform1f( uniforms.rotation, material.rotation );\r\n			gl.uniform2fv( uniforms.scale, scale );\r\n\r\n			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n			state.setDepthTest( material.depthTest );\r\n			state.setDepthWrite( material.depthWrite );\r\n\r\n			if ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n				renderer.setTexture( material.map, 0 );\r\n\r\n			} else {\r\n\r\n				renderer.setTexture( texture, 0 );\r\n\r\n			}\r\n\r\n			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		state.enable( gl.CULL_FACE );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram () {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n		gl.shaderSource( vertexShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform mat4 modelViewMatrix;',\r\n			'uniform mat4 projectionMatrix;',\r\n			'uniform float rotation;',\r\n			'uniform vec2 scale;',\r\n			'uniform vec2 uvOffset;',\r\n			'uniform vec2 uvScale;',\r\n\r\n			'attribute vec2 position;',\r\n			'attribute vec2 uv;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vUV = uvOffset + uv * uvScale;',\r\n\r\n				'vec2 alignedPosition = position * scale;',\r\n\r\n				'vec2 rotatedPosition;',\r\n				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n				'vec4 finalPosition;',\r\n\r\n				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n				'finalPosition.xy += rotatedPosition;',\r\n				'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n				'gl_Position = finalPosition;',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.shaderSource( fragmentShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform vec3 color;',\r\n			'uniform sampler2D map;',\r\n			'uniform float opacity;',\r\n\r\n			'uniform int fogType;',\r\n			'uniform vec3 fogColor;',\r\n			'uniform float fogDensity;',\r\n			'uniform float fogNear;',\r\n			'uniform float fogFar;',\r\n			'uniform float alphaTest;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vec4 texture = texture2D( map, vUV );',\r\n\r\n				'if ( texture.a < alphaTest ) discard;',\r\n\r\n				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n				'if ( fogType > 0 ) {',\r\n\r\n					'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n					'float fogFactor = 0.0;',\r\n\r\n					'if ( fogType == 1 ) {',\r\n\r\n						'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n					'} else {',\r\n\r\n						'const float LOG2 = 1.442695;',\r\n						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n					'}',\r\n\r\n					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n				'}',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.compileShader( vertexShader );\r\n		gl.compileShader( fragmentShader );\r\n\r\n		gl.attachShader( program, vertexShader );\r\n		gl.attachShader( program, fragmentShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n	function painterSortStable ( a, b ) {\r\n		\r\n		if ( a.renderOrder !== b.renderOrder ) {\r\n\r\n			return a.renderOrder - b.renderOrder;\r\n\r\n		} else if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return b.id - a.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/Three.Legacy.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.defineProperties( THREE.Box2.prototype, {\r\n	empty: {\r\n		value: function () {\r\n			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n			return this.isEmpty();\r\n		}\r\n	},\r\n	isIntersectionBox: {\r\n		value: function ( box ) {\r\n			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n			return this.intersectsBox( box );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Box3.prototype, {\r\n	empty: {\r\n		value: function () {\r\n			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n			return this.isEmpty();\r\n		}\r\n	},\r\n	isIntersectionBox: {\r\n		value: function ( box ) {\r\n			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n			return this.intersectsBox( box );\r\n		}\r\n	},\r\n	isIntersectionSphere: {\r\n		value: function ( sphere ) {\r\n			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n			return this.intersectsSphere( sphere );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix3.prototype, {\r\n	multiplyVector3: {\r\n		value: function ( vector ) {\r\n			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n			return vector.applyMatrix3( this );\r\n		}\r\n	},\r\n	multiplyVector3Array: {\r\n		value: function ( a ) {\r\n			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n			return this.applyToVector3Array( a );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix4.prototype, {\r\n	extractPosition: {\r\n		value: function ( m ) {\r\n			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n			return this.copyPosition( m );\r\n		}\r\n	},\r\n	setRotationFromQuaternion: {\r\n		value: function ( q ) {\r\n			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n			return this.makeRotationFromQuaternion( q );\r\n		}\r\n	},\r\n	multiplyVector3: {\r\n		value: function ( vector ) {\r\n			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n			return vector.applyProjection( this );\r\n		}\r\n	},\r\n	multiplyVector4: {\r\n		value: function ( vector ) {\r\n			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n			return vector.applyMatrix4( this );\r\n		}\r\n	},\r\n	multiplyVector3Array: {\r\n		value: function ( a ) {\r\n			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n			return this.applyToVector3Array( a );\r\n		}\r\n	},\r\n	rotateAxis: {\r\n		value: function ( v ) {\r\n			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n			v.transformDirection( this );\r\n		}\r\n	},\r\n	crossVector: {\r\n		value: function ( vector ) {\r\n			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n			return vector.applyMatrix4( this );\r\n		}\r\n	},\r\n	translate: {\r\n		value: function ( v ) {\r\n			console.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n		}\r\n	},\r\n	rotateX: {\r\n		value: function ( angle ) {\r\n			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n		}\r\n	},\r\n	rotateY: {\r\n		value: function ( angle ) {\r\n			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n		}\r\n	},\r\n	rotateZ: {\r\n		value: function ( angle ) {\r\n			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n		}\r\n	},\r\n	rotateByAxis: {\r\n		value: function ( axis, angle ) {\r\n			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Plane.prototype, {\r\n	isIntersectionLine: {\r\n		value: function ( line ) {\r\n			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n			return this.intersectsLine( line );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Quaternion.prototype, {\r\n	multiplyVector3: {\r\n		value: function ( vector ) {\r\n			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n			return vector.applyQuaternion( this );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Ray.prototype, {\r\n	isIntersectionBox: {\r\n		value: function ( box ) {\r\n			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n			return this.intersectsBox( box );\r\n		}\r\n	},\r\n	isIntersectionPlane: {\r\n		value: function ( plane ) {\r\n			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n			return this.intersectsPlane( plane );\r\n		}\r\n	},\r\n	isIntersectionSphere: {\r\n		value: function ( sphere ) {\r\n			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n			return this.intersectsSphere( sphere );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.Vector3.prototype, {\r\n	setEulerFromRotationMatrix: {\r\n		value: function () {\r\n			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n		}\r\n	},\r\n	setEulerFromQuaternion: {\r\n		value: function () {\r\n			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n		}\r\n	},\r\n	getPositionFromMatrix: {\r\n		value: function ( m ) {\r\n			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n			return this.setFromMatrixPosition( m );\r\n		}\r\n	},\r\n	getScaleFromMatrix: {\r\n		value: function ( m ) {\r\n			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n			return this.setFromMatrixScale( m );\r\n		}\r\n	},\r\n	getColumnFromMatrix: {\r\n		value: function ( index, matrix ) {\r\n			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n			return this.setFromMatrixColumn( index, matrix );\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n	return new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Object3D.prototype, {\r\n	eulerOrder: {\r\n		get: function () {\r\n			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n			return this.rotation.order;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n			this.rotation.order = value;\r\n		}\r\n	},\r\n	getChildByName: {\r\n		value: function ( name ) {\r\n			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n			return this.getObjectByName( name );\r\n		}\r\n	},\r\n	renderDepth: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n		}\r\n	},\r\n	translate: {\r\n		value: function ( distance, axis ) {\r\n			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n			return this.translateOnAxis( axis, distance );\r\n		}\r\n	},\r\n	useQuaternion: {\r\n		get: function () {\r\n			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE, {\r\n	PointCloud: {\r\n		value: function ( geometry, material ) {\r\n			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n			return new THREE.Points( geometry, material );\r\n		}\r\n	},\r\n	ParticleSystem: {\r\n		value: function ( geometry, material ) {\r\n			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n			return new THREE.Points( geometry, material );\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Light.prototype, {\r\n	onlyShadow: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n		}\r\n	},\r\n	shadowCameraFov: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n			this.shadow.camera.fov = value;\r\n		}\r\n	},\r\n	shadowCameraLeft: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n			this.shadow.camera.left = value;\r\n		}\r\n	},\r\n	shadowCameraRight: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n			this.shadow.camera.right = value;\r\n		}\r\n	},\r\n	shadowCameraTop: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n			this.shadow.camera.top = value;\r\n		}\r\n	},\r\n	shadowCameraBottom: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n			this.shadow.camera.bottom = value;\r\n		}\r\n	},\r\n	shadowCameraNear: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n			this.shadow.camera.near = value;\r\n		}\r\n	},\r\n	shadowCameraFar: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n			this.shadow.camera.far = value;\r\n		}\r\n	},\r\n	shadowCameraVisible: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n		}\r\n	},\r\n	shadowBias: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n			this.shadow.bias = value;\r\n		}\r\n	},\r\n	shadowDarkness: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n		}\r\n	},\r\n	shadowMapWidth: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n			this.shadow.mapSize.width = value;\r\n		}\r\n	},\r\n	shadowMapHeight: {\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n			this.shadow.mapSize.height = value;\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n	length: {\r\n		get: function () {\r\n			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n			return this.array.length;\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n	drawcalls: {\r\n		get: function () {\r\n			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n			return this.groups;\r\n		}\r\n	},\r\n	offsets: {\r\n		get: function () {\r\n			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n			return this.groups;\r\n		}\r\n	},\r\n	addIndex: {\r\n		value: function ( index ) {\r\n			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n			this.setIndex( index );\r\n		}\r\n	},\r\n	addDrawCall: {\r\n		value: function ( start, count, indexOffset ) {\r\n			if ( indexOffset !== undefined ) {\r\n				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n			}\r\n			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n			this.addGroup( start, count );\r\n		}\r\n	},\r\n	clearDrawCalls: {\r\n		value: function () {\r\n			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n			this.clearGroups();\r\n		}\r\n	},\r\n	computeTangents: {\r\n		value: function () {\r\n			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n		}\r\n	},\r\n	computeOffsets: {\r\n		value: function () {\r\n			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Material.prototype, {\r\n	wrapAround: {\r\n		get: function () {\r\n			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n		}\r\n	},\r\n	wrapRGB: {\r\n		get: function () {\r\n			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n			return new THREE.Color();\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE, {\r\n	PointCloudMaterial: {\r\n		value: function ( parameters ) {\r\n			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n			return new THREE.PointsMaterial( parameters );\r\n		}\r\n	},\r\n	ParticleBasicMaterial: {\r\n		value: function ( parameters ) {\r\n			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n			return new THREE.PointsMaterial( parameters );\r\n		}\r\n	},\r\n	ParticleSystemMaterial:{\r\n		value: function ( parameters ) {\r\n			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n			return new THREE.PointsMaterial( parameters );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n	metal: {\r\n		get: function () {\r\n			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n			return false;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n		}\r\n	}\r\n} );\r\n\r\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n	derivatives: {\r\n		get: function () {\r\n			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n			return this.extensions.derivatives;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n			this.extensions.derivatives = value;\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n	supportsFloatTextures: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n			return this.extensions.get( 'OES_texture_float' );\r\n		}\r\n	},\r\n	supportsHalfFloatTextures: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n			return this.extensions.get( 'OES_texture_half_float' );\r\n		}\r\n	},\r\n	supportsStandardDerivatives: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n			return this.extensions.get( 'OES_standard_derivatives' );\r\n		}\r\n	},\r\n	supportsCompressedTextureS3TC: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n		}\r\n	},\r\n	supportsCompressedTexturePVRTC: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n		}\r\n	},\r\n	supportsBlendMinMax: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n			return this.extensions.get( 'EXT_blend_minmax' );\r\n		}\r\n	},\r\n	supportsVertexTextures: {\r\n		value: function () {\r\n			return this.capabilities.vertexTextures;\r\n		}\r\n	},\r\n	supportsInstancedArrays: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n			return this.extensions.get( 'ANGLE_instanced_arrays' );\r\n		}\r\n	},\r\n	enableScissorTest: {\r\n		value: function ( boolean ) {\r\n			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n			this.setScissorTest( boolean );\r\n		}\r\n	},\r\n	initMaterial: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n		}\r\n	},\r\n	addPrePlugin: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n		}\r\n	},\r\n	addPostPlugin: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n		}\r\n	},\r\n	updateShadowMap: {\r\n		value: function () {\r\n			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n		}\r\n	},\r\n	shadowMapEnabled: {\r\n		get: function () {\r\n			return this.shadowMap.enabled;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n			this.shadowMap.enabled = value;\r\n		}\r\n	},\r\n	shadowMapType: {\r\n		get: function () {\r\n			return this.shadowMap.type;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n			this.shadowMap.type = value;\r\n		}\r\n	},\r\n	shadowMapCullFace: {\r\n		get: function () {\r\n			return this.shadowMap.cullFace;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n			this.shadowMap.cullFace = value;\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n	wrapS: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n			return this.texture.wrapS;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n			this.texture.wrapS = value;\r\n		}\r\n	},\r\n	wrapT: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n			return this.texture.wrapT;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n			this.texture.wrapT = value;\r\n		}\r\n	},\r\n	magFilter: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n			return this.texture.magFilter;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n			this.texture.magFilter = value;\r\n		}\r\n	},\r\n	minFilter: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n			return this.texture.minFilter;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n			this.texture.minFilter = value;\r\n		}\r\n	},\r\n	anisotropy: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n			return this.texture.anisotropy;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n			this.texture.anisotropy = value;\r\n		}\r\n	},\r\n	offset: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n			return this.texture.offset;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n			this.texture.offset = value;\r\n		}\r\n	},\r\n	repeat: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n			return this.texture.repeat;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n			this.texture.repeat = value;\r\n		}\r\n	},\r\n	format: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n			return this.texture.format;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n			this.texture.format = value;\r\n		}\r\n	},\r\n	type: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n			return this.texture.type;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n			this.texture.type = value;\r\n		}\r\n	},\r\n	generateMipmaps: {\r\n		get: function () {\r\n			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n			return this.texture.generateMipmaps;\r\n		},\r\n		set: function ( value ) {\r\n			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n			this.texture.generateMipmaps = value;\r\n		}\r\n	}\r\n} );\r\n\r\n//\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n	merge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n		var matrix;\r\n\r\n		if ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n			geometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n			matrix = geometry2.matrix;\r\n			geometry2 = geometry2.geometry;\r\n\r\n		}\r\n\r\n		geometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n	},\r\n\r\n	center: function ( geometry ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n		return geometry.center();\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ImageUtils = {\r\n\r\n	crossOrigin: undefined,\r\n\r\n	loadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\r\n		var loader = new THREE.TextureLoader();\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n\r\n		var texture = loader.load( url, onLoad, undefined, onError );\r\n\r\n		if ( mapping ) texture.mapping = mapping;\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\r\n		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\r\n		var loader = new THREE.CubeTextureLoader();\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n\r\n		var texture = loader.load( urls, onLoad, undefined, onError );\r\n\r\n		if ( mapping ) texture.mapping = mapping;\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadCompressedTexture: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n	},\r\n\r\n	loadCompressedTextureCube: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Projector = function () {\r\n\r\n	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n	this.projectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n		vector.project( camera );\r\n\r\n	};\r\n\r\n	this.unprojectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n		vector.unproject( camera );\r\n\r\n	};\r\n\r\n	this.pickingRay = function ( vector, camera ) {\r\n\r\n		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n	};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n	this.domElement = document.createElement( 'canvas' );\r\n	this.clear = function () {};\r\n	this.render = function () {};\r\n	this.setClearColor = function () {};\r\n	this.setSize = function () {};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\r\n// File:src/extras/CurveUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.CurveUtils = {\r\n\r\n	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n	},\r\n\r\n	// Puay Bing, thanks for helping with this derivative!\r\n\r\n	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n			3 * t * t * p3;\r\n\r\n	},\r\n\r\n	tangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		// To check if my formulas are correct\r\n\r\n		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1\r\n		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2\r\n		var h11 = 3 * t * t - 2 * t;	// t3 − t2\r\n\r\n		return h00 + h10 + h01 + h11;\r\n\r\n	},\r\n\r\n	// Catmull-Rom\r\n\r\n	interpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5;\r\n		var v1 = ( p3 - p1 ) * 0.5;\r\n		var t2 = t * t;\r\n		var t3 = t * t2;\r\n		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n	createMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n		var group = new THREE.Group();\r\n\r\n		for ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n			group.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n		}\r\n\r\n		return group;\r\n\r\n	},\r\n\r\n	detach: function ( child, parent, scene ) {\r\n\r\n		child.applyMatrix( parent.matrixWorld );\r\n		parent.remove( child );\r\n		scene.add( child );\r\n\r\n	},\r\n\r\n	attach: function ( child, scene, parent ) {\r\n\r\n		var matrixWorldInverse = new THREE.Matrix4();\r\n		matrixWorldInverse.getInverse( parent.matrixWorld );\r\n		child.applyMatrix( matrixWorldInverse );\r\n\r\n		scene.remove( child );\r\n		parent.add( child );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/ShapeUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.ShapeUtils = {\r\n\r\n	// calculate area of the contour polygon\r\n\r\n	area: function ( contour ) {\r\n\r\n		var n = contour.length;\r\n		var a = 0.0;\r\n\r\n		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n		}\r\n\r\n		return a * 0.5;\r\n\r\n	},\r\n\r\n	triangulate: ( function () {\r\n\r\n		/**\r\n		 * This code is a quick port of code written in C++ which was submitted to\r\n		 * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n		 * See original code and more information here:\r\n		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n		 *\r\n		 * ported to actionscript by Zevan Rosser\r\n		 * www.actionsnippet.com\r\n		 *\r\n		 * ported to javascript by Joshua Koo\r\n		 * http://www.lab4games.net/zz85/blog\r\n		 *\r\n		 */\r\n\r\n		function snip( contour, u, v, w, n, verts ) {\r\n\r\n			var p;\r\n			var ax, ay, bx, by;\r\n			var cx, cy, px, py;\r\n\r\n			ax = contour[ verts[ u ] ].x;\r\n			ay = contour[ verts[ u ] ].y;\r\n\r\n			bx = contour[ verts[ v ] ].x;\r\n			by = contour[ verts[ v ] ].y;\r\n\r\n			cx = contour[ verts[ w ] ].x;\r\n			cy = contour[ verts[ w ] ].y;\r\n\r\n			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n			var aX, aY, bX, bY, cX, cY;\r\n			var apx, apy, bpx, bpy, cpx, cpy;\r\n			var cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n			aX = cx - bx;  aY = cy - by;\r\n			bX = ax - cx;  bY = ay - cy;\r\n			cX = bx - ax;  cY = by - ay;\r\n\r\n			for ( p = 0; p < n; p ++ ) {\r\n\r\n				px = contour[ verts[ p ] ].x;\r\n				py = contour[ verts[ p ] ].y;\r\n\r\n				if ( ( ( px === ax ) && ( py === ay ) ) ||\r\n					 ( ( px === bx ) && ( py === by ) ) ||\r\n					 ( ( px === cx ) && ( py === cy ) ) )	continue;\r\n\r\n				apx = px - ax;  apy = py - ay;\r\n				bpx = px - bx;  bpy = py - by;\r\n				cpx = px - cx;  cpy = py - cy;\r\n\r\n				// see if p is inside triangle abc\r\n\r\n				aCROSSbp = aX * bpy - aY * bpx;\r\n				cCROSSap = cX * apy - cY * apx;\r\n				bCROSScp = bX * cpy - bY * cpx;\r\n\r\n				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\r\n			}\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		// takes in an contour array and returns\r\n\r\n		return function ( contour, indices ) {\r\n\r\n			var n = contour.length;\r\n\r\n			if ( n < 3 ) return null;\r\n\r\n			var result = [],\r\n				verts = [],\r\n				vertIndices = [];\r\n\r\n			/* we want a counter-clockwise polygon in verts */\r\n\r\n			var u, v, w;\r\n\r\n			if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\r\n				for ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n			} else {\r\n\r\n				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n			}\r\n\r\n			var nv = n;\r\n\r\n			/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n			var count = 2 * nv;   /* error detection */\r\n\r\n			for ( v = nv - 1; nv > 2; ) {\r\n\r\n				/* if we loop, it is probably a non-simple polygon */\r\n\r\n				if ( ( count -- ) <= 0 ) {\r\n\r\n					//** Triangulate: ERROR - probable bad polygon!\r\n\r\n					//throw ( \"Warning, unable to triangulate polygon!\" );\r\n					//return null;\r\n					// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\r\n					if ( indices ) return vertIndices;\r\n					return result;\r\n\r\n				}\r\n\r\n				/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */\r\n				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n				if ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n					var a, b, c, s, t;\r\n\r\n					/* true names of the vertices */\r\n\r\n					a = verts[ u ];\r\n					b = verts[ v ];\r\n					c = verts[ w ];\r\n\r\n					/* output Triangle */\r\n\r\n					result.push( [ contour[ a ],\r\n						contour[ b ],\r\n						contour[ c ] ] );\r\n\r\n\r\n					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n					/* remove v from the remaining polygon */\r\n\r\n					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n						verts[ s ] = verts[ t ];\r\n\r\n					}\r\n\r\n					nv --;\r\n\r\n					/* reset error detection counter */\r\n\r\n					count = 2 * nv;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( indices ) return vertIndices;\r\n			return result;\r\n\r\n		}\r\n\r\n	} )(),\r\n\r\n	triangulateShape: function ( contour, holes ) {\r\n\r\n		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\r\n			// inOtherPt needs to be collinear to the inSegment\r\n			if ( inSegPt1.x !== inSegPt2.x ) {\r\n\r\n				if ( inSegPt1.x < inSegPt2.x ) {\r\n\r\n					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\r\n				} else {\r\n\r\n					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				if ( inSegPt1.y < inSegPt2.y ) {\r\n\r\n					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\r\n				} else {\r\n\r\n					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\r\n			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;\r\n			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n			if ( Math.abs( limit ) > Number.EPSILON ) {\r\n\r\n				// not parallel\r\n\r\n				var perpSeg2;\r\n				if ( limit > 0 ) {\r\n\r\n					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];\r\n\r\n				} else {\r\n\r\n					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];\r\n\r\n				}\r\n\r\n				// i.e. to reduce rounding errors\r\n				// intersection at endpoint of segment#1?\r\n				if ( perpSeg2 === 0 ) {\r\n\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];\r\n					return [ inSeg1Pt1 ];\r\n\r\n				}\r\n				if ( perpSeg2 === limit ) {\r\n\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];\r\n					return [ inSeg1Pt2 ];\r\n\r\n				}\r\n				// intersection at endpoint of segment#2?\r\n				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];\r\n				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];\r\n\r\n				// return real intersection point\r\n				var factorSeg1 = perpSeg2 / limit;\r\n				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n			} else {\r\n\r\n				// parallel or collinear\r\n				if ( ( perpSeg1 !== 0 ) ||\r\n					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];\r\n\r\n				// they are collinear or degenerate\r\n				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?\r\n				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?\r\n				// both segments are points\r\n				if ( seg1Pt && seg2Pt ) {\r\n\r\n					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points\r\n					return [ inSeg1Pt1 ];                 						// they are the same point\r\n\r\n				}\r\n				// segment#1  is a single point\r\n				if ( seg1Pt ) {\r\n\r\n					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2\r\n					return [ inSeg1Pt1 ];\r\n\r\n				}\r\n				// segment#2  is a single point\r\n				if ( seg2Pt ) {\r\n\r\n					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1\r\n					return [ inSeg2Pt1 ];\r\n\r\n				}\r\n\r\n				// they are collinear segments, which might overlap\r\n				var seg1min, seg1max, seg1minVal, seg1maxVal;\r\n				var seg2min, seg2max, seg2minVal, seg2maxVal;\r\n				if ( seg1dx !== 0 ) {\r\n\r\n					// the segments are NOT on a vertical line\r\n					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\r\n					} else {\r\n\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\r\n					}\r\n					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\r\n					} else {\r\n\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					// the segments are on a vertical line\r\n					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\r\n					} else {\r\n\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\r\n					}\r\n					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\r\n					} else {\r\n\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\r\n					}\r\n\r\n				}\r\n				if ( seg1minVal <= seg2minVal ) {\r\n\r\n					if ( seg1maxVal <  seg2minVal )	return [];\r\n					if ( seg1maxVal === seg2minVal )	{\r\n\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg2min ];\r\n\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];\r\n					return	[ seg2min, seg2max ];\r\n\r\n				} else {\r\n\r\n					if ( seg1minVal >  seg2maxVal )	return [];\r\n					if ( seg1minVal === seg2maxVal )	{\r\n\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg1min ];\r\n\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];\r\n					return	[ seg1min, seg2max ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\r\n			// The order of legs is important\r\n\r\n			// translation of all points, so that Vertex is at (0,0)\r\n			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;\r\n			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;\r\n			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;\r\n\r\n			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\r\n				// angle != 180 deg.\r\n\r\n				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;\r\n				// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n				if ( from2toAngle > 0 ) {\r\n\r\n					// main angle < 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\r\n				} else {\r\n\r\n					// main angle > 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// angle == 180 deg.\r\n				// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n				return	( from2otherAngle > 0 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		function removeHoles( contour, holes ) {\r\n\r\n			var shape = contour.concat(); // work on this shape\r\n			var hole;\r\n\r\n			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\r\n				// Check if hole point lies within angle around shape point\r\n				var lastShapeIdx = shape.length - 1;\r\n\r\n				var prevShapeIdx = inShapeIdx - 1;\r\n				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;\r\n\r\n				var nextShapeIdx = inShapeIdx + 1;\r\n				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;\r\n\r\n				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n				if ( ! insideAngle ) {\r\n\r\n					// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n					return	false;\r\n\r\n				}\r\n\r\n				// Check if shape point lies within angle around hole point\r\n				var lastHoleIdx = hole.length - 1;\r\n\r\n				var prevHoleIdx = inHoleIdx - 1;\r\n				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;\r\n\r\n				var nextHoleIdx = inHoleIdx + 1;\r\n				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;\r\n\r\n				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n				if ( ! insideAngle ) {\r\n\r\n					// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n					return	false;\r\n\r\n				}\r\n\r\n				return	true;\r\n\r\n			}\r\n\r\n			function intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\r\n				// checks for intersections with shape edges\r\n				var sIdx, nextIdx, intersection;\r\n				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\r\n					nextIdx = sIdx + 1; nextIdx %= shape.length;\r\n					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n					if ( intersection.length > 0 )		return	true;\r\n\r\n				}\r\n\r\n				return	false;\r\n\r\n			}\r\n\r\n			var indepHoles = [];\r\n\r\n			function intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\r\n				// checks for intersections with hole edges\r\n				var ihIdx, chkHole,\r\n					hIdx, nextIdx, intersection;\r\n				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\r\n					chkHole = holes[ indepHoles[ ihIdx ]];\r\n					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\r\n						nextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n						if ( intersection.length > 0 )		return	true;\r\n\r\n					}\r\n\r\n				}\r\n				return	false;\r\n\r\n			}\r\n\r\n			var holeIndex, shapeIndex,\r\n				shapePt, holePt,\r\n				holeIdx, cutKey, failedCuts = [],\r\n				tmpShape1, tmpShape2,\r\n				tmpHole1, tmpHole2;\r\n\r\n			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n				indepHoles.push( h );\r\n\r\n			}\r\n\r\n			var minShapeIndex = 0;\r\n			var counter = indepHoles.length * 2;\r\n			while ( indepHoles.length > 0 ) {\r\n\r\n				counter --;\r\n				if ( counter < 0 ) {\r\n\r\n					console.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n					break;\r\n\r\n				}\r\n\r\n				// search for shape-vertex and hole-vertex,\r\n				// which can be connected without intersections\r\n				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n					shapePt = shape[ shapeIndex ];\r\n					holeIndex	= - 1;\r\n\r\n					// search for hole which can be reached without intersections\r\n					for ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\r\n						holeIdx = indepHoles[ h ];\r\n\r\n						// prevent multiple checks\r\n						cutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n						if ( failedCuts[ cutKey ] !== undefined )			continue;\r\n\r\n						hole = holes[ holeIdx ];\r\n						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n							holePt = hole[ h2 ];\r\n							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;\r\n							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;\r\n							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;\r\n\r\n							holeIndex = h2;\r\n							indepHoles.splice( h, 1 );\r\n\r\n							tmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n							tmpShape2 = shape.slice( shapeIndex );\r\n							tmpHole1 = hole.slice( holeIndex );\r\n							tmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n							minShapeIndex = shapeIndex;\r\n\r\n							// Debug only, to show the selected cuts\r\n							// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n							break;\r\n\r\n						}\r\n						if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n\r\n						failedCuts[ cutKey ] = true;			// remember failure\r\n\r\n					}\r\n					if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return shape; 			/* shape with no holes */\r\n\r\n		}\r\n\r\n\r\n		var i, il, f, face,\r\n			key, index,\r\n			allPointsMap = {};\r\n\r\n		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n		var allpoints = contour.concat();\r\n\r\n		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			Array.prototype.push.apply( allpoints, holes[ h ] );\r\n\r\n		}\r\n\r\n		//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n		// prepare all points map\r\n\r\n		for ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n			key = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n			if ( allPointsMap[ key ] !== undefined ) {\r\n\r\n				console.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n			}\r\n\r\n			allPointsMap[ key ] = i;\r\n\r\n		}\r\n\r\n		// remove holes by cutting paths to holes and adding them to the shape\r\n		var shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n		var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n		//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n		// check all face vertices against all points map\r\n\r\n		for ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n			face = triangles[ i ];\r\n\r\n			for ( f = 0; f < 3; f ++ ) {\r\n\r\n				key = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n				index = allPointsMap[ key ];\r\n\r\n				if ( index !== undefined ) {\r\n\r\n					face[ f ] = index;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return triangles.concat();\r\n\r\n	},\r\n\r\n	isClockWise: function ( pts ) {\r\n\r\n		return THREE.ShapeUtils.area( pts ) < 0;\r\n\r\n	},\r\n\r\n	// Bezier Curves formulas obtained from\r\n	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n	// Quad Bezier Functions\r\n\r\n	b2: ( function () {\r\n\r\n		function b2p0( t, p ) {\r\n\r\n			var k = 1 - t;\r\n			return k * k * p;\r\n\r\n		}\r\n\r\n		function b2p1( t, p ) {\r\n\r\n			return 2 * ( 1 - t ) * t * p;\r\n\r\n		}\r\n\r\n		function b2p2( t, p ) {\r\n\r\n			return t * t * p;\r\n\r\n		}\r\n\r\n		return function ( t, p0, p1, p2 ) {\r\n\r\n			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	// Cubic Bezier Functions\r\n\r\n	b3: ( function () {\r\n\r\n		function b3p0( t, p ) {\r\n\r\n			var k = 1 - t;\r\n			return k * k * k * p;\r\n\r\n		}\r\n\r\n		function b3p1( t, p ) {\r\n\r\n			var k = 1 - t;\r\n			return 3 * k * k * t * p;\r\n\r\n		}\r\n\r\n		function b3p2( t, p ) {\r\n\r\n			var k = 1 - t;\r\n			return 3 * k * t * t * p;\r\n\r\n		}\r\n\r\n		function b3p3( t, p ) {\r\n\r\n			return t * t * t * p;\r\n\r\n		}\r\n\r\n		return function ( t, p0, p1, p2, p3 ) {\r\n\r\n			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\r\n		};\r\n\r\n	} )()\r\n\r\n};\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Abstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\nTHREE.Curve.prototype = {\r\n\r\n	constructor: THREE.Curve,\r\n\r\n	// Virtual base class method to overwrite and implement in subclasses\r\n	//	- t [0 .. 1]\r\n\r\n	getPoint: function ( t ) {\r\n\r\n		console.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n		return null;\r\n\r\n	},\r\n\r\n	// Get point at relative position in curve according to arc length\r\n	// - u [0 .. 1]\r\n\r\n	getPointAt: function ( u ) {\r\n\r\n		var t = this.getUtoTmapping( u );\r\n		return this.getPoint( t );\r\n\r\n	},\r\n\r\n	// Get sequence of points using getPoint( t )\r\n\r\n	getPoints: function ( divisions ) {\r\n\r\n		if ( ! divisions ) divisions = 5;\r\n\r\n		var d, pts = [];\r\n\r\n		for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n			pts.push( this.getPoint( d / divisions ) );\r\n\r\n		}\r\n\r\n		return pts;\r\n\r\n	},\r\n\r\n	// Get sequence of points using getPointAt( u )\r\n\r\n	getSpacedPoints: function ( divisions ) {\r\n\r\n		if ( ! divisions ) divisions = 5;\r\n\r\n		var d, pts = [];\r\n\r\n		for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n			pts.push( this.getPointAt( d / divisions ) );\r\n\r\n		}\r\n\r\n		return pts;\r\n\r\n	},\r\n\r\n	// Get total curve arc length\r\n\r\n	getLength: function () {\r\n\r\n		var lengths = this.getLengths();\r\n		return lengths[ lengths.length - 1 ];\r\n\r\n	},\r\n\r\n	// Get list of cumulative segment lengths\r\n\r\n	getLengths: function ( divisions ) {\r\n\r\n		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\r\n		if ( this.cacheArcLengths\r\n			&& ( this.cacheArcLengths.length === divisions + 1 )\r\n			&& ! this.needsUpdate ) {\r\n\r\n			//console.log( \"cached\", this.cacheArcLengths );\r\n			return this.cacheArcLengths;\r\n\r\n		}\r\n\r\n		this.needsUpdate = false;\r\n\r\n		var cache = [];\r\n		var current, last = this.getPoint( 0 );\r\n		var p, sum = 0;\r\n\r\n		cache.push( 0 );\r\n\r\n		for ( p = 1; p <= divisions; p ++ ) {\r\n\r\n			current = this.getPoint ( p / divisions );\r\n			sum += current.distanceTo( last );\r\n			cache.push( sum );\r\n			last = current;\r\n\r\n		}\r\n\r\n		this.cacheArcLengths = cache;\r\n\r\n		return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n	},\r\n\r\n	updateArcLengths: function() {\r\n\r\n		this.needsUpdate = true;\r\n		this.getLengths();\r\n\r\n	},\r\n\r\n	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n	getUtoTmapping: function ( u, distance ) {\r\n\r\n		var arcLengths = this.getLengths();\r\n\r\n		var i = 0, il = arcLengths.length;\r\n\r\n		var targetArcLength; // The targeted u distance value to get\r\n\r\n		if ( distance ) {\r\n\r\n			targetArcLength = distance;\r\n\r\n		} else {\r\n\r\n			targetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n		}\r\n\r\n		//var time = Date.now();\r\n\r\n		// binary search for the index with largest value smaller than target u distance\r\n\r\n		var low = 0, high = il - 1, comparison;\r\n\r\n		while ( low <= high ) {\r\n\r\n			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n			comparison = arcLengths[ i ] - targetArcLength;\r\n\r\n			if ( comparison < 0 ) {\r\n\r\n				low = i + 1;\r\n\r\n			} else if ( comparison > 0 ) {\r\n\r\n				high = i - 1;\r\n\r\n			} else {\r\n\r\n				high = i;\r\n				break;\r\n\r\n				// DONE\r\n\r\n			}\r\n\r\n		}\r\n\r\n		i = high;\r\n\r\n		//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n		if ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n			var t = i / ( il - 1 );\r\n			return t;\r\n\r\n		}\r\n\r\n		// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n		var lengthBefore = arcLengths[ i ];\r\n		var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n		var segmentLength = lengthAfter - lengthBefore;\r\n\r\n		// determine where we are between the 'before' and 'after' points\r\n\r\n		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n		// add that fractional amount to t\r\n\r\n		var t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n		return t;\r\n\r\n	},\r\n\r\n	// Returns a unit vector tangent at t\r\n	// In case any sub curve does not implement its tangent derivation,\r\n	// 2 points a small delta apart will be used to find its gradient\r\n	// which seems to give a reasonable approximation\r\n\r\n	getTangent: function( t ) {\r\n\r\n		var delta = 0.0001;\r\n		var t1 = t - delta;\r\n		var t2 = t + delta;\r\n\r\n		// Capping in case of danger\r\n\r\n		if ( t1 < 0 ) t1 = 0;\r\n		if ( t2 > 1 ) t2 = 1;\r\n\r\n		var pt1 = this.getPoint( t1 );\r\n		var pt2 = this.getPoint( t2 );\r\n\r\n		var vec = pt2.clone().sub( pt1 );\r\n		return vec.normalize();\r\n\r\n	},\r\n\r\n	getTangentAt: function ( u ) {\r\n\r\n		var t = this.getUtoTmapping( u );\r\n		return this.getTangent( t );\r\n\r\n	}\r\n\r\n};\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *	3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n	constructor.prototype = Object.create( THREE.Curve.prototype );\r\n	constructor.prototype.constructor = constructor;\r\n	constructor.prototype.getPoint = getPointFunc;\r\n\r\n	return constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Curved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n	this.curves = [];\r\n\r\n	this.autoClose = false; // Automatically closes the path\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n	this.curves.push( curve );\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n	// TODO\r\n	// If the ending of curve is not connected to the starting\r\n	// or the next curve, then, this is not a real path\r\n};\r\n*/\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\r\n	// TODO Test\r\n	// and verify for vector3 (needs to implement equals)\r\n	// Add a line curve if start and end of lines are not connected\r\n	var startPoint = this.curves[ 0 ].getPoint( 0 );\r\n	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n	if ( ! startPoint.equals( endPoint ) ) {\r\n\r\n		this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\r\n	}\r\n\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n	var d = t * this.getLength();\r\n	var curveLengths = this.getCurveLengths();\r\n	var i = 0;\r\n\r\n	// To think about boundaries points.\r\n\r\n	while ( i < curveLengths.length ) {\r\n\r\n		if ( curveLengths[ i ] >= d ) {\r\n\r\n			var diff = curveLengths[ i ] - d;\r\n			var curve = this.curves[ i ];\r\n\r\n			var u = 1 - diff / curve.getLength();\r\n\r\n			return curve.getPointAt( u );\r\n\r\n		}\r\n\r\n		i ++;\r\n\r\n	}\r\n\r\n	return null;\r\n\r\n	// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};\r\n*/\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n	var lens = this.getCurveLengths();\r\n	return lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n	// We use cache values if curves and cache array are same length\r\n\r\n	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n		return this.cacheLengths;\r\n\r\n	}\r\n\r\n	// Get length of sub-curve\r\n	// Push sums into cached array\r\n\r\n	var lengths = [], sums = 0;\r\n\r\n	for ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n		sums += this.curves[ i ].getLength();\r\n		lengths.push( sums );\r\n\r\n	}\r\n\r\n	this.cacheLengths = lengths;\r\n\r\n	return lengths;\r\n\r\n};\r\n\r\n\r\n\r\n/**************************************************************\r\n *	Create Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getPoints( divisions );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistant sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getSpacedPoints( divisions );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n		var point = points[ i ];\r\n		geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n	}\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n// File:src/extras/core/Font.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Font = function ( data ) {\r\n\r\n	this.data = data;\r\n\r\n};\r\n\r\nTHREE.Font.prototype = {\r\n\r\n	constructor: THREE.Font,\r\n\r\n	generateShapes: function ( text, size, divisions ) {\r\n\r\n		function createPaths( text ) {\r\n\r\n			var chars = String( text ).split( '' );\r\n			var scale = size / data.resolution;\r\n			var offset = 0;\r\n\r\n			var paths = [];\r\n\r\n			for ( var i = 0; i < chars.length; i ++ ) {\r\n\r\n				var ret = createPath( chars[ i ], scale, offset );\r\n				offset += ret.offset;\r\n\r\n				paths.push( ret.path );\r\n\r\n			}\r\n\r\n			return paths;\r\n\r\n		}\r\n\r\n		function createPath( c, scale, offset ) {\r\n\r\n			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\r\n			if ( ! glyph ) return;\r\n\r\n			var path = new THREE.Path();\r\n\r\n			var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\r\n			if ( glyph.o ) {\r\n\r\n				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\r\n				for ( var i = 0, l = outline.length; i < l; ) {\r\n\r\n					var action = outline[ i ++ ];\r\n\r\n					switch ( action ) {\r\n\r\n						case 'm': // moveTo\r\n\r\n							x = outline[ i ++ ] * scale + offset;\r\n							y = outline[ i ++ ] * scale;\r\n\r\n							path.moveTo( x, y );\r\n\r\n							break;\r\n\r\n						case 'l': // lineTo\r\n\r\n							x = outline[ i ++ ] * scale + offset;\r\n							y = outline[ i ++ ] * scale;\r\n\r\n							path.lineTo( x, y );\r\n\r\n							break;\r\n\r\n						case 'q': // quadraticCurveTo\r\n\r\n							cpx  = outline[ i ++ ] * scale + offset;\r\n							cpy  = outline[ i ++ ] * scale;\r\n							cpx1 = outline[ i ++ ] * scale + offset;\r\n							cpy1 = outline[ i ++ ] * scale;\r\n\r\n							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n							laste = pts[ pts.length - 1 ];\r\n\r\n							if ( laste ) {\r\n\r\n								cpx0 = laste.x;\r\n								cpy0 = laste.y;\r\n\r\n								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n									var t = i2 / divisions;\r\n									b2( t, cpx0, cpx1, cpx );\r\n									b2( t, cpy0, cpy1, cpy );\r\n\r\n								}\r\n\r\n							}\r\n\r\n							break;\r\n\r\n						case 'b': // bezierCurveTo\r\n\r\n							cpx  = outline[ i ++ ] * scale + offset;\r\n							cpy  = outline[ i ++ ] * scale;\r\n							cpx1 = outline[ i ++ ] * scale + offset;\r\n							cpy1 = outline[ i ++ ] * scale;\r\n							cpx2 = outline[ i ++ ] * scale + offset;\r\n							cpy2 = outline[ i ++ ] * scale;\r\n\r\n							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n							laste = pts[ pts.length - 1 ];\r\n\r\n							if ( laste ) {\r\n\r\n								cpx0 = laste.x;\r\n								cpy0 = laste.y;\r\n\r\n								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n									var t = i2 / divisions;\r\n									b3( t, cpx0, cpx1, cpx2, cpx );\r\n									b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n								}\r\n\r\n							}\r\n\r\n							break;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return { offset: glyph.ha * scale, path: path };\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( size === undefined ) size = 100;\r\n		if ( divisions === undefined ) divisions = 4;\r\n\r\n		var data = this.data;\r\n\r\n		var paths = createPaths( text );\r\n		var shapes = [];\r\n\r\n		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n		}\r\n\r\n		return shapes;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n	THREE.CurvePath.call( this );\r\n\r\n	this.actions = [];\r\n\r\n	if ( points ) {\r\n\r\n		this.fromPoints( points );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n	for ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\r\n		this.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\r\n	}\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n	this.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.QuadraticBezierCurve(\r\n		new THREE.Vector2( x0, y0 ),\r\n		new THREE.Vector2( aCPx, aCPy ),\r\n		new THREE.Vector2( aX, aY )\r\n	);\r\n\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.CubicBezierCurve(\r\n		new THREE.Vector2( x0, y0 ),\r\n		new THREE.Vector2( aCP1x, aCP1y ),\r\n		new THREE.Vector2( aCP2x, aCP2y ),\r\n		new THREE.Vector2( aX, aY )\r\n	);\r\n\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var npts = [ new THREE.Vector2( x0, y0 ) ];\r\n	Array.prototype.push.apply( npts, pts );\r\n\r\n	var curve = new THREE.SplineCurve( npts );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: 'splineThru', args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absarc( aX + x0, aY + y0, aRadius,\r\n		aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	var args = [\r\n		aX, aY,\r\n		xRadius, yRadius,\r\n		aStartAngle, aEndAngle,\r\n		aClockwise,\r\n		aRotation || 0 // aRotation is optional.\r\n	];\r\n\r\n	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n	this.curves.push( curve );\r\n\r\n	var lastPoint = curve.getPoint( 1 );\r\n	args.push( lastPoint.x );\r\n	args.push( lastPoint.y );\r\n\r\n	this.actions.push( { action: 'ellipse', args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = 40;\r\n\r\n	var points = [];\r\n\r\n	for ( var i = 0; i < divisions; i ++ ) {\r\n\r\n		points.push( this.getPoint( i / divisions ) );\r\n\r\n		//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n	}\r\n\r\n	if ( this.autoClose ) {\r\n\r\n		points.push( points[ 0 ] );\r\n\r\n	}\r\n\r\n	return points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions ) {\r\n\r\n	divisions = divisions || 12;\r\n\r\n	var b2 = THREE.ShapeUtils.b2;\r\n	var b3 = THREE.ShapeUtils.b3;\r\n\r\n	var points = [];\r\n\r\n	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n		laste, tx, ty;\r\n\r\n	for ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\r\n		var item = this.actions[ i ];\r\n\r\n		var action = item.action;\r\n		var args = item.args;\r\n\r\n		switch ( action ) {\r\n\r\n		case 'moveTo':\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case 'lineTo':\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case 'quadraticCurveTo':\r\n\r\n			cpx  = args[ 2 ];\r\n			cpy  = args[ 3 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n			for ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n				var t = j / divisions;\r\n\r\n				tx = b2( t, cpx0, cpx1, cpx );\r\n				ty = b2( t, cpy0, cpy1, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case 'bezierCurveTo':\r\n\r\n			cpx  = args[ 4 ];\r\n			cpy  = args[ 5 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			cpx2 = args[ 2 ];\r\n			cpy2 = args[ 3 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n\r\n			for ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n				var t = j / divisions;\r\n\r\n				tx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n				ty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case 'splineThru':\r\n\r\n			laste = this.actions[ i - 1 ].args;\r\n\r\n			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n			var spts = [ last ];\r\n\r\n			var n = divisions * args[ 0 ].length;\r\n\r\n			spts = spts.concat( args[ 0 ] );\r\n\r\n			var spline = new THREE.SplineCurve( spts );\r\n\r\n			for ( var j = 1; j <= n; j ++ ) {\r\n\r\n				points.push( spline.getPointAt( j / n ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case 'arc':\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				aRadius = args[ 2 ],\r\n				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n				aClockwise = !! args[ 5 ];\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			for ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				var t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + aRadius * Math.cos( angle );\r\n				ty = aY + aRadius * Math.sin( angle );\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n			break;\r\n\r\n		case 'ellipse':\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				xRadius = args[ 2 ],\r\n				yRadius = args[ 3 ],\r\n				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n				aClockwise = !! args[ 6 ],\r\n				aRotation = args[ 7 ];\r\n\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			var cos, sin;\r\n			if ( aRotation !== 0 ) {\r\n\r\n				cos = Math.cos( aRotation );\r\n				sin = Math.sin( aRotation );\r\n\r\n			}\r\n\r\n			for ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				var t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + xRadius * Math.cos( angle );\r\n				ty = aY + yRadius * Math.sin( angle );\r\n\r\n				if ( aRotation !== 0 ) {\r\n\r\n					var x = tx, y = ty;\r\n\r\n					// Rotate the point about the center of the ellipse.\r\n					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\r\n				}\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n			break;\r\n\r\n		} // end switch\r\n\r\n	}\r\n\r\n\r\n\r\n	// Normalize to remove the closing point by default.\r\n	var lastPoint = points[ points.length - 1 ];\r\n	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n			 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n		points.splice( points.length - 1, 1 );\r\n\r\n	if ( this.autoClose ) {\r\n\r\n		points.push( points[ 0 ] );\r\n\r\n	}\r\n\r\n	return points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//	Assumptions (if parameter isCCW==true the opposite holds):\r\n//	- solid shapes are defined clockwise (CW)\r\n//	- holes are defined counterclockwise (CCW)\r\n//\r\n//	If parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n	function extractSubpaths( inActions ) {\r\n\r\n		var subPaths = [], lastPath = new THREE.Path();\r\n\r\n		for ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\r\n			var item = inActions[ i ];\r\n\r\n			var args = item.args;\r\n			var action = item.action;\r\n\r\n			if ( action === 'moveTo' ) {\r\n\r\n				if ( lastPath.actions.length !== 0 ) {\r\n\r\n					subPaths.push( lastPath );\r\n					lastPath = new THREE.Path();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			lastPath[ action ].apply( lastPath, args );\r\n\r\n		}\r\n\r\n		if ( lastPath.actions.length !== 0 ) {\r\n\r\n			subPaths.push( lastPath );\r\n\r\n		}\r\n\r\n		// console.log(subPaths);\r\n\r\n		return	subPaths;\r\n\r\n	}\r\n\r\n	function toShapesNoHoles( inSubpaths ) {\r\n\r\n		var shapes = [];\r\n\r\n		for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n			var tmpPath = inSubpaths[ i ];\r\n\r\n			var tmpShape = new THREE.Shape();\r\n			tmpShape.actions = tmpPath.actions;\r\n			tmpShape.curves = tmpPath.curves;\r\n\r\n			shapes.push( tmpShape );\r\n\r\n		}\r\n\r\n		//console.log(\"shape\", shapes);\r\n\r\n		return shapes;\r\n\r\n	}\r\n\r\n	function isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n		var polyLen = inPolygon.length;\r\n\r\n		// inPt on polygon contour => immediate success    or\r\n		// toggling of inside/outside at every single! intersection point of an edge\r\n		//  with the horizontal line through inPt, left of inPt\r\n		//  not counting lowerY endpoints of edges and whole edges on that line\r\n		var inside = false;\r\n		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n			var edgeLowPt  = inPolygon[ p ];\r\n			var edgeHighPt = inPolygon[ q ];\r\n\r\n			var edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n			var edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n			if ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n				// not parallel\r\n				if ( edgeDy < 0 ) {\r\n\r\n					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n				}\r\n				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;\r\n\r\n				if ( inPt.y === edgeLowPt.y ) {\r\n\r\n					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?\r\n					// continue;				// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n				} else {\r\n\r\n					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?\r\n					if ( perpEdge < 0 ) 				continue;\r\n					inside = ! inside;		// true intersection left of inPt\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// parallel or collinear\r\n				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel\r\n				// edge lies on the same horizontal line as inPt\r\n				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !\r\n				// continue;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return	inside;\r\n\r\n	}\r\n\r\n	var isClockWise = THREE.ShapeUtils.isClockWise;\r\n\r\n	var subPaths = extractSubpaths( this.actions );\r\n	if ( subPaths.length === 0 ) return [];\r\n\r\n	if ( noHoles === true )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	var solid, tmpPath, tmpShape, shapes = [];\r\n\r\n	if ( subPaths.length === 1 ) {\r\n\r\n		tmpPath = subPaths[ 0 ];\r\n		tmpShape = new THREE.Shape();\r\n		tmpShape.actions = tmpPath.actions;\r\n		tmpShape.curves = tmpPath.curves;\r\n		shapes.push( tmpShape );\r\n		return shapes;\r\n\r\n	}\r\n\r\n	var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n	holesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n	// console.log(\"Holes first\", holesFirst);\r\n\r\n	var betterShapeHoles = [];\r\n	var newShapes = [];\r\n	var newShapeHoles = [];\r\n	var mainIdx = 0;\r\n	var tmpPoints;\r\n\r\n	newShapes[ mainIdx ] = undefined;\r\n	newShapeHoles[ mainIdx ] = [];\r\n\r\n	for ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n		tmpPath = subPaths[ i ];\r\n		tmpPoints = tmpPath.getPoints();\r\n		solid = isClockWise( tmpPoints );\r\n		solid = isCCW ? ! solid : solid;\r\n\r\n		if ( solid ) {\r\n\r\n			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;\r\n\r\n			newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n			newShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n			newShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n			if ( holesFirst )	mainIdx ++;\r\n			newShapeHoles[ mainIdx ] = [];\r\n\r\n			//console.log('cw', i);\r\n\r\n		} else {\r\n\r\n			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n			//console.log('ccw', i);\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// only Holes? -> probably all Shapes with wrong orientation\r\n	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	if ( newShapes.length > 1 ) {\r\n\r\n		var ambiguous = false;\r\n		var toChange = [];\r\n\r\n		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n			betterShapeHoles[ sIdx ] = [];\r\n\r\n		}\r\n\r\n		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n			var sho = newShapeHoles[ sIdx ];\r\n\r\n			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n				var ho = sho[ hIdx ];\r\n				var hole_unassigned = true;\r\n\r\n				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n						if ( hole_unassigned ) {\r\n\r\n							hole_unassigned = false;\r\n							betterShapeHoles[ s2Idx ].push( ho );\r\n\r\n						} else {\r\n\r\n							ambiguous = true;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n				if ( hole_unassigned ) {\r\n\r\n					betterShapeHoles[ sIdx ].push( ho );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n		// console.log(\"ambiguous: \", ambiguous);\r\n		if ( toChange.length > 0 ) {\r\n\r\n			// console.log(\"to change: \", toChange);\r\n			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var tmpHoles;\r\n\r\n	for ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n		tmpShape = newShapes[ i ].s;\r\n		shapes.push( tmpShape );\r\n		tmpHoles = newShapeHoles[ i ];\r\n\r\n		for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n			tmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	//console.log(\"shape\", shapes);\r\n\r\n	return shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n	THREE.Path.apply( this, arguments );\r\n\r\n	this.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n	return new THREE.ExtrudeGeometry( this, options );\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n	return new THREE.ShapeGeometry( this, options );\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n	var holesPts = [];\r\n\r\n	for ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n		holesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n	}\r\n\r\n	return holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n	return {\r\n\r\n		shape: this.getPoints( divisions ),\r\n		holes: this.getPointsHoles( divisions )\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n	return this.extractAllPoints( divisions );\r\n\r\n};\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *	Line\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var point = this.v2.clone().sub( this.v1 );\r\n	point.multiplyScalar( t ).add( this.v1 );\r\n\r\n	return point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n	return this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tangent = this.v2.clone().sub( this.v1 );\r\n\r\n	return tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var b2 = THREE.ShapeUtils.b2;\r\n\r\n	return new THREE.Vector2(\r\n		b2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n		b2( t, this.v0.y, this.v1.y, this.v2.y )\r\n	);\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\r\n	return new THREE.Vector2(\r\n		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n	).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n	this.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var b3 = THREE.ShapeUtils.b3;\r\n\r\n	return new THREE.Vector2( \r\n		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n	);\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\r\n	return new THREE.Vector2( \r\n		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n	).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *	Spline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n	this.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var points = this.points;\r\n	var point = ( points.length - 1 ) * t;\r\n\r\n	var intPoint = Math.floor( point );\r\n	var weight = point - intPoint;\r\n\r\n	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n	var point1 = points[ intPoint ];\r\n	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n	var interpolate = THREE.CurveUtils.interpolate;\r\n\r\n	return new THREE.Vector2(\r\n		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n		interpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n	);\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *	Ellipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n	this.aX = aX;\r\n	this.aY = aY;\r\n\r\n	this.xRadius = xRadius;\r\n	this.yRadius = yRadius;\r\n\r\n	this.aStartAngle = aStartAngle;\r\n	this.aEndAngle = aEndAngle;\r\n\r\n	this.aClockwise = aClockwise;\r\n	\r\n	this.aRotation = aRotation || 0;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n	var angle;\r\n\r\n	if ( this.aClockwise === true ) {\r\n\r\n		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n	} else {\r\n\r\n		angle = this.aStartAngle + t * deltaAngle;\r\n\r\n	}\r\n	\r\n	var x = this.aX + this.xRadius * Math.cos( angle );\r\n	var y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n	if ( this.aRotation !== 0 ) {\r\n\r\n		var cos = Math.cos( this.aRotation );\r\n		var sin = Math.sin( this.aRotation );\r\n\r\n		var tx = x, ty = y;\r\n\r\n		// Rotate the point about the center of the ellipse.\r\n		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\r\n	}\r\n\r\n	return new THREE.Vector2( x, y );\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *	Arc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *	Line3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n	function ( v1, v2 ) {\r\n\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.subVectors( this.v2, this.v1 ); // diff\r\n		vector.multiplyScalar( t );\r\n		vector.add( this.v1 );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var b2 = THREE.ShapeUtils.b2;		\r\n\r\n		return new THREE.Vector3(\r\n			b2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n			b2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n			b2( t, this.v0.z, this.v1.z, this.v2.z )\r\n		);\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2, v3 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n		this.v3 = v3;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var b3 = THREE.ShapeUtils.b3;\r\n\r\n		return new THREE.Vector3(\r\n			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n		);\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n	function ( points /* array of Vector3 */ ) {\r\n\r\n		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n		this.points = ( points == undefined ) ? [] : points;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var points = this.points;\r\n		var point = ( points.length - 1 ) * t;\r\n\r\n		var intPoint = Math.floor( point );\r\n		var weight = point - intPoint;\r\n\r\n		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n		var point1 = points[ intPoint ];\r\n		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n		var interpolate = THREE.CurveUtils.interpolate;\r\n\r\n		return new THREE.Vector3(\r\n			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n			interpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n		);\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CatmullRomCurve3.js\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\nTHREE.CatmullRomCurve3 = ( function() {\r\n\r\n	var\r\n		tmp = new THREE.Vector3(),\r\n		px = new CubicPoly(),\r\n		py = new CubicPoly(),\r\n		pz = new CubicPoly();\r\n\r\n	/*\r\n	Based on an optimized c++ solution in\r\n	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n	 - http://ideone.com/NoEbVM\r\n\r\n	This CubicPoly class could be used for reusing some variables and calculations,\r\n	but for three.js curve use, it could be possible inlined and flatten into a single function call\r\n	which can be placed in CurveUtils.\r\n	*/\r\n\r\n	function CubicPoly() {\r\n\r\n	}\r\n\r\n	/*\r\n	 * Compute coefficients for a cubic polynomial\r\n	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n	 * such that\r\n	 *   p(0) = x0, p(1) = x1\r\n	 *  and\r\n	 *   p'(0) = t0, p'(1) = t1.\r\n	 */\r\n	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\r\n		this.c0 = x0;\r\n		this.c1 = t0;\r\n		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n	};\r\n\r\n	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n		// compute tangents when parameterized in [t1,t2]\r\n		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n		// rescale tangents for parametrization in [0,1]\r\n		t1 *= dt1;\r\n		t2 *= dt1;\r\n\r\n		// initCubicPoly\r\n		this.init( x1, x2, t1, t2 );\r\n\r\n	};\r\n\r\n	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\r\n		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n	};\r\n\r\n	CubicPoly.prototype.calc = function( t ) {\r\n\r\n		var t2 = t * t;\r\n		var t3 = t2 * t;\r\n		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\r\n	};\r\n\r\n	// Subclass Three.js curve\r\n	return THREE.Curve.create(\r\n\r\n		function ( p /* array of Vector3 */ ) {\r\n\r\n			this.points = p || [];\r\n			this.closed = false;\r\n\r\n		},\r\n\r\n		function ( t ) {\r\n\r\n			var points = this.points,\r\n				point, intPoint, weight, l;\r\n\r\n			l = points.length;\r\n\r\n			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\r\n			point = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n			intPoint = Math.floor( point );\r\n			weight = point - intPoint;\r\n\r\n			if ( this.closed ) {\r\n\r\n				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n			} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n				intPoint = l - 2;\r\n				weight = 1;\r\n\r\n			}\r\n\r\n			var p0, p1, p2, p3; // 4 points\r\n\r\n			if ( this.closed || intPoint > 0 ) {\r\n\r\n				p0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n			} else {\r\n\r\n				// extrapolate first point\r\n				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n				p0 = tmp;\r\n\r\n			}\r\n\r\n			p1 = points[ intPoint % l ];\r\n			p2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n			if ( this.closed || intPoint + 2 < l ) {\r\n\r\n				p3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n			} else {\r\n\r\n				// extrapolate last point\r\n				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n				p3 = tmp;\r\n\r\n			}\r\n\r\n			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\r\n				// init Centripetal / Chordal Catmull-Rom\r\n				var pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n				// safety check for repeated points\r\n				if ( dt1 < 1e-4 ) dt1 = 1.0;\r\n				if ( dt0 < 1e-4 ) dt0 = dt1;\r\n				if ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n			} else if ( this.type === 'catmullrom' ) {\r\n\r\n				var tension = this.tension !== undefined ? this.tension : 0.5;\r\n				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\r\n			}\r\n\r\n			var v = new THREE.Vector3(\r\n				px.calc( weight ),\r\n				py.calc( weight ),\r\n				pz.calc( weight )\r\n			);\r\n\r\n			return v;\r\n\r\n		}\r\n\r\n	);\r\n\r\n} )();\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Closed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\r\n	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\r\n	THREE.CatmullRomCurve3.call( this, points );\r\n	this.type = 'catmullrom';\r\n	this.closed = true;\r\n\r\n};\r\n\r\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'BoxGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		depth: depth,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		depthSegments: depthSegments\r\n	};\r\n\r\n	this.widthSegments = widthSegments || 1;\r\n	this.heightSegments = heightSegments || 1;\r\n	this.depthSegments = depthSegments || 1;\r\n\r\n	var scope = this;\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n	var depth_half = depth / 2;\r\n\r\n	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\r\n	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n		var w, ix, iy,\r\n		gridX = scope.widthSegments,\r\n		gridY = scope.heightSegments,\r\n		width_half = width / 2,\r\n		height_half = height / 2,\r\n		offset = scope.vertices.length;\r\n\r\n		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n			w = 'z';\r\n\r\n		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n			w = 'y';\r\n			gridY = scope.depthSegments;\r\n\r\n		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n			w = 'x';\r\n			gridX = scope.depthSegments;\r\n\r\n		}\r\n\r\n		var gridX1 = gridX + 1,\r\n		gridY1 = gridY + 1,\r\n		segment_width = width / gridX,\r\n		segment_height = height / gridY,\r\n		normal = new THREE.Vector3();\r\n\r\n		normal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n		for ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n				var vector = new THREE.Vector3();\r\n				vector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n				vector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n				vector[ w ] = depth;\r\n\r\n				scope.vertices.push( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n				var a = ix + gridX1 * iy;\r\n				var b = ix + gridX1 * ( iy + 1 );\r\n				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n				var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n				var face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n				face = new THREE.Face3( b + offset, c + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CircleGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		segments: segments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CircleBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'CircleBufferGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		segments: segments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n	segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	var vertices = segments + 2;\r\n\r\n	var positions = new Float32Array( vertices * 3 );\r\n	var normals = new Float32Array( vertices * 3 );\r\n	var uvs = new Float32Array( vertices * 2 );\r\n\r\n	// center data is already zero, but need to set a few extras\r\n	normals[ 2 ] = 1.0;\r\n	uvs[ 0 ] = 0.5;\r\n	uvs[ 1 ] = 0.5;\r\n\r\n	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\r\n		var segment = thetaStart + s / segments * thetaLength;\r\n\r\n		positions[ i ] = radius * Math.cos( segment );\r\n		positions[ i + 1 ] = radius * Math.sin( segment );\r\n\r\n		normals[ i + 2 ] = 1; // normal z\r\n\r\n		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n	}\r\n\r\n	var indices = [];\r\n\r\n	for ( var i = 1; i <= segments; i ++ ) {\r\n\r\n		indices.push( i, i + 1, 0 );\r\n\r\n	}\r\n\r\n	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CylinderGeometry';\r\n\r\n	this.parameters = {\r\n		radiusTop: radiusTop,\r\n		radiusBottom: radiusBottom,\r\n		height: height,\r\n		radialSegments: radialSegments,\r\n		heightSegments: heightSegments,\r\n		openEnded: openEnded,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n	height = height !== undefined ? height : 100;\r\n\r\n	radialSegments = radialSegments || 8;\r\n	heightSegments = heightSegments || 1;\r\n\r\n	openEnded = openEnded !== undefined ? openEnded : false;\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n	var heightHalf = height / 2;\r\n\r\n	var x, y, vertices = [], uvs = [];\r\n\r\n	for ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n		var uvsRow = [];\r\n\r\n		var v = y / heightSegments;\r\n		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n		for ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n			var u = x / radialSegments;\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n			vertex.y = - v * height + heightHalf;\r\n			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			verticesRow.push( this.vertices.length - 1 );\r\n			uvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n		uvs.push( uvsRow );\r\n\r\n	}\r\n\r\n	var tanTheta = ( radiusBottom - radiusTop ) / height;\r\n	var na, nb;\r\n\r\n	for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n		if ( radiusTop !== 0 ) {\r\n\r\n			na = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n		} else {\r\n\r\n			na = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n		}\r\n\r\n		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n		for ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x ];\r\n			var v2 = vertices[ y + 1 ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x + 1 ];\r\n			var v4 = vertices[ y ][ x + 1 ];\r\n\r\n			var n1 = na.clone();\r\n			var n2 = na.clone();\r\n			var n3 = nb.clone();\r\n			var n4 = nb.clone();\r\n\r\n			var uv1 = uvs[ y ][ x ].clone();\r\n			var uv2 = uvs[ y + 1 ][ x ].clone();\r\n			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n			var uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// top cap\r\n\r\n	if ( openEnded === false && radiusTop > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ 0 ][ x ];\r\n			var v2 = vertices[ 0 ][ x + 1 ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n			var uv1 = uvs[ 0 ][ x ].clone();\r\n			var uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// bottom cap\r\n\r\n	if ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ heightSegments ][ x + 1 ];\r\n			var v2 = vertices[ heightSegments ][ x ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n			var uv2 = uvs[ heightSegments ][ x ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/EdgesGeometry.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n	var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n\r\n	function sortFunction( a, b ) {\r\n\r\n		return a - b;\r\n\r\n	}\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n\r\n	var geometry2;\r\n\r\n	if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		geometry2 = new THREE.Geometry();\r\n		geometry2.fromBufferGeometry( geometry );\r\n\r\n	} else {\r\n\r\n		geometry2 = geometry.clone();\r\n\r\n	}\r\n\r\n	geometry2.mergeVertices();\r\n	geometry2.computeFaceNormals();\r\n\r\n	var vertices = geometry2.vertices;\r\n	var faces = geometry2.faces;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		var face = faces[ i ];\r\n\r\n		for ( var j = 0; j < 3; j ++ ) {\r\n\r\n			edge[ 0 ] = face[ keys[ j ] ];\r\n			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n			edge.sort( sortFunction );\r\n\r\n			var key = edge.toString();\r\n\r\n			if ( hash[ key ] === undefined ) {\r\n\r\n				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n			} else {\r\n\r\n				hash[ key ].face2 = i;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var coords = [];\r\n\r\n	for ( var key in hash ) {\r\n\r\n		var h = hash[ key ];\r\n\r\n		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n			var vertex = vertices[ h.vert1 ];\r\n			coords.push( vertex.x );\r\n			coords.push( vertex.y );\r\n			coords.push( vertex.z );\r\n\r\n			vertex = vertices[ h.vert2 ];\r\n			coords.push( vertex.x );\r\n			coords.push( vertex.y );\r\n			coords.push( vertex.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\r\n};\r\n\r\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n	if ( typeof( shapes ) === \"undefined\" ) {\r\n\r\n		shapes = [];\r\n		return;\r\n\r\n	}\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ExtrudeGeometry';\r\n\r\n	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n	// can't really use automatic vertex normals\r\n	// as then front and back sides get smoothed too\r\n	// should do separate smoothing just for sides\r\n\r\n	//this.computeVertexNormals();\r\n\r\n	//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n	var sl = shapes.length;\r\n\r\n	for ( var s = 0; s < sl; s ++ ) {\r\n\r\n		var shape = shapes[ s ];\r\n		this.addShape( shape, options );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	var amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n	var extrudePath = options.extrudePath;\r\n	var extrudePts, extrudeByPath = false;\r\n\r\n	// Use default WorldUVGenerator if no UV generators are specified.\r\n	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n	var splineTube, binormal, normal, position2;\r\n	if ( extrudePath ) {\r\n\r\n		extrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n		extrudeByPath = true;\r\n		bevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n		// SETUP TNB variables\r\n\r\n		// Reuse TNB from TubeGeomtry for now.\r\n		// TODO1 - have a .isClosed in spline?\r\n\r\n		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\r\n		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n		binormal = new THREE.Vector3();\r\n		normal = new THREE.Vector3();\r\n		position2 = new THREE.Vector3();\r\n\r\n	}\r\n\r\n	// Safeguards if bevels are not enabled\r\n\r\n	if ( ! bevelEnabled ) {\r\n\r\n		bevelSegments = 0;\r\n		bevelThickness = 0;\r\n		bevelSize = 0;\r\n\r\n	}\r\n\r\n	// Variables initialization\r\n\r\n	var ahole, h, hl; // looping of holes\r\n	var scope = this;\r\n\r\n	var shapesOffset = this.vertices.length;\r\n\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n\r\n			if ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n				holes[ h ] = ahole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n	}\r\n\r\n\r\n	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n	/* Vertices */\r\n\r\n	var contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n	for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		vertices = vertices.concat( ahole );\r\n\r\n	}\r\n\r\n\r\n	function scalePt2 ( pt, vec, size ) {\r\n\r\n		if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n		return vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n	}\r\n\r\n	var b, bs, t, z,\r\n		vert, vlen = vertices.length,\r\n		face, flen = faces.length;\r\n\r\n\r\n	// Find directions for point movement\r\n\r\n\r\n	function getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n		// computes for inPt the corresponding point inPt' on a new contour\r\n		//   shifted by 1 unit (length of normalized vector) to the left\r\n		// if we walk along contour clockwise, this new contour is outside the old one\r\n		//\r\n		// inPt' is the intersection of the two lines parallel to the two\r\n		//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt\r\n\r\n		// good reading for geometry algorithms (here: line-line intersection)\r\n		// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\r\n		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n		// check for collinear edges\r\n		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n		if ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n			// not collinear\r\n\r\n			// length of vectors for normalizing\r\n\r\n			var v_prev_len = Math.sqrt( v_prev_lensq );\r\n			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n			// shift adjacent points by unit vectors to the left\r\n\r\n			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n			// scaling factor for v_prev to intersection point\r\n\r\n			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n			// vector from inPt to intersection point\r\n\r\n			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n			// Don't normalize!, otherwise sharp corners become ugly\r\n			//  but prevent crazy spikes\r\n			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n			if ( v_trans_lensq <= 2 ) {\r\n\r\n				return	new THREE.Vector2( v_trans_x, v_trans_y );\r\n\r\n			} else {\r\n\r\n				shrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// handle special case of collinear edges\r\n\r\n			var direction_eq = false;		// assumes: opposite\r\n			if ( v_prev_x > Number.EPSILON ) {\r\n\r\n				if ( v_next_x > Number.EPSILON ) {\r\n\r\n					direction_eq = true;\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				if ( v_prev_x < - Number.EPSILON ) {\r\n\r\n					if ( v_next_x < - Number.EPSILON ) {\r\n\r\n						direction_eq = true;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n						direction_eq = true;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( direction_eq ) {\r\n\r\n				// console.log(\"Warning: lines are a straight sequence\");\r\n				v_trans_x = - v_prev_y;\r\n				v_trans_y =  v_prev_x;\r\n				shrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n			} else {\r\n\r\n				// console.log(\"Warning: lines are a straight spike\");\r\n				v_trans_x = v_prev_x;\r\n				v_trans_y = v_prev_y;\r\n				shrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n	}\r\n\r\n\r\n	var contourMovements = [];\r\n\r\n	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n		if ( j === il ) j = 0;\r\n		if ( k === il ) k = 0;\r\n\r\n		//  (j)---(i)---(k)\r\n		// console.log('i,j,k', i, j , k)\r\n\r\n		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n	}\r\n\r\n	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n	for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		oneHoleMovements = [];\r\n\r\n		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n			if ( j === il ) j = 0;\r\n			if ( k === il ) k = 0;\r\n\r\n			//  (j)---(i)---(k)\r\n			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n		}\r\n\r\n		holesMovements.push( oneHoleMovements );\r\n		verticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n	}\r\n\r\n\r\n	// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n	for ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n		//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n\r\n		//z = bevelThickness * t;\r\n		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n		//bs = bevelSize * t; // linear\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n			v( vert.x, vert.y,  - z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				v( vert.x, vert.y,  - z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	bs = bevelSize;\r\n\r\n	// Back facing vertices\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n		if ( ! extrudeByPath ) {\r\n\r\n			v( vert.x, vert.y, 0 );\r\n\r\n		} else {\r\n\r\n			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n			v( position2.x, position2.y, position2.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Add stepped vertices...\r\n	// Including front facing vertices\r\n\r\n	var s;\r\n\r\n	for ( s = 1; s <= steps; s ++ ) {\r\n\r\n		for ( i = 0; i < vlen; i ++ ) {\r\n\r\n			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n			if ( ! extrudeByPath ) {\r\n\r\n				v( vert.x, vert.y, amount / steps * s );\r\n\r\n			} else {\r\n\r\n				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n				v( position2.x, position2.y, position2.z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Add bevel segments planes\r\n\r\n	//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n	for ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n		bs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n			v( vert.x, vert.y,  amount + z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				if ( ! extrudeByPath ) {\r\n\r\n					v( vert.x, vert.y,  amount + z );\r\n\r\n				} else {\r\n\r\n					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	/* Faces */\r\n\r\n	// Top and bottom faces\r\n\r\n	buildLidFaces();\r\n\r\n	// Sides faces\r\n\r\n	buildSideFaces();\r\n\r\n\r\n	/////  Internal functions\r\n\r\n	function buildLidFaces() {\r\n\r\n		if ( bevelEnabled ) {\r\n\r\n			var layer = 0; // steps + 1\r\n			var offset = vlen * layer;\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n			}\r\n\r\n			layer = steps + bevelSegments * 2;\r\n			offset = vlen * layer;\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n			}\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Create faces for the z-sides of the shape\r\n\r\n	function buildSideFaces() {\r\n\r\n		var layeroffset = 0;\r\n		sidewalls( contour, layeroffset );\r\n		layeroffset += contour.length;\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			sidewalls( ahole, layeroffset );\r\n\r\n			//, true\r\n			layeroffset += ahole.length;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function sidewalls( contour, layeroffset ) {\r\n\r\n		var j, k;\r\n		i = contour.length;\r\n\r\n		while ( -- i >= 0 ) {\r\n\r\n			j = i;\r\n			k = i - 1;\r\n			if ( k < 0 ) k = contour.length - 1;\r\n\r\n			//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n			var s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n			for ( s = 0; s < sl; s ++ ) {\r\n\r\n				var slen1 = vlen * s;\r\n				var slen2 = vlen * ( s + 1 );\r\n\r\n				var a = layeroffset + j + slen1,\r\n					b = layeroffset + k + slen1,\r\n					c = layeroffset + k + slen2,\r\n					d = layeroffset + j + slen2;\r\n\r\n				f4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	function v( x, y, z ) {\r\n\r\n		scope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n	}\r\n\r\n	function f3( a, b, c ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n\r\n		scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\r\n		var uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n		scope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n	}\r\n\r\n	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n		d += shapesOffset;\r\n\r\n		scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n		scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\r\n		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n	generateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n\r\n		return [\r\n			new THREE.Vector2( a.x, a.y ),\r\n			new THREE.Vector2( b.x, b.y ),\r\n			new THREE.Vector2( c.x, c.y )\r\n		];\r\n\r\n	},\r\n\r\n	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n		var d = vertices[ indexD ];\r\n\r\n		if ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\r\n			return [\r\n				new THREE.Vector2( a.x, 1 - a.z ),\r\n				new THREE.Vector2( b.x, 1 - b.z ),\r\n				new THREE.Vector2( c.x, 1 - c.z ),\r\n				new THREE.Vector2( d.x, 1 - d.z )\r\n			];\r\n\r\n		} else {\r\n\r\n			return [\r\n				new THREE.Vector2( a.y, 1 - a.z ),\r\n				new THREE.Vector2( b.y, 1 - b.z ),\r\n				new THREE.Vector2( c.y, 1 - c.z ),\r\n				new THREE.Vector2( d.y, 1 - d.z )\r\n			];\r\n\r\n		}\r\n\r\n	}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *	material: <int> // material index for front and back faces\r\n *	uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ShapeGeometry';\r\n\r\n	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n	for ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n		this.addShape( shapes[ i ], options );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	if ( options === undefined ) options = {};\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var material = options.material;\r\n	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n	//\r\n\r\n	var i, l, hole;\r\n\r\n	var shapesOffset = this.vertices.length;\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n		for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n			hole = holes[ i ];\r\n\r\n			if ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\r\n				holes[ i ] = hole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false;\r\n\r\n	}\r\n\r\n	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n	// Vertices\r\n\r\n	for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n		hole = holes[ i ];\r\n		vertices = vertices.concat( hole );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var vert, vlen = vertices.length;\r\n	var face, flen = faces.length;\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = vertices[ i ];\r\n\r\n		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n	}\r\n\r\n	for ( i = 0; i < flen; i ++ ) {\r\n\r\n		face = faces[ i ];\r\n\r\n		var a = face[ 0 ] + shapesOffset;\r\n		var b = face[ 1 ] + shapesOffset;\r\n		var c = face[ 2 ] + shapesOffset;\r\n\r\n		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points\r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'LatheGeometry';\r\n\r\n	this.parameters = {\r\n		points: points,\r\n		segments: segments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength\r\n	};\r\n\r\n	segments = segments || 12;\r\n	phiStart = phiStart || 0;\r\n	phiLength = phiLength || 2 * Math.PI;\r\n\r\n	var inversePointLength = 1.0 / ( points.length - 1 );\r\n	var inverseSegments = 1.0 / segments;\r\n\r\n	for ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n		var phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n		var sin = Math.sin( phi );\r\n		var cos = Math.cos( phi );\r\n\r\n		for ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n			var point = points[ j ];\r\n\r\n			var vertex = new THREE.Vector3();\r\n\r\n			vertex.x = point.x * sin;\r\n			vertex.y = point.y;\r\n			vertex.z = point.x * cos;\r\n\r\n			this.vertices.push( vertex );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var np = points.length;\r\n\r\n	for ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n			var base = j + np * i;\r\n			var a = base;\r\n			var b = base + np;\r\n			var c = base + 1 + np;\r\n			var d = base + 1;\r\n\r\n			var u0 = i * inverseSegments;\r\n			var v0 = j * inversePointLength;\r\n			var u1 = u0 + inverseSegments;\r\n			var v1 = v0 + inversePointLength;\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u0, v0 ),\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u1, v1 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PlaneGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'PlaneBufferGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n\r\n	var gridX = Math.floor( widthSegments ) || 1;\r\n	var gridY = Math.floor( heightSegments ) || 1;\r\n\r\n	var gridX1 = gridX + 1;\r\n	var gridY1 = gridY + 1;\r\n\r\n	var segment_width = width / gridX;\r\n	var segment_height = height / gridY;\r\n\r\n	var vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n	var offset = 0;\r\n	var offset2 = 0;\r\n\r\n	for ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n		var y = iy * segment_height - height_half;\r\n\r\n		for ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n			var x = ix * segment_width - width_half;\r\n\r\n			vertices[ offset ] = x;\r\n			vertices[ offset + 1 ] = - y;\r\n\r\n			normals[ offset + 2 ] = 1;\r\n\r\n			uvs[ offset2 ] = ix / gridX;\r\n			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n			offset += 3;\r\n			offset2 += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	offset = 0;\r\n\r\n	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n	for ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n		for ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n			var a = ix + gridX1 * iy;\r\n			var b = ix + gridX1 * ( iy + 1 );\r\n			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n			var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n			indices[ offset ] = a;\r\n			indices[ offset + 1 ] = b;\r\n			indices[ offset + 2 ] = d;\r\n\r\n			indices[ offset + 3 ] = b;\r\n			indices[ offset + 4 ] = c;\r\n			indices[ offset + 5 ] = d;\r\n\r\n			offset += 6;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'RingGeometry';\r\n\r\n	this.parameters = {\r\n		innerRadius: innerRadius,\r\n		outerRadius: outerRadius,\r\n		thetaSegments: thetaSegments,\r\n		phiSegments: phiSegments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	innerRadius = innerRadius || 0;\r\n	outerRadius = outerRadius || 50;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\r\n	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n	for ( i = 0; i < phiSegments + 1; i ++ ) {\r\n\r\n		// concentric circles inside ring\r\n\r\n		for ( o = 0; o < thetaSegments + 1; o ++ ) {\r\n\r\n			// number of segments per circle\r\n\r\n			var vertex = new THREE.Vector3();\r\n			var segment = thetaStart + o / thetaSegments * thetaLength;\r\n			vertex.x = radius * Math.cos( segment );\r\n			vertex.y = radius * Math.sin( segment );\r\n\r\n			this.vertices.push( vertex );\r\n			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\r\n		}\r\n\r\n		radius += radiusStep;\r\n\r\n	}\r\n\r\n	var n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n	for ( i = 0; i < phiSegments; i ++ ) {\r\n\r\n		// concentric circles inside ring\r\n\r\n		var thetaSegment = i * ( thetaSegments + 1 );\r\n\r\n		for ( o = 0; o < thetaSegments ; o ++ ) {\r\n\r\n			// number of segments per circle\r\n\r\n			var segment = o + thetaSegment;\r\n\r\n			var v1 = segment;\r\n			var v2 = segment + thetaSegments + 1;\r\n			var v3 = segment + thetaSegments + 2;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );\r\n\r\n			v1 = segment;\r\n			v2 = segment + thetaSegments + 2;\r\n			v3 = segment + 1;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'SphereGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/SphereBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\r\n\r\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'SphereBufferGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n\r\n	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n	phiStart = phiStart !== undefined ? phiStart : 0;\r\n	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n	var thetaEnd = thetaStart + thetaLength;\r\n\r\n	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\r\n	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n	var index = 0, vertices = [], normal = new THREE.Vector3();\r\n\r\n	for ( var y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n\r\n		var v = y / heightSegments;\r\n\r\n		for ( var x = 0; x <= widthSegments; x ++ ) {\r\n\r\n			var u = x / widthSegments;\r\n\r\n			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n			var py = radius * Math.cos( thetaStart + v * thetaLength );\r\n			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n			normal.set( px, py, pz ).normalize();\r\n\r\n			positions.setXYZ( index, px, py, pz );\r\n			normals.setXYZ( index, normal.x, normal.y, normal.z );\r\n			uvs.setXY( index, u, 1 - v );\r\n\r\n			verticesRow.push( index );\r\n\r\n			index ++;\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n\r\n	}\r\n\r\n	var indices = [];\r\n\r\n	for ( var y = 0; y < heightSegments; y ++ ) {\r\n\r\n		for ( var x = 0; x < widthSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x + 1 ];\r\n			var v2 = vertices[ y ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x ];\r\n			var v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n	this.addAttribute( 'position', positions );\r\n	this.addAttribute( 'normal', normals );\r\n	this.addAttribute( 'uv', uvs );\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  font: <THREE.Font>, // font\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float> // how far from text outline is bevel\r\n * }\r\n */\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n	parameters = parameters || {};\r\n\r\n	var font = parameters.font;\r\n\r\n	if ( font instanceof THREE.Font === false ) {\r\n\r\n		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n		return new THREE.Geometry();\r\n\r\n	}\r\n\r\n	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\r\n	// translate parameters to ExtrudeGeometry API\r\n\r\n	parameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n	// defaults\r\n\r\n	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n	THREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\r\n	this.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		arc: arc\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 8;\r\n	tubularSegments = tubularSegments || 6;\r\n	arc = arc || Math.PI * 2;\r\n\r\n	var center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n	for ( var j = 0; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n			var u = i / tubularSegments * arc;\r\n			var v = j / radialSegments * Math.PI * 2;\r\n\r\n			center.x = radius * Math.cos( u );\r\n			center.y = radius * Math.sin( u );\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n			vertex.z = tube * Math.sin( v );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n			normals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var j = 1; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n			var a = ( tubularSegments + 1 ) * j + i - 1;\r\n			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n			var d = ( tubularSegments + 1 ) * j + i;\r\n\r\n			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusKnotGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		p: p,\r\n		q: q,\r\n		heightScale: heightScale\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 64;\r\n	tubularSegments = tubularSegments || 8;\r\n	p = p || 2;\r\n	q = q || 3;\r\n	heightScale = heightScale || 1;\r\n\r\n	var grid = new Array( radialSegments );\r\n	var tang = new THREE.Vector3();\r\n	var n = new THREE.Vector3();\r\n	var bitan = new THREE.Vector3();\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		grid[ i ] = new Array( tubularSegments );\r\n		var u = i / radialSegments * 2 * p * Math.PI;\r\n		var p1 = getPos( u, q, p, radius, heightScale );\r\n		var p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n		tang.subVectors( p2, p1 );\r\n		n.addVectors( p2, p1 );\r\n\r\n		bitan.crossVectors( tang, n );\r\n		n.crossVectors( bitan, tang );\r\n		bitan.normalize();\r\n		n.normalize();\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var v = j / tubularSegments * 2 * Math.PI;\r\n			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			var cy = tube * Math.sin( v );\r\n\r\n			var pos = new THREE.Vector3();\r\n			pos.x = p1.x + cx * n.x + cy * bitan.x;\r\n			pos.y = p1.y + cx * n.y + cy * bitan.y;\r\n			pos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n			grid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var ip = ( i + 1 ) % radialSegments;\r\n			var jp = ( j + 1 ) % tubularSegments;\r\n\r\n			var a = grid[ i ][ j ];\r\n			var b = grid[ ip ][ j ];\r\n			var c = grid[ ip ][ jp ];\r\n			var d = grid[ i ][ jp ];\r\n\r\n			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n	function getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n		var cu = Math.cos( u );\r\n		var su = Math.sin( u );\r\n		var quOverP = in_q / in_p * u;\r\n		var cs = Math.cos( quOverP );\r\n\r\n		var tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n		var ty = radius * ( 2 + cs ) * su * 0.5;\r\n		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n		return new THREE.Vector3( tx, ty, tz );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TubeGeometry';\r\n\r\n	this.parameters = {\r\n		path: path,\r\n		segments: segments,\r\n		radius: radius,\r\n		radialSegments: radialSegments,\r\n		closed: closed,\r\n		taper: taper\r\n	};\r\n\r\n	segments = segments || 64;\r\n	radius = radius || 1;\r\n	radialSegments = radialSegments || 8;\r\n	closed = closed || false;\r\n	taper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n	var grid = [];\r\n\r\n	var scope = this,\r\n\r\n		tangent,\r\n		normal,\r\n		binormal,\r\n\r\n		numpoints = segments + 1,\r\n\r\n		u, v, r,\r\n\r\n		cx, cy,\r\n		pos, pos2 = new THREE.Vector3(),\r\n		i, j,\r\n		ip, jp,\r\n		a, b, c, d,\r\n		uva, uvb, uvc, uvd;\r\n\r\n	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n		tangents = frames.tangents,\r\n		normals = frames.normals,\r\n		binormals = frames.binormals;\r\n\r\n	// proxy internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	function vert( x, y, z ) {\r\n\r\n		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n	}\r\n\r\n	// construct the grid\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		grid[ i ] = [];\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		pos = path.getPointAt( u );\r\n\r\n		tangent = tangents[ i ];\r\n		normal = normals[ i ];\r\n		binormal = binormals[ i ];\r\n\r\n		r = radius * taper( u );\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			v = j / radialSegments * 2 * Math.PI;\r\n\r\n			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			cy = r * Math.sin( v );\r\n\r\n			pos2.copy( pos );\r\n			pos2.x += cx * normal.x + cy * binormal.x;\r\n			pos2.y += cx * normal.y + cy * binormal.y;\r\n			pos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// construct the mesh\r\n\r\n	for ( i = 0; i < segments; i ++ ) {\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n			jp = ( j + 1 ) % radialSegments;\r\n\r\n			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***\r\n			b = grid[ ip ][ j ];\r\n			c = grid[ ip ][ jp ];\r\n			d = grid[ i ][ jp ];\r\n\r\n			uva = new THREE.Vector2( i / segments, j / radialSegments );\r\n			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n	return 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n	return Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n	var	normal = new THREE.Vector3(),\r\n\r\n		tangents = [],\r\n		normals = [],\r\n		binormals = [],\r\n\r\n		vec = new THREE.Vector3(),\r\n		mat = new THREE.Matrix4(),\r\n\r\n		numpoints = segments + 1,\r\n		theta,\r\n		smallest,\r\n\r\n		tx, ty, tz,\r\n		i, u;\r\n\r\n\r\n	// expose internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	// compute the tangent vectors for each segment on the path\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		tangents[ i ] = path.getTangentAt( u );\r\n		tangents[ i ].normalize();\r\n\r\n	}\r\n\r\n	initialNormal3();\r\n\r\n	/*\r\n	function initialNormal1(lastBinormal) {\r\n		// fixed start binormal. Has dangers of 0 vectors\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n	}\r\n\r\n	function initialNormal2() {\r\n\r\n		// This uses the Frenet-Serret formula for deriving binormal\r\n		var t2 = path.getTangentAt( epsilon );\r\n\r\n		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n	}\r\n	*/\r\n\r\n	function initialNormal3() {\r\n\r\n		// select an initial normal vector perpendicular to the first tangent vector,\r\n		// and in the direction of the smallest tangent xyz component\r\n\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		smallest = Number.MAX_VALUE;\r\n		tx = Math.abs( tangents[ 0 ].x );\r\n		ty = Math.abs( tangents[ 0 ].y );\r\n		tz = Math.abs( tangents[ 0 ].z );\r\n\r\n		if ( tx <= smallest ) {\r\n\r\n			smallest = tx;\r\n			normal.set( 1, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( ty <= smallest ) {\r\n\r\n			smallest = ty;\r\n			normal.set( 0, 1, 0 );\r\n\r\n		}\r\n\r\n		if ( tz <= smallest ) {\r\n\r\n			normal.set( 0, 0, 1 );\r\n\r\n		}\r\n\r\n		vec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n		normals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n	}\r\n\r\n\r\n	// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n	for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n		normals[ i ] = normals[ i - 1 ].clone();\r\n\r\n		binormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n		if ( vec.length() > Number.EPSILON ) {\r\n\r\n			vec.normalize();\r\n\r\n			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n		}\r\n\r\n		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n	}\r\n\r\n\r\n	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n	if ( closed ) {\r\n\r\n		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n		theta /= ( numpoints - 1 );\r\n\r\n		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n			theta = - theta;\r\n\r\n		}\r\n\r\n		for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n			// twist a little...\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PolyhedronGeometry';\r\n\r\n	this.parameters = {\r\n		vertices: vertices,\r\n		indices: indices,\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n	radius = radius || 1;\r\n	detail = detail || 0;\r\n\r\n	var that = this;\r\n\r\n	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n	}\r\n\r\n	var p = this.vertices;\r\n\r\n	var faces = [];\r\n\r\n	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n		var v1 = p[ indices[ i ] ];\r\n		var v2 = p[ indices[ i + 1 ] ];\r\n		var v3 = p[ indices[ i + 2 ] ];\r\n\r\n		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\r\n	}\r\n\r\n	var centroid = new THREE.Vector3();\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		subdivide( faces[ i ], detail );\r\n\r\n	}\r\n\r\n\r\n	// Handle case when face straddles the seam\r\n\r\n	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n		var uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n		var x0 = uvs[ 0 ].x;\r\n		var x1 = uvs[ 1 ].x;\r\n		var x2 = uvs[ 2 ].x;\r\n\r\n		var max = Math.max( x0, x1, x2 );\r\n		var min = Math.min( x0, x1, x2 );\r\n\r\n		if ( max > 0.9 && min < 0.1 ) {\r\n\r\n			// 0.9 is somewhat arbitrary\r\n\r\n			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Apply radius\r\n\r\n	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n		this.vertices[ i ].multiplyScalar( radius );\r\n\r\n	}\r\n\r\n\r\n	// Merge vertices\r\n\r\n	this.mergeVertices();\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n	// Project vector onto sphere's surface\r\n\r\n	function prepare( vector ) {\r\n\r\n		var vertex = vector.normalize().clone();\r\n		vertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n		var u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n		var v = inclination( vector ) / Math.PI + 0.5;\r\n		vertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n		return vertex;\r\n\r\n	}\r\n\r\n\r\n	// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n	function make( v1, v2, v3, materialIndex ) {\r\n\r\n		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n		that.faces.push( face );\r\n\r\n		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n		var azi = azimuth( centroid );\r\n\r\n		that.faceVertexUvs[ 0 ].push( [\r\n			correctUV( v1.uv, v1, azi ),\r\n			correctUV( v2.uv, v2, azi ),\r\n			correctUV( v3.uv, v3, azi )\r\n		] );\r\n\r\n	}\r\n\r\n\r\n	// Analytically subdivide a face to the required detail level.\r\n\r\n	function subdivide( face, detail ) {\r\n\r\n		var cols = Math.pow( 2, detail );\r\n		var a = prepare( that.vertices[ face.a ] );\r\n		var b = prepare( that.vertices[ face.b ] );\r\n		var c = prepare( that.vertices[ face.c ] );\r\n		var v = [];\r\n\r\n		var materialIndex = face.materialIndex;\r\n\r\n		// Construct all of the vertices for this subdivision.\r\n\r\n		for ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n			v[ i ] = [];\r\n\r\n			var aj = prepare( a.clone().lerp( c, i / cols ) );\r\n			var bj = prepare( b.clone().lerp( c, i / cols ) );\r\n			var rows = cols - i;\r\n\r\n			for ( var j = 0; j <= rows; j ++ ) {\r\n\r\n				if ( j === 0 && i === cols ) {\r\n\r\n					v[ i ][ j ] = aj;\r\n\r\n				} else {\r\n\r\n					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Construct all of the faces.\r\n\r\n		for ( var i = 0; i < cols ; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n				var k = Math.floor( j / 2 );\r\n\r\n				if ( j % 2 === 0 ) {\r\n\r\n					make(\r\n						v[ i ][ k + 1 ],\r\n						v[ i + 1 ][ k ],\r\n						v[ i ][ k ],\r\n						materialIndex\r\n					);\r\n\r\n				} else {\r\n\r\n					make(\r\n						v[ i ][ k + 1 ],\r\n						v[ i + 1 ][ k + 1 ],\r\n						v[ i + 1 ][ k ],\r\n						materialIndex\r\n					);\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n	function azimuth( vector ) {\r\n\r\n		return Math.atan2( vector.z, - vector.x );\r\n\r\n	}\r\n\r\n\r\n	// Angle above the XZ plane.\r\n\r\n	function inclination( vector ) {\r\n\r\n		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n	}\r\n\r\n\r\n	// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n	function correctUV( uv, vector, azimuth ) {\r\n\r\n		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n		return uv.clone();\r\n\r\n	}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n	var r = 1 / t;\r\n\r\n	var vertices = [\r\n\r\n		// (±1, ±1, ±1)\r\n		- 1, - 1, - 1,    - 1, - 1,  1,\r\n		- 1,  1, - 1,    - 1,  1,  1,\r\n		 1, - 1, - 1,     1, - 1,  1,\r\n		 1,  1, - 1,     1,  1,  1,\r\n\r\n		// (0, ±1/φ, ±φ)\r\n		 0, - r, - t,     0, - r,  t,\r\n		 0,  r, - t,     0,  r,  t,\r\n\r\n		// (±1/φ, ±φ, 0)\r\n		- r, - t,  0,    - r,  t,  0,\r\n		 r, - t,  0,     r,  t,  0,\r\n\r\n		// (±φ, 0, ±1/φ)\r\n		- t,  0, - r,     t,  0, - r,\r\n		- t,  0,  r,     t,  0,  r\r\n	];\r\n\r\n	var indices = [\r\n		 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n		 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n		17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n		 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n		 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n		 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n		 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n		18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n		 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n		11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n		19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n		 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'DodecahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n	var vertices = [\r\n		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n	];\r\n\r\n	var indices = [\r\n		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'IcosahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n	var vertices = [\r\n		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n	];\r\n\r\n	var indices = [\r\n		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'OctahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n	var vertices = [\r\n		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n	];\r\n\r\n	var indices = [\r\n		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'TetrahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ParametricGeometry';\r\n\r\n	this.parameters = {\r\n		func: func,\r\n		slices: slices,\r\n		stacks: stacks\r\n	};\r\n\r\n	var verts = this.vertices;\r\n	var faces = this.faces;\r\n	var uvs = this.faceVertexUvs[ 0 ];\r\n\r\n	var i, j, p;\r\n	var u, v;\r\n\r\n	var sliceCount = slices + 1;\r\n\r\n	for ( i = 0; i <= stacks; i ++ ) {\r\n\r\n		v = i / stacks;\r\n\r\n		for ( j = 0; j <= slices; j ++ ) {\r\n\r\n			u = j / slices;\r\n\r\n			p = func( u, v );\r\n			verts.push( p );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var a, b, c, d;\r\n	var uva, uvb, uvc, uvd;\r\n\r\n	for ( i = 0; i < stacks; i ++ ) {\r\n\r\n		for ( j = 0; j < slices; j ++ ) {\r\n\r\n			a = i * sliceCount + j;\r\n			b = i * sliceCount + j + 1;\r\n			c = ( i + 1 ) * sliceCount + j + 1;\r\n			d = ( i + 1 ) * sliceCount + j;\r\n\r\n			uva = new THREE.Vector2( j / slices, i / stacks );\r\n			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n			faces.push( new THREE.Face3( a, b, d ) );\r\n			uvs.push( [ uva, uvb, uvd ] );\r\n\r\n			faces.push( new THREE.Face3( b, c, d ) );\r\n			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// console.log(this);\r\n\r\n	// magic bullet\r\n	// var diff = this.mergeVertices();\r\n	// console.log('removed ', diff, ' vertices by merging');\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/geometries/WireframeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeGeometry = function ( geometry ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n\r\n	function sortFunction( a, b ) {\r\n\r\n		return a - b;\r\n\r\n	}\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n\r\n	if ( geometry instanceof THREE.Geometry ) {\r\n\r\n		var vertices = geometry.vertices;\r\n		var faces = geometry.faces;\r\n		var numEdges = 0;\r\n\r\n		// allocate maximal size\r\n		var edges = new Uint32Array( 6 * faces.length );\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			for ( var j = 0; j < 3; j ++ ) {\r\n\r\n				edge[ 0 ] = face[ keys[ j ] ];\r\n				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n				edge.sort( sortFunction );\r\n\r\n				var key = edge.toString();\r\n\r\n				if ( hash[ key ] === undefined ) {\r\n\r\n					edges[ 2 * numEdges ] = edge[ 0 ];\r\n					edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n					hash[ key ] = true;\r\n					numEdges ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n		for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2; j ++ ) {\r\n\r\n				var vertex = vertices[ edges [ 2 * i + j ] ];\r\n\r\n				var index = 6 * i + 3 * j;\r\n				coords[ index + 0 ] = vertex.x;\r\n				coords[ index + 1 ] = vertex.y;\r\n				coords[ index + 2 ] = vertex.z;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n	} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		if ( geometry.index !== null ) {\r\n\r\n			// Indexed BufferGeometry\r\n\r\n			var indices = geometry.index.array;\r\n			var vertices = geometry.attributes.position;\r\n			var groups = geometry.groups;\r\n			var numEdges = 0;\r\n\r\n			if ( groups.length === 0 ) {\r\n\r\n				geometry.addGroup( 0, indices.length );\r\n\r\n			}\r\n\r\n			// allocate maximal size\r\n			var edges = new Uint32Array( 2 * indices.length );\r\n\r\n			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n				var group = groups[ o ];\r\n\r\n				var start = group.start;\r\n				var count = group.count;\r\n\r\n				for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n					for ( var j = 0; j < 3; j ++ ) {\r\n\r\n						edge[ 0 ] = indices[ i + j ];\r\n						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n						edge.sort( sortFunction );\r\n\r\n						var key = edge.toString();\r\n\r\n						if ( hash[ key ] === undefined ) {\r\n\r\n							edges[ 2 * numEdges ] = edge[ 0 ];\r\n							edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n							hash[ key ] = true;\r\n							numEdges ++;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 2; j ++ ) {\r\n\r\n					var index = 6 * i + 3 * j;\r\n					var index2 = edges[ 2 * i + j ];\r\n\r\n					coords[ index + 0 ] = vertices.getX( index2 );\r\n					coords[ index + 1 ] = vertices.getY( index2 );\r\n					coords[ index + 2 ] = vertices.getZ( index2 );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		} else {\r\n\r\n			// non-indexed BufferGeometry\r\n\r\n			var vertices = geometry.attributes.position.array;\r\n			var numEdges = vertices.length / 3;\r\n			var numTris = numEdges / 3;\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 3; j ++ ) {\r\n\r\n					var index = 18 * i + 6 * j;\r\n\r\n					var index1 = 9 * i + 3 * j;\r\n					coords[ index + 0 ] = vertices[ index1 ];\r\n					coords[ index + 1 ] = vertices[ index1 + 1 ];\r\n					coords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n					coords[ index + 3 ] = vertices[ index2 ];\r\n					coords[ index + 4 ] = vertices[ index2 + 1 ];\r\n					coords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n	size = size || 1;\r\n\r\n	var vertices = new Float32Array( [\r\n		0, 0, 0,  size, 0, 0,\r\n		0, 0, 0,  0, size, 0,\r\n		0, 0, 0,  0, 0, size\r\n	] );\r\n\r\n	var colors = new Float32Array( [\r\n		1, 0, 0,  1, 0.6, 0,\r\n		0, 1, 0,  0.6, 1, 0,\r\n		0, 0, 1,  0, 0.6, 1\r\n	] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n	var lineGeometry = new THREE.Geometry();\r\n	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n	coneGeometry.translate( 0, - 0.5, 0 );\r\n\r\n	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		if ( color === undefined ) color = 0xffff00;\r\n		if ( length === undefined ) length = 1;\r\n		if ( headLength === undefined ) headLength = 0.2 * length;\r\n		if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n		this.position.copy( origin );\r\n		\r\n		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n		this.line.matrixAutoUpdate = false;\r\n		this.add( this.line );\r\n\r\n		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n		this.cone.matrixAutoUpdate = false;\r\n		this.add( this.cone );\r\n\r\n		this.setDirection( dir );\r\n		this.setLength( length, headLength, headWidth );\r\n\r\n	}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n	var axis = new THREE.Vector3();\r\n	var radians;\r\n\r\n	return function setDirection( dir ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		if ( dir.y > 0.99999 ) {\r\n\r\n			this.quaternion.set( 0, 0, 0, 1 );\r\n\r\n		} else if ( dir.y < - 0.99999 ) {\r\n\r\n			this.quaternion.set( 1, 0, 0, 0 );\r\n\r\n		} else {\r\n\r\n			axis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n			radians = Math.acos( dir.y );\r\n\r\n			this.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n	if ( headLength === undefined ) headLength = 0.2 * length;\r\n	if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n	this.line.updateMatrix();\r\n\r\n	this.cone.scale.set( headWidth, headLength, headWidth );\r\n	this.cone.position.y = length;\r\n	this.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n	this.line.material.color.set( color );\r\n	this.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n	var positions = new Float32Array( 8 * 3 );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\r\n	if ( object !== undefined ) {\r\n\r\n		this.update( object );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = ( function () {\r\n\r\n	var box = new THREE.Box3();\r\n\r\n	return function ( object ) {\r\n\r\n		box.setFromObject( object );\r\n\r\n		if ( box.isEmpty() ) return;\r\n\r\n		var min = box.min;\r\n		var max = box.max;\r\n\r\n		/*\r\n		  5____4\r\n		1/___0/|\r\n		| 6__|_7\r\n		2/___3/\r\n\r\n		0: max.x, max.y, max.z\r\n		1: min.x, max.y, max.z\r\n		2: min.x, min.y, max.z\r\n		3: max.x, min.y, max.z\r\n		4: max.x, max.y, min.z\r\n		5: min.x, max.y, min.z\r\n		6: min.x, min.y, min.z\r\n		7: max.x, min.y, min.z\r\n		*/\r\n\r\n		var position = this.geometry.attributes.position;\r\n		var array = position.array;\r\n\r\n		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n		position.needsUpdate = true;\r\n\r\n		this.geometry.computeBoundingSphere();\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n	this.object = object;\r\n\r\n	this.box = new THREE.Box3();\r\n\r\n	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n	this.box.setFromObject( this.object );\r\n\r\n	this.box.size( this.scale );\r\n\r\n	this.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *	- shows frustum, line of sight and up of the camera\r\n *	- suitable for fast updates\r\n * 	- based on frustum visualization in lightgl.js shadowmap example\r\n *		http://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n	var pointMap = {};\r\n\r\n	// colors\r\n\r\n	var hexFrustum = 0xffaa00;\r\n	var hexCone = 0xff0000;\r\n	var hexUp = 0x00aaff;\r\n	var hexTarget = 0xffffff;\r\n	var hexCross = 0x333333;\r\n\r\n	// near\r\n\r\n	addLine( \"n1\", \"n2\", hexFrustum );\r\n	addLine( \"n2\", \"n4\", hexFrustum );\r\n	addLine( \"n4\", \"n3\", hexFrustum );\r\n	addLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n	// far\r\n\r\n	addLine( \"f1\", \"f2\", hexFrustum );\r\n	addLine( \"f2\", \"f4\", hexFrustum );\r\n	addLine( \"f4\", \"f3\", hexFrustum );\r\n	addLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n	// sides\r\n\r\n	addLine( \"n1\", \"f1\", hexFrustum );\r\n	addLine( \"n2\", \"f2\", hexFrustum );\r\n	addLine( \"n3\", \"f3\", hexFrustum );\r\n	addLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n	// cone\r\n\r\n	addLine( \"p\", \"n1\", hexCone );\r\n	addLine( \"p\", \"n2\", hexCone );\r\n	addLine( \"p\", \"n3\", hexCone );\r\n	addLine( \"p\", \"n4\", hexCone );\r\n\r\n	// up\r\n\r\n	addLine( \"u1\", \"u2\", hexUp );\r\n	addLine( \"u2\", \"u3\", hexUp );\r\n	addLine( \"u3\", \"u1\", hexUp );\r\n\r\n	// target\r\n\r\n	addLine( \"c\", \"t\", hexTarget );\r\n	addLine( \"p\", \"c\", hexCross );\r\n\r\n	// cross\r\n\r\n	addLine( \"cn1\", \"cn2\", hexCross );\r\n	addLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n	addLine( \"cf1\", \"cf2\", hexCross );\r\n	addLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n	function addLine( a, b, hex ) {\r\n\r\n		addPoint( a, hex );\r\n		addPoint( b, hex );\r\n\r\n	}\r\n\r\n	function addPoint( id, hex ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3() );\r\n		geometry.colors.push( new THREE.Color( hex ) );\r\n\r\n		if ( pointMap[ id ] === undefined ) {\r\n\r\n			pointMap[ id ] = [];\r\n\r\n		}\r\n\r\n		pointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n	}\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n	this.camera = camera;\r\n	this.camera.updateProjectionMatrix();\r\n\r\n	this.matrix = camera.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.pointMap = pointMap;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n	var geometry, pointMap;\r\n\r\n	var vector = new THREE.Vector3();\r\n	var camera = new THREE.Camera();\r\n\r\n	function setPoint( point, x, y, z ) {\r\n\r\n		vector.set( x, y, z ).unproject( camera );\r\n\r\n		var points = pointMap[ point ];\r\n\r\n		if ( points !== undefined ) {\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				geometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return function () {\r\n\r\n		geometry = this.geometry;\r\n		pointMap = this.pointMap;\r\n\r\n		var w = 1, h = 1;\r\n\r\n		// we need just camera projection matrix\r\n		// world matrix must be identity\r\n\r\n		camera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n		// center / target\r\n\r\n		setPoint( \"c\", 0, 0, - 1 );\r\n		setPoint( \"t\", 0, 0,  1 );\r\n\r\n		// near\r\n\r\n		setPoint( \"n1\", - w, - h, - 1 );\r\n		setPoint( \"n2\",   w, - h, - 1 );\r\n		setPoint( \"n3\", - w,   h, - 1 );\r\n		setPoint( \"n4\",   w,   h, - 1 );\r\n\r\n		// far\r\n\r\n		setPoint( \"f1\", - w, - h, 1 );\r\n		setPoint( \"f2\",   w, - h, 1 );\r\n		setPoint( \"f3\", - w,   h, 1 );\r\n		setPoint( \"f4\",   w,   h, 1 );\r\n\r\n		// up\r\n\r\n		setPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n		// cross\r\n\r\n		setPoint( \"cf1\", - w,   0, 1 );\r\n		setPoint( \"cf2\",   w,   0, 1 );\r\n		setPoint( \"cf3\",   0, - h, 1 );\r\n		setPoint( \"cf4\",   0,   h, 1 );\r\n\r\n		setPoint( \"cn1\", - w,   0, - 1 );\r\n		setPoint( \"cn2\",   w,   0, - 1 );\r\n		setPoint( \"cn3\",   0, - h, - 1 );\r\n		setPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n		geometry.verticesNeedUpdate = true;\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	size = size || 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3( - size,   size, 0 ),\r\n		new THREE.Vector3(   size,   size, 0 ),\r\n		new THREE.Vector3(   size, - size, 0 ),\r\n		new THREE.Vector3( - size, - size, 0 ),\r\n		new THREE.Vector3( - size,   size, 0 )\r\n	);\r\n\r\n	var material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.lightPlane = new THREE.Line( geometry, material );\r\n	this.add( this.lightPlane );\r\n\r\n	geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3(),\r\n		new THREE.Vector3()\r\n	);\r\n\r\n	material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.targetLine = new THREE.Line( geometry, material );\r\n	this.add( this.targetLine );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n	this.lightPlane.geometry.dispose();\r\n	this.lightPlane.material.dispose();\r\n	this.targetLine.geometry.dispose();\r\n	this.targetLine.material.dispose();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var v3 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		v1.setFromMatrixPosition( this.light.matrixWorld );\r\n		v2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n		v3.subVectors( v2, v1 );\r\n\r\n		this.lightPlane.lookAt( v3 );\r\n		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n		this.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n		this.targetLine.geometry.verticesNeedUpdate = true;\r\n		this.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	// FaceNormalsHelper only supports THREE.Geometry\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	//\r\n\r\n	var nNormals = 0;\r\n\r\n	var objGeometry = this.object.geometry;\r\n\r\n	if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n		nNormals = objGeometry.faces.length;\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n	geometry.addAttribute( 'position', positions );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n	//\r\n\r\n	this.matrixAutoUpdate = false;\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var normalMatrix = new THREE.Matrix3();\r\n\r\n	return function update() {\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n		var matrixWorld = this.object.matrixWorld;\r\n\r\n		var position = this.geometry.attributes.position;\r\n\r\n		//\r\n\r\n		var objGeometry = this.object.geometry;\r\n\r\n		var vertices = objGeometry.vertices;\r\n\r\n		var faces = objGeometry.faces;\r\n\r\n		var idx = 0;\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			var normal = face.normal;\r\n\r\n			v1.copy( vertices[ face.a ] )\r\n				.add( vertices[ face.b ] )\r\n				.add( vertices[ face.c ] )\r\n				.divideScalar( 3 )\r\n				.applyMatrix4( matrixWorld );\r\n\r\n			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n			position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n			idx = idx + 1;\r\n\r\n			position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n			idx = idx + 1;\r\n\r\n		}\r\n\r\n		position.needsUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	this.color1 = new THREE.Color( 0x444444 );\r\n	this.color2 = new THREE.Color( 0x888888 );\r\n\r\n	for ( var i = - size; i <= size; i += step ) {\r\n\r\n		geometry.vertices.push(\r\n			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n		);\r\n\r\n		var color = i === 0 ? this.color1 : this.color2;\r\n\r\n		geometry.colors.push( color, color, color, color );\r\n\r\n	}\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n	this.color1.set( colorCenterLine );\r\n	this.color2.set( colorGrid );\r\n\r\n	this.geometry.colorsNeedUpdate = true;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	geometry.rotateX( - Math.PI / 2 );\r\n\r\n	for ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n	}\r\n\r\n	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( geometry, material );\r\n	this.add( this.lightSphere );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\r\n	this.lightSphere.geometry.dispose();\r\n	this.lightSphere.material.dispose();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n		this.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n	}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.matrix = this.light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	/*\r\n	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n	var d = light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n\r\n	this.add( this.lightDistance );\r\n	*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n	this.geometry.dispose();\r\n	this.material.dispose();\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	/*\r\n	var d = this.light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.visible = true;\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n	*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n	this.bones = this.getBoneList( object );\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.dynamic = true;\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n	THREE.LineSegments.call( this, geometry, material );\r\n\r\n	this.root = object;\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n	var boneList = [];\r\n\r\n	if ( object instanceof THREE.Bone ) {\r\n\r\n		boneList.push( object );\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n	}\r\n\r\n	return boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n	var geometry = this.geometry;\r\n\r\n	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n	var boneMatrix = new THREE.Matrix4();\r\n\r\n	var j = 0;\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n			j += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.verticesNeedUpdate = true;\r\n\r\n	geometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n	geometry.translate( 0, - 0.5, 0 );\r\n	geometry.rotateX( - Math.PI / 2 );\r\n\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n	this.cone = new THREE.Mesh( geometry, material );\r\n	this.add( this.cone );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\r\n	this.cone.geometry.dispose();\r\n	this.cone.material.dispose();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n	var vector2 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		var coneLength = this.light.distance ? this.light.distance : 10000;\r\n		var coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n		this.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n		vector.setFromMatrixPosition( this.light.matrixWorld );\r\n		vector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n		this.cone.lookAt( vector2.sub( vector ) );\r\n\r\n		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	//\r\n\r\n	var nNormals = 0;\r\n\r\n	var objGeometry = this.object.geometry;\r\n\r\n	if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n		nNormals = objGeometry.faces.length * 3;\r\n\r\n	} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n		nNormals = objGeometry.attributes.normal.count\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n	geometry.addAttribute( 'position', positions );\r\n\r\n	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n	//\r\n\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var normalMatrix = new THREE.Matrix3();\r\n\r\n	return function update() {\r\n\r\n		var keys = [ 'a', 'b', 'c' ];\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n		var matrixWorld = this.object.matrixWorld;\r\n\r\n		var position = this.geometry.attributes.position;\r\n\r\n		//\r\n\r\n		var objGeometry = this.object.geometry;\r\n\r\n		if ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n			var vertices = objGeometry.vertices;\r\n\r\n			var faces = objGeometry.faces;\r\n\r\n			var idx = 0;\r\n\r\n			for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n				var face = faces[ i ];\r\n\r\n				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n					var vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n					var normal = face.vertexNormals[ j ];\r\n\r\n					v1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n					position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n					idx = idx + 1;\r\n\r\n					position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n					idx = idx + 1;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var objPos = objGeometry.attributes.position;\r\n\r\n			var objNorm = objGeometry.attributes.normal;\r\n\r\n			var idx = 0;\r\n\r\n			// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n				position.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n				idx = idx + 1;\r\n\r\n				position.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n				idx = idx + 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		position.needsUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function ( material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.material = material;\r\n	this.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.animationsMap = {};\r\n	this.animationsList = [];\r\n\r\n	// prepare default animation\r\n	// (all frames played together in 1 second)\r\n\r\n	var numFrames = this.geometry.morphTargets.length;\r\n\r\n	var name = \"__default\";\r\n\r\n	var startFrame = 0;\r\n	var endFrame = numFrames - 1;\r\n\r\n	var fps = numFrames / 1;\r\n\r\n	this.createAnimation( name, startFrame, endFrame, fps );\r\n	this.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n	var animation = {\r\n\r\n		start: start,\r\n		end: end,\r\n\r\n		length: end - start + 1,\r\n\r\n		fps: fps,\r\n		duration: ( end - start ) / fps,\r\n\r\n		lastFrame: 0,\r\n		currentFrame: 0,\r\n\r\n		active: false,\r\n\r\n		time: 0,\r\n		direction: 1,\r\n		weight: 1,\r\n\r\n		directionBackwards: false,\r\n		mirroredLoop: false\r\n\r\n	};\r\n\r\n	this.animationsMap[ name ] = animation;\r\n	this.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n	var pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n	var firstAnimation, frameRanges = {};\r\n\r\n	var geometry = this.geometry;\r\n\r\n	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n		var morph = geometry.morphTargets[ i ];\r\n		var chunks = morph.name.match( pattern );\r\n\r\n		if ( chunks && chunks.length > 1 ) {\r\n\r\n			var name = chunks[ 1 ];\r\n\r\n			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n			var range = frameRanges[ name ];\r\n\r\n			if ( i < range.start ) range.start = i;\r\n			if ( i > range.end ) range.end = i;\r\n\r\n			if ( ! firstAnimation ) firstAnimation = name;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var name in frameRanges ) {\r\n\r\n		var range = frameRanges[ name ];\r\n		this.createAnimation( name, range.start, range.end, fps );\r\n\r\n	}\r\n\r\n	this.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = 1;\r\n		animation.directionBackwards = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = - 1;\r\n		animation.directionBackwards = true;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.fps = fps;\r\n		animation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.duration = duration;\r\n		animation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.weight = weight;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = time;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n	var time = 0;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		time = animation.time;\r\n\r\n	}\r\n\r\n	return time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n	var duration = - 1;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		duration = animation.duration;\r\n\r\n	}\r\n\r\n	return duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = 0;\r\n		animation.active = true;\r\n\r\n	} else {\r\n\r\n		console.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.active = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n		var animation = this.animationsList[ i ];\r\n\r\n		if ( ! animation.active ) continue;\r\n\r\n		var frameTime = animation.duration / animation.length;\r\n\r\n		animation.time += animation.direction * delta;\r\n\r\n		if ( animation.mirroredLoop ) {\r\n\r\n			if ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n				animation.direction *= - 1;\r\n\r\n				if ( animation.time > animation.duration ) {\r\n\r\n					animation.time = animation.duration;\r\n					animation.directionBackwards = true;\r\n\r\n				}\r\n\r\n				if ( animation.time < 0 ) {\r\n\r\n					animation.time = 0;\r\n					animation.directionBackwards = false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			animation.time = animation.time % animation.duration;\r\n\r\n			if ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n		}\r\n\r\n		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n		var weight = animation.weight;\r\n\r\n		if ( keyframe !== animation.currentFrame ) {\r\n\r\n			this.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n			this.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n			animation.lastFrame = animation.currentFrame;\r\n			animation.currentFrame = keyframe;\r\n\r\n		}\r\n\r\n		var mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n		if ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n		if ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n		} else {\r\n\r\n			this.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (true) {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/three/three.js?");
},function(module,exports){eval("'use strict';\n\nvar Keys = {\n  search: 'search--NA8UXg',\n  turnByTurn: 'valhalla-RfDii2g',\n  vectorTile: 'vector-tiles-IHKOJtk'\n};\n\nmodule.exports = Keys;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Keys.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Keys.js?")},function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.updatePoint = updatePoint;\nexports.updateZoom = updateZoom;\nexports.updatePointZoom = updatePointZoom;\n\nfunction updatePoint(latLon) {\n  return {\n    type: 'updateLatLon',\n    lat: parseFloat(latLon.lat),\n    lon: parseFloat(latLon.lon)\n  };\n}\n\nfunction updateZoom(zoomLevel) {\n  return {\n    type: 'updateZoom',\n    zoom: parseInt(zoomLevel)\n  };\n}\n\nfunction updatePointZoom(latLonZoom) {\n  return {\n    type: 'updatePointZoom',\n    lat: parseFloat(latLonZoom.lat),\n    lon: parseFloat(latLonZoom.lon),\n    zoom: parseInt(latLonZoom.zoom)\n  };\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Redux/Action.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Redux/Action.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _redux = __webpack_require__(97);\n\nvar _redux2 = _interopRequireDefault(_redux);\n\nvar initialState = {\n  lat: 40.71427,\n  lon: -74.00597,\n  zoom: 16\n\n};\n\nfunction tileInfo() {\n  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];\n  var action = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  switch (action.type) {\n    case 'updateLatLon':\n      return _extends({}, state, {\n        lat: action.lat,\n        lon: action.lon\n      });\n    case 'updateZoom':\n      return _extends({}, state, {\n        zoom: action.zoom\n      });\n    case 'updatePointZoom':\n      return {\n        zoom: action.zoom,\n        lat: action.lat,\n        lon: action.lon\n      };\n    default:\n      return state;\n  }\n}\n\nmodule.exports = tileInfo;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Redux/Reducer.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Redux/Reducer.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _redux = __webpack_require__(97);\n\nvar _Reducer = __webpack_require__(37);\n\nvar _Reducer2 = _interopRequireDefault(_Reducer);\n\nvar store = (0, _redux.createStore)(_Reducer2['default']);\n\nmodule.exports = store;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Redux/Store.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Redux/Store.js?")},function(module,exports,__webpack_require__){eval("exports = module.exports = __webpack_require__(116)();\n// imports\n\n\n// module\nexports.push([module.id, \"#search-bar{width:100%;height:100%;margin-bottom:20px;background-color:#fff;position:relative;z-index:300}#search-bar .search-icon{width:30px;height:34px;position:absolute;background-color:#fff;background-image:url(\" + __webpack_require__(101) + \");background-repeat:no-repeat;background-size:200px 25px;background-position:3px 3px}#search-bar .search-bar{width:100%;float:left;padding-left:33px;border:0;text-overflow:ellipsis}#search-bar .search-bar::-webkit-search-decoration:after{content:' ';width:0;height:0;display:inline-block;background-image:none;margin:0}#search-bar .search-bar::-webkit-search-decoration{display:none}#search-bar .table-view.search-table{padding-left:0;max-height:150px;overflow-y:auto;position:absolute;top:100%;width:calc(100% - 30px)}#search-bar .table-view.search-table li{background-color:#fff;font-size:14px;width:100%;float:left;z-index:50;cursor:pointer;border-top:1px solid #ddd;border-bottom:0;padding-left:5px;overflow:hidden;text-overflow:ellipsis}#search-bar .table-view.search-table li:hover{background-color:#ddd}#search-bar .table-view.search-table li.select{background-color:#ccc}#search-bar .table-view.search-table li:before{content:' ';width:10px;height:10px;display:inline-block;background-image:url(\" + __webpack_require__(101) + \");background-repeat:no-repeat;background-size:80px 10px}#search-bar .table-view.search-table li.search-result:before{background-position:-60px 0}#search-bar .table-view.search-table li.search-term-result:before{background-position:-70px 0}.navigation{position:fixed;right:20px;bottom:30px;width:300px;height:300px}@media only screen and (max-device-width:480px){.navigation{display:none}}.direction-control{position:relative;width:100%;height:100%}div[id^=preview]{content:' ';position:absolute;background-color:hsla(0,0%,100%,.7);width:100px;height:100px;fill:hsla(0,0%,80%,.5);stroke:#666}div[id^=preview]:hover:before{cursor:pointer;text-align:center;color:#fff;font-weight:600;line-height:100px;background-color:hsla(0,0%,39%,.7);position:absolute;width:100px;height:100px}#preview-north-east{top:0;left:200px}#preview-north-east:hover:before{content:'NE'}#preview-north{top:0;left:100px}#preview-north:hover:before{content:'N'}#preview-north-west{top:0;left:0}#preview-north-west:hover:before{content:'NW'}#preview-east{top:100px;left:200px}#preview-east:hover:before{content:'E'}#preview-center{top:100px;left:100px;fill:hsla(0,0%,100%,.8);stroke:#000;z-index:5}#preview-west{top:100px;left:0}#preview-west:hover:before{content:'W'}#preview-south-east{top:200px;left:200px}#preview-south-east:hover:before{content:'SE'}#preview-south{top:200px;left:100px}#preview-south:hover:before{content:'S'}#preview-south-west{top:200px;left:0}#preview-south-west:hover:before{content:'SW'}body,html{margin:0;padding:0;width:100%;height:100%;overflow-y:hidden}.control{width:300px;position:fixed;left:20px;padding:20px;background:hsla(0,0%,100%,.7);font-size:14px}@media only screen and (max-device-width:480px){.control{width:calc(100% - 40px)}}.control-toggle{display:none}@media only screen and (max-device-width:480px){.control-toggle{display:block;position:fixed;background-color:#fff;top:0;right:0}}.form-group .label{font-style:italic;display:inline}.form-group .geocode{font-weight:400;display:inline;border-bottom:1px solid #ccc}#exportA{font-size:18px}.loading-bar{position:fixed;top:0;left:0;width:100%;height:100%;background-color:hsla(0,0%,100%,.3);z-index:30;display:none}.loading-bar:before{content:' ';position:fixed;top:calc(50% - 50px);left:calc(50% - 50px);width:100px;height:100px;z-index:20030;border-radius:50%;border:15px solid #fff;border-top-color:transparent;color:#fff;animation:spinning 1s infinite linear;-webkit-animation:spinning 1s infinite linear;-moz-animation:spinning 1s infinite linear}.loading-bar:after{content:'Loading';position:fixed;color:#fff;font-size:12px;top:calc(50% - 7px);left:calc(50% - 18px)}.marginTopDown{margin:10px 0}a.disabled{color:#eee;pointer-event:none}.cc{position:fixed;bottom:0;right:0;padding:5px}@media only screen and (max-device-width:480px){.cc{font-size:11px}}@keyframes spinning{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@-webkit-keyframes spinning{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}\", \"\"]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/sass-loader?sourceMap!./app/scss/main.scss\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scss/main.scss?./~/css-loader!./~/sass-loader?sourceMap")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {\n  var d3 = {\n    version: "3.5.17"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + "");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + "");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + "", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error("infinite range");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = "__proto__", d3_map_zero = "\\x00";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += "")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf("."), name = "";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, "\\\\$&");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === "function") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === "function" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === "function" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";\n  var d3_nsPrefix = {\n    svg: "http://www.w3.org/2000/svg",\n    xhtml: d3_nsXhtml,\n    xlink: "http://www.w3.org/1999/xlink",\n    xml: "http://www.w3.org/XML/1998/namespace",\n    xmlns: "http://www.w3.org/2000/xmlns/"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(":"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === "string") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, " ");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === "string") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute("class");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp("(?:^|\\\\s+)" + d3.requote(name) + "(?:\\\\s+|$)", "g");\n  }\n  function d3_selection_classes(name) {\n    return (name + "").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === "function" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute("class") || "";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));\n      } else {\n        node.setAttribute("class", d3_collapse(c.replace(re, " ")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== "string") {\n        if (n < 2) value = "";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = "";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === "string") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === "function" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? "" : v;\n    } : value == null ? function() {\n      this.textContent = "";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === "function" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? "" : v;\n    } : value == null ? function() {\n      this.innerHTML = "";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === "function") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property("__data__", value) : this.property("__data__");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== "function") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === "string") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === "string") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== "string") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()["__on" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: "mouseover",\n    mouseleave: "mouseout"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = "none";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select("body").append("svg").style({\n            position: "absolute",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: "none"\n          }, "important");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");\n    function drag() {\n      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: "dragstart"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: "drag",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: "dragend"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, "on");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < ε2) {\n      S = Math.log(w1 / w0) / ρ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ρ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, "mousewheel") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, "MozMousePixelScroll");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each("start.zoom", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween("zoom:zoom", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each("interrupt.zoom", function() {\n            zoomended(dispatch);\n          }).each("end.zoom", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: "zoomstart"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: "zoom",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: "zoomend"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, "on");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + "";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + "";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(",");\n      switch (m1[1]) {\n       case "hsl":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case "rgb":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === "function" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + "").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + "";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + "";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ "get", "post" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on("error", callback).on("load", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, "on");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== "text" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp(\'["\' + delimiter + "\\n]"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function("d", "return {" + row.map(function(name, i) {\n          return JSON.stringify(name) + ": d[" + i + "]";\n        }).join(",") + "}");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/""/g, \'"\');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join("\\n");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join("\\n");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? \'"\' + text.replace(/\\"/g, \'""\') + \'"\' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(",", "text/csv");\n  d3.tsv = d3.dsv("	", "text/tab-separated-values");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === "0" && align === "=") {\n        zfill = fill = "0";\n        align = "=";\n      }\n      switch (type) {\n       case "n":\n        comma = true;\n        type = "g";\n        break;\n\n       case "%":\n        scale = 100;\n        suffix = "%";\n        type = "f";\n        break;\n\n       case "p":\n        scale = 100;\n        suffix = "%";\n        type = "r";\n        break;\n\n       case "b":\n       case "o":\n       case "x":\n       case "X":\n        if (symbol === "#") prefix = "0" + type.toLowerCase();\n\n       case "c":\n        exponent = false;\n\n       case "d":\n        integer = true;\n        precision = 0;\n        break;\n\n       case "s":\n        scale = -1;\n        type = "r";\n        break;\n      }\n      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == "r" && !precision) type = "g";\n      if (precision != null) {\n        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return "";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf("."), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf("e") : -1;\n          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + "";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + "s"] = interval.range;\n    d3_time[day + "s"].utc = interval.utc.range;\n    d3_time[day + "OfYear"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join("");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if ("p" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {\n          if (!("w" in d)) d.w = "W" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      "%": function() {\n        return "%";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      "%": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    "-": "",\n    _: " ",\n    "0": "0"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: ".",\n    thousands: ",",\n    grouping: [ 3 ],\n    currency: [ "$", "" ],\n    dateTime: "%a %b %e %X %Y",\n    date: "%m/%d/%Y",\n    time: "%H:%M:%S",\n    periods: [ "AM", "PM" ],\n    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],\n    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],\n    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],\n    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ0, cosφ0, sinφ0;\n    d3_geo_area.point = function(λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \n      sinφ0 = Math.sin(φ);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      φ = φ * d3_radians / 2 + π / 4;\n      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(λ00, φ00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n  }\n  d3.geo.bounds = function() {\n    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dλSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;\n        range[0] = λ0, range[1] = λ1;\n      }\n    };\n    function point(λ, φ) {\n      ranges.push(range = [ λ0 = λ, λ1 = λ ]);\n      if (φ < φ0) φ0 = φ;\n      if (φ > φ1) φ1 = φ;\n    }\n    function linePoint(λ, φ) {\n      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = inflection[1] * d3_degrees;\n          if (φi > φ1) φ1 = φi;\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = -inflection[1] * d3_degrees;\n          if (φi < φ0) φ0 = φi;\n        } else {\n          if (φ < φ0) φ0 = φ;\n          if (φ > φ1) φ1 = φ;\n        }\n        if (antimeridian) {\n          if (λ < λ_) {\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n          } else {\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n          }\n        } else {\n          if (λ1 >= λ0) {\n            if (λ < λ0) λ0 = λ;\n            if (λ > λ1) λ1 = λ;\n          } else {\n            if (λ > λ_) {\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n            } else {\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n            }\n          }\n        }\n      } else {\n        point(λ, φ);\n      }\n      p0 = p, λ_ = λ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = λ0, range[1] = λ1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(λ, φ) {\n      if (p0) {\n        var dλ = λ - λ_;\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n      } else λ__ = λ, φ__ = φ;\n      d3_geo_area.point(λ, φ);\n      linePoint(λ, φ);\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(λ__, φ__);\n      d3_geo_area.lineEnd();\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n      range[0] = λ0, range[1] = λ1;\n      p0 = null;\n    }\n    function angle(λ0, λ1) {\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, dλ;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < ε2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < ε2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(λ, φ) {\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00, x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ00 = λ, φ00 = φ;\n      d3_geo_centroid.point = nextPoint;\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(λ00, φ00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(λ, φ) {\n        var point = rotate(λ, φ);\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n      }\n      function pointLine(λ, φ) {\n        var point = rotate(λ, φ);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(λ, φ) {\n        ring.push([ λ, φ ]);\n        var point = rotate(λ, φ);\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(λ, φ) {\n        line.push([ λ, φ ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);\n        if (abs(dλ - π) < ε) {\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          clean = 0;\n        }\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n    if (from == null) {\n      φ = direction * halfπ;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (abs(from[0] - to[0]) > ε) {\n      var s = from[0] < to[0] ? π : -π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n      }\n    }\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(λ, φ) {\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(λ, φ) {\n      var r = smallRadius ? radius : π - radius, code = 0;\n      if (λ < -r) code |= 1; else if (λ > r) code |= 2;\n      if (φ < -r) code |= 4; else if (φ > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\n    function forward(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = ρ0 - y;\n      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join("");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push("M", x, ",", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push("M", x, ",", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push("L", x, ",", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push("Z");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, τ);\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(λ, φ) {\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + δx, δy - x[1] * k ];\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + δx, δy - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, "precision");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(λ, φ) {\n    return [ λ, φ ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(λ, φ) {\n    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotationλ(δλ) {\n    return function(λ, φ) {\n      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n    };\n  }\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];\n    }\n    rotation.invert = function(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: "Polygon",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\n      } else {\n        from = radius + direction * τ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;\n    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: "MultiLineString",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ε;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ε;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: "LineString",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: "Polygon",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: "LineString",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === "function" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === "function" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var λ0, sinφ0, cosφ0;\n    d3_geo_length.point = function(λ, φ) {\n      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(λ, φ) {\n      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\n      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(λ, φ) {\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\n    }\n    azimuthal.invert = function(x, y) {\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\n    return Math.sqrt(2 / (1 + cosλcosφ));\n  }, function(ρ) {\n    return 2 * Math.asin(ρ / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\n    var c = Math.acos(cosλcosφ);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), t = function(φ) {\n      return Math.tan(π / 4 + φ / 2);\n    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(λ, φ) {\n      if (F > 0) {\n        if (φ < -halfπ + ε) φ = -halfπ + ε;\n      } else {\n        if (φ > halfπ - ε) φ = halfπ - ε;\n      }\n      var ρ = F / Math.pow(t(φ), n);\n      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\n      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;\n    if (abs(n) < ε) return d3_geo_equirectangular;\n    function forward(λ, φ) {\n      var ρ = G - φ;\n      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = G - y;\n      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / cosλcosφ;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(λ, φ) {\n    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k = π * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / (1 + cosλcosφ);\n  }, function(ρ) {\n    return 2 * Math.atan(ρ);\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(λ, φ) {\n    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ε) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ε) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -ε) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -ε) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\n            x: x0,\n            y: abs(x2 - x0) < ε ? y2 : y1\n          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\n            x: abs(y2 - y1) < ε ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\n            x: x1,\n            y: abs(x2 - x1) < ε ? y2 : y0\n          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\n            x: abs(y2 - y0) < ε ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -ε2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ε) * ε,\n          y: Math.round(fy(d, i) / ε) * ε,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + "", b = b + "";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + "";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join("");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    "in": d3_identity,\n    out: d3_ease_reverse,\n    "in-out": d3_ease_reflect,\n    "out-in": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * halfπ);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute("transform", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + "," : "";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push("translate(", null, ",", null, ")");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push("translate(" + tb + ")");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join("");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = (τ - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + "-" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: "end",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: "tick",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === "function" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === "function" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === "function" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: "end",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: "start",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == "number") o.source = nodes[o.source];\n        if (typeof o.target == "number") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position("x", w);\n        if (isNaN(o.y)) o.y = position("y", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, "on");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, "sort", "children", "value");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    "inside-out": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    "default": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === "number" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === "function" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== "squarify" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + "";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === "s") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = "f";\n        format = d3.format(match.join(""));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join("");\n    } else {\n      format = ",." + d3_scale_linearPrecision(range[2]) + "f";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : "";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: "range",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: "range",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: "rangePoints",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: "rangeRoundPoints",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: "rangeBands",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: "rangeRoundBands",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < π) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);\n          } else {\n            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);\n          }\n        } else {\n          path.push("M", x0, ",", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);\n          } else {\n            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);\n          }\n        } else {\n          path.push("L", x2, ",", y2);\n        }\n      } else {\n        path.push("M", x0, ",", y0);\n        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);\n        path.push("L", x2, ",", y2);\n        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);\n      }\n      path.push("Z");\n      return path.join("");\n    }\n    function circleSegment(r1, cw) {\n      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = "auto";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push("M", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join("") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    "linear-closed": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    "step-before": d3_svg_lineStepBefore,\n    "step-after": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    "basis-open": d3_svg_lineBasisOpen,\n    "basis-closed": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    "cardinal-open": d3_svg_lineCardinalOpen,\n    "cardinal-closed": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join("L") : points + "Z";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join("L") + "Z";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];\n    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);\n    if (n > 1) path.push("H", p[0]);\n    return path.join("");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];\n    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);\n    return path.join("");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];\n    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);\n    return path.join("");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push("L", pi);\n    return path.join("");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join("");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join("");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ε) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - halfπ;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join("") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? "M" : "L";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return "Q 0,0 " + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return "circle";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / π);\n    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";\n    },\n    "triangle-down": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";\n    },\n    "triangle-up": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if ("__data__" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== "function") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += "", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += "", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== "string") {\n        if (n < 2) value = "";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = "";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += "", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, "style." + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = "";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween("style." + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, "text", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = "";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each("end.transition", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? "__transition__" : "__transition_" + name + "__";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), \n        d3.transition(path));\n        tickEnter.append("line");\n        tickEnter.append("text");\n        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === "bottom" || orient === "top") {\n          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";\n          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");\n          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";\n          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");\n          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr("transform", function(d) {\n      var v0 = x0(d);\n      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr("transform", function(d) {\n      var v0 = y0(d);\n      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);\n        var background = g.selectAll(".background").data([ 0 ]);\n        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");\n        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");\n        var resize = g.selectAll(".resize").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append("g").attr("class", function(d) {\n          return "resize " + d;\n        }).style("cursor", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append("rect").attr("x", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr("y", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");\n        resize.style("display", brush.empty() ? "none" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each("start.brush", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: "brushstart"\n            });\n          }).tween("brush:brush", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: "brush",\n                mode: "resize"\n              });\n            };\n          }).each("end.brush", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: "brush",\n              mode: "resize"\n            });\n            event_({\n              type: "brushend"\n            });\n          });\n        } else {\n          event_({\n            type: "brushstart"\n          });\n          event_({\n            type: "brush",\n            mode: "resize"\n          });\n          event_({\n            type: "brushend"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(".resize").attr("transform", function(d) {\n        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";\n      });\n    }\n    function redrawX(g) {\n      g.select(".extent").attr("x", xExtent[0]);\n      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(".extent").attr("y", yExtent[0]);\n      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);\n      if (d3.event.changedTouches) {\n        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);\n      } else {\n        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);\n      }\n      g.interrupt().selectAll("*").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style("pointer-events", "none").selectAll(".resize").style("display", null);\n      d3.select("body").style("cursor", eventTarget.style("cursor"));\n      event_({\n        type: "brushstart"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: "brush",\n            mode: dragging ? "move" : "resize"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);\n        d3.select("body").style("cursor", null);\n        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);\n        dragRestore();\n        event_({\n          type: "brushend"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, "on");\n  };\n  var d3_svg_brushCursor = {\n    n: "ns-resize",\n    e: "ew-resize",\n    s: "ns-resize",\n    w: "ew-resize",\n    nw: "nwse-resize",\n    ne: "nesw-resize",\n    se: "nwse-resize",\n    sw: "nesw-resize"\n  };\n  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {\n    return d.getMilliseconds();\n  } ], [ ":%S", function(d) {\n    return d.getSeconds();\n  } ], [ "%I:%M", function(d) {\n    return d.getMinutes();\n  } ], [ "%I %p", function(d) {\n    return d.getHours();\n  } ], [ "%a %d", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ "%b %d", function(d) {\n    return d.getDate() != 1;\n  } ], [ "%B", function(d) {\n    return d.getMonth();\n  } ], [ "%Y", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ ":%S", function(d) {\n    return d.getUTCSeconds();\n  } ], [ "%I:%M", function(d) {\n    return d.getUTCMinutes();\n  } ], [ "%I %p", function(d) {\n    return d.getUTCHours();\n  } ], [ "%a %d", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ "%b %d", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ "%B", function(d) {\n    return d.getUTCMonth();\n  } ], [ "%Y", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, "application/json", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, "text/html", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;\n}();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3/d3.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/d3/d3.js?');
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CallbackQueue\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(14);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\n\n/**\n * A specialized pseudo-event module to help keep track of components waiting to\n * be notified when their DOM representations are available for use.\n *\n * This implements `PooledClass`, so you should never need to instantiate this.\n * Instead, use `CallbackQueue.getPooled()`.\n *\n * @class ReactMountReady\n * @implements PooledClass\n * @internal\n */\nfunction CallbackQueue() {\n  this._callbacks = null;\n  this._contexts = null;\n}\n\nassign(CallbackQueue.prototype, {\n\n  /**\n   * Enqueues a callback to be invoked when `notifyAll` is invoked.\n   *\n   * @param {function} callback Invoked when `notifyAll` is invoked.\n   * @param {?object} context Context to call `callback` with.\n   * @internal\n   */\n  enqueue: function (callback, context) {\n    this._callbacks = this._callbacks || [];\n    this._contexts = this._contexts || [];\n    this._callbacks.push(callback);\n    this._contexts.push(context);\n  },\n\n  /**\n   * Invokes all enqueued callbacks and clears the queue. This is invoked after\n   * the DOM representation of a component has been created or updated.\n   *\n   * @internal\n   */\n  notifyAll: function () {\n    var callbacks = this._callbacks;\n    var contexts = this._contexts;\n    if (callbacks) {\n      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;\n      this._callbacks = null;\n      this._contexts = null;\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i].call(contexts[i]);\n      }\n      callbacks.length = 0;\n      contexts.length = 0;\n    }\n  },\n\n  /**\n   * Resets the internal queue.\n   *\n   * @internal\n   */\n  reset: function () {\n    this._callbacks = null;\n    this._contexts = null;\n  },\n\n  /**\n   * `PooledClass` looks for this.\n   */\n  destructor: function () {\n    this.reset();\n  }\n\n});\n\nPooledClass.addPoolingTo(CallbackQueue);\n\nmodule.exports = CallbackQueue;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CallbackQueue.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CallbackQueue.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMPropertyOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\nvar ReactPerf = __webpack_require__(8);\n\nvar quoteAttributeValueForBrowser = __webpack_require__(191);\nvar warning = __webpack_require__(4);\n\n// Simplified subset\nvar VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\\w\\.\\-]*$/;\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;\n  return false;\n}\n\nfunction shouldIgnoreValue(propertyInfo, value) {\n  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  var reactProps = {\n    children: true,\n    dangerouslySetInnerHTML: true,\n    key: true,\n    ref: true\n  };\n  var warnedProperties = {};\n\n  var warnUnknownProperty = function (name) {\n    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {\n      return;\n    }\n\n    warnedProperties[name] = true;\n    var lowerCasedName = name.toLowerCase();\n\n    // data-* attributes should be lowercase; suggest the lowercase version\n    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;\n\n    // For now, only warn when we have a suggested correction. This prevents\n    // logging too much when using transferPropsTo.\n    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;\n  };\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\nvar DOMPropertyOperations = {\n\n  /**\n   * Creates markup for the ID property.\n   *\n   * @param {string} id Unescaped ID.\n   * @return {string} Markup string.\n   */\n  createMarkupForID: function (id) {\n    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);\n  },\n\n  setAttributeForID: function (node, id) {\n    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);\n  },\n\n  /**\n   * Creates markup for a property.\n   *\n   * @param {string} name\n   * @param {*} value\n   * @return {?string} Markup string, or null if the property was invalid.\n   */\n  createMarkupForProperty: function (name, value) {\n    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;\n    if (propertyInfo) {\n      if (shouldIgnoreValue(propertyInfo, value)) {\n        return '';\n      }\n      var attributeName = propertyInfo.attributeName;\n      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n        return attributeName + '=\"\"';\n      }\n      return attributeName + '=' + quoteAttributeValueForBrowser(value);\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      if (value == null) {\n        return '';\n      }\n      return name + '=' + quoteAttributeValueForBrowser(value);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warnUnknownProperty(name);\n    }\n    return null;\n  },\n\n  /**\n   * Creates markup for a custom property.\n   *\n   * @param {string} name\n   * @param {*} value\n   * @return {string} Markup string, or empty string if the property was invalid.\n   */\n  createMarkupForCustomAttribute: function (name, value) {\n    if (!isAttributeNameSafe(name) || value == null) {\n      return '';\n    }\n    return name + '=' + quoteAttributeValueForBrowser(value);\n  },\n\n  /**\n   * Sets the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   * @param {*} value\n   */\n  setValueForProperty: function (node, name, value) {\n    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod) {\n        mutationMethod(node, value);\n      } else if (shouldIgnoreValue(propertyInfo, value)) {\n        this.deleteValueForProperty(node, name);\n      } else if (propertyInfo.mustUseAttribute) {\n        var attributeName = propertyInfo.attributeName;\n        var namespace = propertyInfo.attributeNamespace;\n        // `setAttribute` with objects becomes only `[object]` in IE8/9,\n        // ('' + value) makes it output the correct toString()-value.\n        if (namespace) {\n          node.setAttributeNS(namespace, attributeName, '' + value);\n        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n          node.setAttribute(attributeName, '');\n        } else {\n          node.setAttribute(attributeName, '' + value);\n        }\n      } else {\n        var propName = propertyInfo.propertyName;\n        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the\n        // property type before comparing; only `value` does and is string.\n        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {\n          // Contrary to `setAttribute`, object properties are properly\n          // `toString`ed by IE8/9.\n          node[propName] = value;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      DOMPropertyOperations.setValueForAttribute(node, name, value);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warnUnknownProperty(name);\n    }\n  },\n\n  setValueForAttribute: function (node, name, value) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (value == null) {\n      node.removeAttribute(name);\n    } else {\n      node.setAttribute(name, '' + value);\n    }\n  },\n\n  /**\n   * Deletes the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   */\n  deleteValueForProperty: function (node, name) {\n    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod) {\n        mutationMethod(node, undefined);\n      } else if (propertyInfo.mustUseAttribute) {\n        node.removeAttribute(propertyInfo.attributeName);\n      } else {\n        var propName = propertyInfo.propertyName;\n        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);\n        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {\n          node[propName] = defaultValue;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      node.removeAttribute(name);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warnUnknownProperty(name);\n    }\n  }\n\n};\n\nReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {\n  setValueForProperty: 'setValueForProperty',\n  setValueForAttribute: 'setValueForAttribute',\n  deleteValueForProperty: 'deleteValueForProperty'\n});\n\nmodule.exports = DOMPropertyOperations;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMPropertyOperations.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMPropertyOperations.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LinkedValueUtils\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactPropTypes = __webpack_require__(89);\nvar ReactPropTypeLocations = __webpack_require__(28);\n\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\nvar hasReadOnlyValue = {\n  'button': true,\n  'checkbox': true,\n  'image': true,\n  'hidden': true,\n  'radio': true,\n  'reset': true,\n  'submit': true\n};\n\nfunction _assertSingleLink(inputProps) {\n  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\\'t want to use valueLink and vice versa.') : invariant(false) : undefined;\n}\nfunction _assertValueLink(inputProps) {\n  _assertSingleLink(inputProps);\n  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\\'t want to use valueLink.') : invariant(false) : undefined;\n}\n\nfunction _assertCheckedLink(inputProps) {\n  _assertSingleLink(inputProps);\n  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\\'t want to ' + 'use checkedLink') : invariant(false) : undefined;\n}\n\nvar propTypes = {\n  value: function (props, propName, componentName) {\n    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n      return null;\n    }\n    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n  },\n  checked: function (props, propName, componentName) {\n    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n      return null;\n    }\n    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n  },\n  onChange: ReactPropTypes.func\n};\n\nvar loggedTypeFailures = {};\nfunction getDeclarationErrorAddendum(owner) {\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\n/**\n * Provide a linked `value` attribute for controlled forms. You should not use\n * this outside of the ReactDOM controlled form components.\n */\nvar LinkedValueUtils = {\n  checkPropTypes: function (tagName, props, owner) {\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);\n      }\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n\n        var addendum = getDeclarationErrorAddendum(owner);\n        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;\n      }\n    }\n  },\n\n  /**\n   * @param {object} inputProps Props for form component\n   * @return {*} current value of the input either from value prop or link.\n   */\n  getValue: function (inputProps) {\n    if (inputProps.valueLink) {\n      _assertValueLink(inputProps);\n      return inputProps.valueLink.value;\n    }\n    return inputProps.value;\n  },\n\n  /**\n   * @param {object} inputProps Props for form component\n   * @return {*} current checked status of the input either from checked prop\n   *             or link.\n   */\n  getChecked: function (inputProps) {\n    if (inputProps.checkedLink) {\n      _assertCheckedLink(inputProps);\n      return inputProps.checkedLink.value;\n    }\n    return inputProps.checked;\n  },\n\n  /**\n   * @param {object} inputProps Props for form component\n   * @param {SyntheticEvent} event change event to handle\n   */\n  executeOnChange: function (inputProps, event) {\n    if (inputProps.valueLink) {\n      _assertValueLink(inputProps);\n      return inputProps.valueLink.requestChange(event.target.value);\n    } else if (inputProps.checkedLink) {\n      _assertCheckedLink(inputProps);\n      return inputProps.checkedLink.requestChange(event.target.checked);\n    } else if (inputProps.onChange) {\n      return inputProps.onChange.call(undefined, event);\n    }\n  }\n};\n\nmodule.exports = LinkedValueUtils;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LinkedValueUtils.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LinkedValueUtils.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentBrowserEnvironment\n */\n\n'use strict';\n\nvar ReactDOMIDOperations = __webpack_require__(46);\nvar ReactMount = __webpack_require__(6);\n\n/**\n * Abstracts away all functionality of the reconciler that requires knowledge of\n * the browser context. TODO: These callers should be refactored to avoid the\n * need for this injection.\n */\nvar ReactComponentBrowserEnvironment = {\n\n  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,\n\n  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,\n\n  /**\n   * If a particular environment requires that some resources be cleaned up,\n   * specify this in the injected Mixin. In the DOM, we would likely want to\n   * purge any cached node ID lookups.\n   *\n   * @private\n   */\n  unmountIDFromEnvironment: function (rootNodeID) {\n    ReactMount.purgeID(rootNodeID);\n  }\n\n};\n\nmodule.exports = ReactComponentBrowserEnvironment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentBrowserEnvironment.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentBrowserEnvironment.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentEnvironment\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\nvar injected = false;\n\nvar ReactComponentEnvironment = {\n\n  /**\n   * Optionally injectable environment dependent cleanup hook. (server vs.\n   * browser etc). Example: A browser system caches DOM nodes based on component\n   * ID and must remove that cache entry when this instance is unmounted.\n   */\n  unmountIDFromEnvironment: null,\n\n  /**\n   * Optionally injectable hook for swapping out mount images in the middle of\n   * the tree.\n   */\n  replaceNodeWithMarkupByID: null,\n\n  /**\n   * Optionally injectable hook for processing a queue of child updates. Will\n   * later move into MultiChildComponents.\n   */\n  processChildrenUpdates: null,\n\n  injection: {\n    injectEnvironment: function (environment) {\n      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;\n      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;\n      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;\n      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;\n      injected = true;\n    }\n  }\n\n};\n\nmodule.exports = ReactComponentEnvironment;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentEnvironment.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentEnvironment.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMIDOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = __webpack_require__(69);\nvar DOMPropertyOperations = __webpack_require__(42);\nvar ReactMount = __webpack_require__(6);\nvar ReactPerf = __webpack_require__(8);\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Errors for properties that should not be updated with `updatePropertyByID()`.\n *\n * @type {object}\n * @private\n */\nvar INVALID_PROPERTY_ERRORS = {\n  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',\n  style: '`style` must be set using `updateStylesByID()`.'\n};\n\n/**\n * Operations used to process updates to DOM nodes.\n */\nvar ReactDOMIDOperations = {\n\n  /**\n   * Updates a DOM node with new property values. This should only be used to\n   * update DOM properties in `DOMProperty`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} name A valid property name, see `DOMProperty`.\n   * @param {*} value New value of the property.\n   * @internal\n   */\n  updatePropertyByID: function (id, name, value) {\n    var node = ReactMount.getNode(id);\n    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;\n\n    // If we're updating to null or undefined, we should remove the property\n    // from the DOM node instead of inadvertantly setting to a string. This\n    // brings us in line with the same behavior we have on initial render.\n    if (value != null) {\n      DOMPropertyOperations.setValueForProperty(node, name, value);\n    } else {\n      DOMPropertyOperations.deleteValueForProperty(node, name);\n    }\n  },\n\n  /**\n   * Replaces a DOM node that exists in the document with markup.\n   *\n   * @param {string} id ID of child to be replaced.\n   * @param {string} markup Dangerous markup to inject in place of child.\n   * @internal\n   * @see {Danger.dangerouslyReplaceNodeWithMarkup}\n   */\n  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {\n    var node = ReactMount.getNode(id);\n    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);\n  },\n\n  /**\n   * Updates a component's children by processing a series of updates.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markup List of markup strings.\n   * @internal\n   */\n  dangerouslyProcessChildrenUpdates: function (updates, markup) {\n    for (var i = 0; i < updates.length; i++) {\n      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);\n    }\n    DOMChildrenOperations.processUpdates(updates, markup);\n  }\n};\n\nReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {\n  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',\n  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'\n});\n\nmodule.exports = ReactDOMIDOperations;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMIDOperations.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMIDOperations.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactElement = __webpack_require__(7);\nvar ReactInstanceMap = __webpack_require__(23);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);\n  },\n\n  enqueueSetPropsInternal: function (internalInstance, partialProps) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    var props = assign({}, element.props, partialProps);\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);\n  },\n\n  enqueueReplacePropsInternal: function (internalInstance, props) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  enqueueElementInternal: function (internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactUpdateQueue.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactUpdateQueue.js?");
},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactVersion\n */\n\n'use strict';\n\nmodule.exports = '0.14.8';\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactVersion.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactVersion.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule findDOMNode\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactInstanceMap = __webpack_require__(23);\nvar ReactMount = __webpack_require__(6);\n\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\n/**\n * Returns the DOM node rendered by this element.\n *\n * @param {ReactComponent|DOMElement} componentOrElement\n * @return {?DOMElement} The root node of this element.\n */\nfunction findDOMNode(componentOrElement) {\n  if (process.env.NODE_ENV !== 'production') {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null) {\n      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n      owner._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if (componentOrElement.nodeType === 1) {\n    return componentOrElement;\n  }\n  if (ReactInstanceMap.has(componentOrElement)) {\n    return ReactMount.getNodeFromInstance(componentOrElement);\n  }\n  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;\n   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;\n}\n\nmodule.exports = findDOMNode;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/findDOMNode.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/findDOMNode.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventCharCode\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\nmodule.exports = getEventCharCode;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventCharCode.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventCharCode.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventModifierState\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  'Alt': 'altKey',\n  'Control': 'ctrlKey',\n  'Meta': 'metaKey',\n  'Shift': 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nmodule.exports = getEventModifierState;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventModifierState.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventModifierState.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventTarget\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === 3 ? target.parentNode : target;\n}\n\nmodule.exports = getEventTarget;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventTarget.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventTarget.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getIteratorFn\n * @typechecks static-only\n */\n\n'use strict';\n\n/* global Symbol */\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n/**\n * Returns the iterator method function contained on the iterable object.\n *\n * Be sure to invoke the function with the iterable as context:\n *\n *     var iteratorFn = getIteratorFn(myIterable);\n *     if (iteratorFn) {\n *       var iterator = iteratorFn.call(myIterable);\n *       ...\n *     }\n *\n * @param {?object} maybeIterable\n * @return {?function}\n */\nfunction getIteratorFn(maybeIterable) {\n  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nmodule.exports = getIteratorFn;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getIteratorFn.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getIteratorFn.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule instantiateReactComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactCompositeComponent = __webpack_require__(150);\nvar ReactEmptyComponent = __webpack_require__(81);\nvar ReactNativeComponent = __webpack_require__(87);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\n// To avoid a cyclic dependency, we create the final class in this module\nvar ReactCompositeComponentWrapper = function () {};\nassign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {\n  _instantiateReactComponent: instantiateReactComponent\n});\n\nfunction getDeclarationErrorAddendum(owner) {\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the type reference is a known internal type. I.e. not a user\n * provided composite type.\n *\n * @param {function} type\n * @return {boolean} Returns true if this is a valid internal type.\n */\nfunction isInternalComponentType(type) {\n  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';\n}\n\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node) {\n  var instance;\n\n  if (node === null || node === false) {\n    instance = new ReactEmptyComponent(instantiateReactComponent);\n  } else if (typeof node === 'object') {\n    var element = node;\n    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;\n\n    // Special case string values\n    if (typeof element.type === 'string') {\n      instance = ReactNativeComponent.createInternalComponent(element);\n    } else if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // representations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n    } else {\n      instance = new ReactCompositeComponentWrapper();\n    }\n  } else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactNativeComponent.createInstanceForText(node);\n  } else {\n     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;\n  }\n\n  // Sets up the instance. This can probably just move into the constructor now.\n  instance.construct(node);\n\n  // These two fields are used by the DOM and ART diffing algorithms\n  // respectively. Instead of using expandos on components, we should be\n  // storing the state needed by the diffing algorithms elsewhere.\n  instance._mountIndex = 0;\n  instance._mountImage = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    instance._isOwnerNecessary = false;\n    instance._warnedAboutRefsInRender = false;\n  }\n\n  // Internal instances should fully constructed at this point, so they should\n  // not get any new fields added to them at this point.\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.preventExtensions) {\n      Object.preventExtensions(instance);\n    }\n  }\n\n  return instance;\n}\n\nmodule.exports = instantiateReactComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/instantiateReactComponent.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/instantiateReactComponent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = (eventName in document);\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isEventSupported.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isEventSupported.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setTextContent\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\nvar escapeTextContentForBrowser = __webpack_require__(32);\nvar setInnerHTML = __webpack_require__(33);\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  node.textContent = text;\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  if (!('textContent' in document.documentElement)) {\n    setTextContent = function (node, text) {\n      setInnerHTML(node, escapeTextContentForBrowser(text));\n    };\n  }\n}\n\nmodule.exports = setTextContent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/setTextContent.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/setTextContent.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shouldUpdateReactComponent\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Given a `prevElement` and `nextElement`, determines if the existing\n * instance should be updated as opposed to being destroyed or replaced by a new\n * instance. Both arguments are elements. This ensures that this logic can\n * operate on stateless trees without any backing instance.\n *\n * @param {?object} prevElement\n * @param {?object} nextElement\n * @return {boolean} True if the existing instance should be updated.\n * @protected\n */\nfunction shouldUpdateReactComponent(prevElement, nextElement) {\n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  var prevType = typeof prevElement;\n  var nextType = typeof nextElement;\n  if (prevType === 'string' || prevType === 'number') {\n    return nextType === 'string' || nextType === 'number';\n  } else {\n    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;\n  }\n  return false;\n}\n\nmodule.exports = shouldUpdateReactComponent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/shouldUpdateReactComponent.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/shouldUpdateReactComponent.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactElement = __webpack_require__(7);\nvar ReactInstanceHandles = __webpack_require__(19);\n\nvar getIteratorFn = __webpack_require__(53);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nvar didWarnAboutMaps = false;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} text Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (iteratorFn) {\n      var iterator = iteratorFn.call(children);\n      var step;\n      if (iteratorFn !== children.entries) {\n        var ii = 0;\n        while (!(step = iterator.next()).done) {\n          child = step.value;\n          nextName = nextNamePrefix + getComponentKey(child, ii++);\n          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n        }\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;\n          didWarnAboutMaps = true;\n        }\n        // Iterator will provide entry [k,v] tuples rather than values.\n        while (!(step = iterator.next()).done) {\n          var entry = step.value;\n          if (entry) {\n            child = entry[1];\n            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);\n            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n          }\n        }\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      if (process.env.NODE_ENV !== 'production') {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';\n        if (children._isReactElement) {\n          addendum = ' It looks like you\\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';\n        }\n        if (ReactCurrentOwner.current) {\n          var name = ReactCurrentOwner.current.getName();\n          if (name) {\n            addendum += ' Check the render method of `' + name + '`.';\n          }\n        }\n      }\n      var childrenString = String(children);\n       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/traverseAllChildren.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/traverseAllChildren.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule validateDOMNesting\n */\n\n'use strict';\n\nvar assign = __webpack_require__(3);\nvar emptyFunction = __webpack_require__(10);\nvar warning = __webpack_require__(4);\n\nvar validateDOMNesting = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    parentTag: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo = function (oldInfo, tag, instance) {\n    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.parentTag = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n\n      case 'pre':\n      case 'listing':\n\n      case 'table':\n\n      case 'hr':\n\n      case 'xmp':\n\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  /**\n   * Given a ReactCompositeComponent instance, return a list of its recursive\n   * owners, starting at the root and ending with the instance itself.\n   */\n  var findOwnerStack = function (instance) {\n    if (!instance) {\n      return [];\n    }\n\n    var stack = [];\n    /*eslint-disable space-after-keywords */\n    do {\n      /*eslint-enable space-after-keywords */\n      stack.push(instance);\n    } while (instance = instance._currentElement._owner);\n    stack.reverse();\n    return stack;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.parentTag;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var problematic = invalidParent || invalidAncestor;\n\n    if (problematic) {\n      var ancestorTag = problematic.tag;\n      var ancestorInstance = problematic.instance;\n\n      var childOwner = childInstance && childInstance._currentElement._owner;\n      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;\n\n      var childOwners = findOwnerStack(childOwner);\n      var ancestorOwners = findOwnerStack(ancestorOwner);\n\n      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);\n      var i;\n\n      var deepestCommon = -1;\n      for (i = 0; i < minStackLen; i++) {\n        if (childOwners[i] === ancestorOwners[i]) {\n          deepestCommon = i;\n        } else {\n          break;\n        }\n      }\n\n      var UNKNOWN = '(unknown)';\n      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {\n        return inst.getName() || UNKNOWN;\n      });\n      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {\n        return inst.getName() || UNKNOWN;\n      });\n      var ownerInfo = [].concat(\n      // If the parent and child instances have a common owner ancestor, start\n      // with that -- otherwise we just start with the parent's owners.\n      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,\n      // If we're warning about an invalid (non-parent) ancestry, add '...'\n      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');\n\n      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;\n      if (didWarn[warnKey]) {\n        return;\n      }\n      didWarn[warnKey] = true;\n\n      if (invalidParent) {\n        var info = '';\n        if (ancestorTag === 'table' && childTag === 'tr') {\n          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n        }\n        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;\n      } else {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;\n      }\n    }\n  };\n\n  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);\n\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;\n\n  // For testing\n  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.parentTag;\n    var parentTag = parentInfo && parentInfo.tag;\n    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n  };\n}\n\nmodule.exports = validateDOMNesting;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/validateDOMNesting.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/validateDOMNesting.js?");
},function(module,exports,__webpack_require__){eval('"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar ResultRow = (function (_Component) {\n  _inherits(ResultRow, _Component);\n\n  function ResultRow() {\n    _classCallCheck(this, ResultRow);\n\n    _get(Object.getPrototypeOf(ResultRow.prototype), "constructor", this).apply(this, arguments);\n  }\n\n  _createClass(ResultRow, [{\n    key: "render",\n    value: function render() {\n      var _props = this.props;\n      var data = _props.data;\n      var dataIndex = _props.dataIndex;\n      var rowIndex = _props.rowIndex;\n      var pointAction = _props.pointAction;\n\n      return _react2["default"].createElement(\n        "li",\n        { className: dataIndex === rowIndex ? "select table-view-cell search-result" : "table-view-cell search-result", onClick: function () {\n            return pointAction(data);\n          } },\n        " ",\n        data.properties.label,\n        " "\n      );\n    }\n  }]);\n\n  return ResultRow;\n})(_react.Component);\n\nexports["default"] = ResultRow;\nmodule.exports = exports["default"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/Search/ResultRow.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/Search/ResultRow.js?')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventListener\n * @typechecks\n */\n\n'use strict';\n\nvar emptyFunction = __webpack_require__(10);\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function (target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function () {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function () {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function (target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function () {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');\n      }\n      return {\n        remove: emptyFunction\n      };\n    }\n  },\n\n  registerDefault: function () {}\n};\n\nmodule.exports = EventListener;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/EventListener.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/EventListener.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule containsNode\n * @typechecks\n */\n\n'use strict';\n\nvar isTextNode = __webpack_require__(125);\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n *\n * @param {?DOMNode} outerNode Outer DOM node.\n * @param {?DOMNode} innerNode Inner DOM node.\n * @return {boolean} True if `outerNode` contains or is `innerNode`.\n */\nfunction containsNode(_x, _x2) {\n  var _again = true;\n\n  _function: while (_again) {\n    var outerNode = _x,\n        innerNode = _x2;\n    _again = false;\n\n    if (!outerNode || !innerNode) {\n      return false;\n    } else if (outerNode === innerNode) {\n      return true;\n    } else if (isTextNode(outerNode)) {\n      return false;\n    } else if (isTextNode(innerNode)) {\n      _x = outerNode;\n      _x2 = innerNode.parentNode;\n      _again = true;\n      continue _function;\n    } else if (outerNode.contains) {\n      return outerNode.contains(innerNode);\n    } else if (outerNode.compareDocumentPosition) {\n      return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n    } else {\n      return false;\n    }\n  }\n}\n\nmodule.exports = containsNode;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/containsNode.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/containsNode.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule focusNode\n */\n\n'use strict';\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch (e) {}\n}\n\nmodule.exports = focusNode;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/focusNode.js\n ** module id = 63\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/focusNode.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getActiveElement\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n */\n'use strict';\n\nfunction getActiveElement() /*?DOMElement*/{\n  if (typeof document === 'undefined') {\n    return null;\n  }\n  try {\n    return document.activeElement || document.body;\n  } catch (e) {\n    return document.body;\n  }\n}\n\nmodule.exports = getActiveElement;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/getActiveElement.js\n ** module id = 64\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/getActiveElement.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getMarkupWrap\n */\n\n/*eslint-disable fb-www/unsafe-html */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Dummy container used to detect which wraps are necessary.\n */\nvar dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Some browsers cannot use `innerHTML` to render certain elements standalone,\n * so we wrap them, render the wrapped nodes, then extract the desired node.\n *\n * In IE8, certain elements cannot render alone, so wrap all elements ('*').\n */\n\nvar shouldWrap = {};\n\nvar selectWrap = [1, '<select multiple=\"true\">', '</select>'];\nvar tableWrap = [1, '<table>', '</table>'];\nvar trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nvar svgWrap = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\">', '</svg>'];\n\nvar markupWrap = {\n  '*': [1, '?<div>', '</div>'],\n\n  'area': [1, '<map>', '</map>'],\n  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  'legend': [1, '<fieldset>', '</fieldset>'],\n  'param': [1, '<object>', '</object>'],\n  'tr': [2, '<table><tbody>', '</tbody></table>'],\n\n  'optgroup': selectWrap,\n  'option': selectWrap,\n\n  'caption': tableWrap,\n  'colgroup': tableWrap,\n  'tbody': tableWrap,\n  'tfoot': tableWrap,\n  'thead': tableWrap,\n\n  'td': trWrap,\n  'th': trWrap\n};\n\n// Initialize the SVG elements since we know they'll always need to be wrapped\n// consistently. If they are created inside a <div> they will be initialized in\n// the wrong namespace (and will not display).\nvar svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];\nsvgElements.forEach(function (nodeName) {\n  markupWrap[nodeName] = svgWrap;\n  shouldWrap[nodeName] = true;\n});\n\n/**\n * Gets the markup wrap configuration for the supplied `nodeName`.\n *\n * NOTE: This lazily detects which wraps are necessary for the current browser.\n *\n * @param {string} nodeName Lowercase `nodeName`.\n * @return {?array} Markup wrap configuration, if applicable.\n */\nfunction getMarkupWrap(nodeName) {\n  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;\n  if (!markupWrap.hasOwnProperty(nodeName)) {\n    nodeName = '*';\n  }\n  if (!shouldWrap.hasOwnProperty(nodeName)) {\n    if (nodeName === '*') {\n      dummyNode.innerHTML = '<link />';\n    } else {\n      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';\n    }\n    shouldWrap[nodeName] = !dummyNode.firstChild;\n  }\n  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;\n}\n\nmodule.exports = getMarkupWrap;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/getMarkupWrap.js\n ** module id = 65\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/getMarkupWrap.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shallowEqual\n * @typechecks\n * \n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  var bHasOwnProperty = hasOwnProperty.bind(objB);\n  for (var i = 0; i < keysA.length; i++) {\n    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/shallowEqual.js\n ** module id = 66\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/shallowEqual.js?")},function(module,exports){eval("var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['CloseCurlyDoubleQuote', [8221]], ['CloseCurlyQuote', [8217]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];\n\nvar alphaIndex = {};\nvar charIndex = {};\n\ncreateIndexes(alphaIndex, charIndex);\n\n/**\n * @constructor\n */\nfunction Html5Entities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.decode = function(str) {\n    if (str.length === 0) {\n        return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function(s, entity) {\n        var chr;\n        if (entity.charAt(0) === \"#\") {\n            var code = entity.charAt(1) === 'x' ?\n                parseInt(entity.substr(2).toLowerCase(), 16) :\n                parseInt(entity.substr(1));\n\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\n                chr = String.fromCharCode(code);\n            }\n        } else {\n            chr = alphaIndex[entity];\n        }\n        return chr || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.decode = function(str) {\n    return new Html5Entities().decode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encode = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var charInfo = charIndex[str.charCodeAt(i)];\n        if (charInfo) {\n            var alpha = charInfo[str.charCodeAt(i + 1)];\n            if (alpha) {\n                i++;\n            } else {\n                alpha = charInfo[''];\n            }\n            if (alpha) {\n                result += \"&\" + alpha + \";\";\n                i++;\n                continue;\n            }\n        }\n        result += str.charAt(i);\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encode = function(str) {\n    return new Html5Entities().encode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encodeNonUTF = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        var charInfo = charIndex[c];\n        if (charInfo) {\n            var alpha = charInfo[str.charCodeAt(i + 1)];\n            if (alpha) {\n                i++;\n            } else {\n                alpha = charInfo[''];\n            }\n            if (alpha) {\n                result += \"&\" + alpha + \";\";\n                i++;\n                continue;\n            }\n        }\n        if (c < 32 || c > 126) {\n            result += '&#' + c + ';';\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encodeNonUTF = function(str) {\n    return new Html5Entities().encodeNonUTF(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml5Entities.prototype.encodeNonASCII = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n Html5Entities.encodeNonASCII = function(str) {\n    return new Html5Entities().encodeNonASCII(str);\n };\n\n/**\n * @param {Object} alphaIndex Passed by reference.\n * @param {Object} charIndex Passed by reference.\n */\nfunction createIndexes(alphaIndex, charIndex) {\n    var i = ENTITIES.length;\n    var _results = [];\n    while (i--) {\n        var e = ENTITIES[i];\n        var alpha = e[0];\n        var chars = e[1];\n        var chr = chars[0];\n        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;\n        var charInfo;\n        if (addChar) {\n            charInfo = charIndex[chr] = charIndex[chr] || {};\n        }\n        if (chars[1]) {\n            var chr2 = chars[1];\n            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);\n            _results.push(addChar && (charInfo[chr2] = alpha));\n        } else {\n            alphaIndex[alpha] = String.fromCharCode(chr);\n            _results.push(addChar && (charInfo[''] = alpha));\n        }\n    }\n}\n\nmodule.exports = Html5Entities;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/html-entities/lib/html5-entities.js\n ** module id = 67\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/html-entities/lib/html5-entities.js?");
},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSProperty\n */\n\n'use strict';\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Most style properties can be unset by doing .style[prop] = '' but IE8\n * doesn't like doing that with shorthand properties so for the properties that\n * IE8 breaks on, which are listed here, we instead unset each of the\n * individual properties. See http://bugs.jquery.com/ticket/12385.\n * The 4-value 'clock' properties like margin, padding, border-width seem to\n * behave without any problems. Curiously, list-style works too without any\n * special prodding.\n */\nvar shorthandPropertyExpansions = {\n  background: {\n    backgroundAttachment: true,\n    backgroundColor: true,\n    backgroundImage: true,\n    backgroundPositionX: true,\n    backgroundPositionY: true,\n    backgroundRepeat: true\n  },\n  backgroundPosition: {\n    backgroundPositionX: true,\n    backgroundPositionY: true\n  },\n  border: {\n    borderWidth: true,\n    borderStyle: true,\n    borderColor: true\n  },\n  borderBottom: {\n    borderBottomWidth: true,\n    borderBottomStyle: true,\n    borderBottomColor: true\n  },\n  borderLeft: {\n    borderLeftWidth: true,\n    borderLeftStyle: true,\n    borderLeftColor: true\n  },\n  borderRight: {\n    borderRightWidth: true,\n    borderRightStyle: true,\n    borderRightColor: true\n  },\n  borderTop: {\n    borderTopWidth: true,\n    borderTopStyle: true,\n    borderTopColor: true\n  },\n  font: {\n    fontStyle: true,\n    fontVariant: true,\n    fontWeight: true,\n    fontSize: true,\n    lineHeight: true,\n    fontFamily: true\n  },\n  outline: {\n    outlineWidth: true,\n    outlineStyle: true,\n    outlineColor: true\n  }\n};\n\nvar CSSProperty = {\n  isUnitlessNumber: isUnitlessNumber,\n  shorthandPropertyExpansions: shorthandPropertyExpansions\n};\n\nmodule.exports = CSSProperty;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSProperty.js\n ** module id = 68\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSProperty.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar Danger = __webpack_require__(141);\nvar ReactMultiChildUpdateTypes = __webpack_require__(86);\nvar ReactPerf = __webpack_require__(8);\n\nvar setInnerHTML = __webpack_require__(33);\nvar setTextContent = __webpack_require__(56);\nvar invariant = __webpack_require__(2);\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nfunction insertChildAt(parentNode, childNode, index) {\n  // By exploiting arrays returning `undefined` for an undefined index, we can\n  // rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. However, using `undefined` is not allowed by all\n  // browsers so we must replace it with `null`.\n\n  // fix render order error in safari\n  // IE8 will throw error when index out of list size.\n  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);\n\n  parentNode.insertBefore(childNode, beforeChild);\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n\n  updateTextContent: setTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function (updates, markupList) {\n    var update;\n    // Mapping from parent IDs to initial child orderings.\n    var initialChildren = null;\n    // List of children that will be moved or removed.\n    var updatedChildren = null;\n\n    for (var i = 0; i < updates.length; i++) {\n      update = updates[i];\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n\n        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;\n\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup;\n    // markupList is either a list of markup or just a list of elements\n    if (markupList.length && typeof markupList[0] === 'string') {\n      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);\n    } else {\n      renderedMarkup = markupList;\n    }\n\n    // Remove updated children first so that `toIndex` is consistent.\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; k < updates.length; k++) {\n      update = updates[k];\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);\n          break;\n        case ReactMultiChildUpdateTypes.SET_MARKUP:\n          setInnerHTML(update.parentNode, update.content);\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          setTextContent(update.parentNode, update.content);\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n\n};\n\nReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {\n  updateTextContent: 'updateTextContent'\n});\n\nmodule.exports = DOMChildrenOperations;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMChildrenOperations.js\n ** module id = 69\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMChildrenOperations.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginRegistry\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Injectable ordering of event plugins.\n */\nvar EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!EventPluginOrder) {\n    // Wait until an `EventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var PluginModule = namesToPlugins[pluginName];\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\n    var publishedEvents = PluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function (InjectedEventPluginOrder) {\n    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;\n    // Clone the ordering so it cannot be dynamically mutated.\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var PluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;\n        namesToPlugins[pluginName] = PluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function (event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\n    }\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\n        continue;\n      }\n      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];\n      if (PluginModule) {\n        return PluginModule;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function () {\n    EventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginRegistry.js\n ** module id = 70\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginRegistry.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildren\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(14);\nvar ReactElement = __webpack_require__(7);\n\nvar emptyFunction = __webpack_require__(10);\nvar traverseAllChildren = __webpack_require__(58);\n\nvar twoArgumentPooler = PooledClass.twoArgumentPooler;\nvar fourArgumentPooler = PooledClass.fourArgumentPooler;\n\nvar userProvidedKeyEscapeRegex = /\\/(?!\\/)/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');\n}\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * traversal. Allows avoiding binding callbacks.\n *\n * @constructor ForEachBookKeeping\n * @param {!function} forEachFunction Function to perform traversal with.\n * @param {?*} forEachContext Context to perform context with.\n */\nfunction ForEachBookKeeping(forEachFunction, forEachContext) {\n  this.func = forEachFunction;\n  this.context = forEachContext;\n  this.count = 0;\n}\nForEachBookKeeping.prototype.destructor = function () {\n  this.func = null;\n  this.context = null;\n  this.count = 0;\n};\nPooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func;\n  var context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  ForEachBookKeeping.release(traverseContext);\n}\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * mapping. Allows avoiding binding callbacks.\n *\n * @constructor MapBookKeeping\n * @param {!*} mapResult Object containing the ordered map of results.\n * @param {!function} mapFunction Function to perform mapping with.\n * @param {?*} mapContext Context to perform mapping with.\n */\nfunction MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {\n  this.result = mapResult;\n  this.keyPrefix = keyPrefix;\n  this.func = mapFunction;\n  this.context = mapContext;\n  this.count = 0;\n}\nMapBookKeeping.prototype.destructor = function () {\n  this.result = null;\n  this.keyPrefix = null;\n  this.func = null;\n  this.context = null;\n  this.count = 0;\n};\nPooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result;\n  var keyPrefix = bookKeeping.keyPrefix;\n  var func = bookKeeping.func;\n  var context = bookKeeping.context;\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (ReactElement.isValidElement(mappedChild)) {\n      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  MapBookKeeping.release(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\nfunction forEachSingleChildDummy(traverseContext, child, name) {\n  return null;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, forEachSingleChildDummy, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\nvar ReactChildren = {\n  forEach: forEachChildren,\n  map: mapChildren,\n  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,\n  count: countChildren,\n  toArray: toArray\n};\n\nmodule.exports = ReactChildren;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactChildren.js\n ** module id = 71\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactChildren.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactClass\n */\n\n'use strict';\n\nvar ReactComponent = __webpack_require__(73);\nvar ReactElement = __webpack_require__(7);\nvar ReactPropTypeLocations = __webpack_require__(28);\nvar ReactPropTypeLocationNames = __webpack_require__(27);\nvar ReactNoopUpdateQueue = __webpack_require__(88);\n\nvar assign = __webpack_require__(3);\nvar emptyObject = __webpack_require__(20);\nvar invariant = __webpack_require__(2);\nvar keyMirror = __webpack_require__(25);\nvar keyOf = __webpack_require__(13);\nvar warning = __webpack_require__(4);\n\nvar MIXINS_KEY = keyOf({ mixins: null });\n\n/**\n * Policies that describe methods in `ReactClassInterface`.\n */\nvar SpecPolicy = keyMirror({\n  /**\n   * These methods may be defined only once by the class specification or mixin.\n   */\n  DEFINE_ONCE: null,\n  /**\n   * These methods may be defined by both the class specification and mixins.\n   * Subsequent definitions will be chained. These methods must return void.\n   */\n  DEFINE_MANY: null,\n  /**\n   * These methods are overriding the base class.\n   */\n  OVERRIDE_BASE: null,\n  /**\n   * These methods are similar to DEFINE_MANY, except we assume they return\n   * objects. We try to merge the keys of the return values of all the mixed in\n   * functions. If there is a key conflict we throw.\n   */\n  DEFINE_MANY_MERGED: null\n});\n\nvar injectedMixins = [];\n\nvar warnedSetProps = false;\nfunction warnSetProps() {\n  if (!warnedSetProps) {\n    warnedSetProps = true;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;\n  }\n}\n\n/**\n * Composite components are higher-level components that compose other composite\n * or native components.\n *\n * To create a new type of `ReactClass`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactClassInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will be available on the prototype.\n *\n * @interface ReactClassInterface\n * @internal\n */\nvar ReactClassInterface = {\n\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: SpecPolicy.DEFINE_MANY,\n\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: SpecPolicy.DEFINE_ONCE,\n\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: SpecPolicy.DEFINE_MANY,\n\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: SpecPolicy.OVERRIDE_BASE\n\n};\n\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\nvar RESERVED_SPEC_KEYS = {\n  displayName: function (Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function (Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function (Constructor, childContextTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);\n    }\n    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);\n  },\n  contextTypes: function (Constructor, contextTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);\n    }\n    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);\n  },\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function (Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function (Constructor, propTypes) {\n    if (process.env.NODE_ENV !== 'production') {\n      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);\n    }\n    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);\n  },\n  statics: function (Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  },\n  autobind: function () {} };\n\n// noop\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      // use a warning instead of an invariant so components\n      // don't show up in prod but not in __DEV__\n      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;\n    }\n  }\n}\n\nfunction validateMethodOverride(proto, name) {\n  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;\n\n  // Disallow overriding of base class methods unless explicitly allowed.\n  if (ReactClassMixin.hasOwnProperty(name)) {\n    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;\n  }\n\n  // Disallow defining methods more than once unless explicitly allowed.\n  if (proto.hasOwnProperty(name)) {\n    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;\n  }\n}\n\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building React classses.\n */\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    return;\n  }\n\n  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;\n  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;\n\n  var proto = Constructor.prototype;\n\n  // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above.\n      continue;\n    }\n\n    var property = spec[name];\n    validateMethodOverride(proto, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactClass methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n\n      if (shouldAutoBind) {\n        if (!proto.__reactAutoBindMap) {\n          proto.__reactAutoBindMap = {};\n        }\n        proto.__reactAutoBindMap[name] = property;\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactClassInterface[name];\n\n          // These cases should already be caught by validateMethodOverride.\n          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;\n\n          // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n          if (process.env.NODE_ENV !== 'production') {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n  for (var name in statics) {\n    var property = statics[name];\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = (name in RESERVED_SPEC_KEYS);\n    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;\n\n    var isInherited = (name in Constructor);\n    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;\n    Constructor[name] = property;\n  }\n}\n\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\nfunction mergeIntoWithNoDuplicateKeys(one, two) {\n  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;\n\n  for (var key in two) {\n    if (two.hasOwnProperty(key)) {\n      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;\n      one[key] = two[key];\n    }\n  }\n  return one;\n}\n\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n    var c = {};\n    mergeIntoWithNoDuplicateKeys(c, a);\n    mergeIntoWithNoDuplicateKeys(c, b);\n    return c;\n  };\n}\n\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\n/**\n * Binds a method to the component.\n *\n * @param {object} component Component whose method is going to be bound.\n * @param {function} method Method to be bound.\n * @return {function} The bound method.\n */\nfunction bindAutoBindMethod(component, method) {\n  var boundMethod = method.bind(component);\n  if (process.env.NODE_ENV !== 'production') {\n    boundMethod.__reactBoundContext = component;\n    boundMethod.__reactBoundMethod = method;\n    boundMethod.__reactBoundArguments = null;\n    var componentName = component.constructor.displayName;\n    var _bind = boundMethod.bind;\n    /* eslint-disable block-scoped-var, no-undef */\n    boundMethod.bind = function (newThis) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // User is trying to bind() an autobound method; we effectively will\n      // ignore the value of \"this\" that the user is trying to use, so\n      // let's warn.\n      if (newThis !== component && newThis !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;\n      } else if (!args.length) {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;\n        return boundMethod;\n      }\n      var reboundMethod = _bind.apply(boundMethod, arguments);\n      reboundMethod.__reactBoundContext = component;\n      reboundMethod.__reactBoundMethod = method;\n      reboundMethod.__reactBoundArguments = args;\n      return reboundMethod;\n      /* eslint-enable */\n    };\n  }\n  return boundMethod;\n}\n\n/**\n * Binds all auto-bound methods in a component.\n *\n * @param {object} component Component whose method is going to be bound.\n */\nfunction bindAutoBindMethods(component) {\n  for (var autoBindKey in component.__reactAutoBindMap) {\n    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n      var method = component.__reactAutoBindMap[autoBindKey];\n      component[autoBindKey] = bindAutoBindMethod(component, method);\n    }\n  }\n}\n\n/**\n * Add more to the ReactClass base class. These are all legacy features and\n * therefore not already part of the modern ReactComponent.\n */\nvar ReactClassMixin = {\n\n  /**\n   * TODO: This will be deprecated because state should always keep a consistent\n   * type signature and the only use case for this, is to avoid that.\n   */\n  replaceState: function (newState, callback) {\n    this.updater.enqueueReplaceState(this, newState);\n    if (callback) {\n      this.updater.enqueueCallback(this, callback);\n    }\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function () {\n    return this.updater.isMounted(this);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {object} partialProps Subset of the next props.\n   * @param {?function} callback Called after props are updated.\n   * @final\n   * @public\n   * @deprecated\n   */\n  setProps: function (partialProps, callback) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnSetProps();\n    }\n    this.updater.enqueueSetProps(this, partialProps);\n    if (callback) {\n      this.updater.enqueueCallback(this, callback);\n    }\n  },\n\n  /**\n   * Replace all the props.\n   *\n   * @param {object} newProps Subset of the next props.\n   * @param {?function} callback Called after props are updated.\n   * @final\n   * @public\n   * @deprecated\n   */\n  replaceProps: function (newProps, callback) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnSetProps();\n    }\n    this.updater.enqueueReplaceProps(this, newProps);\n    if (callback) {\n      this.updater.enqueueCallback(this, callback);\n    }\n  }\n};\n\nvar ReactClassComponent = function () {};\nassign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n\n/**\n * Module for creating composite components.\n *\n * @class ReactClass\n */\nvar ReactClass = {\n\n  /**\n   * Creates a composite component class given a class specification.\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function (spec) {\n    var Constructor = function (props, context, updater) {\n      // This constructor is overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted.\n\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;\n      }\n\n      // Wire up auto-binding\n      if (this.__reactAutoBindMap) {\n        bindAutoBindMethods(this);\n      }\n\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n\n      this.state = null;\n\n      // ReactClasses doesn't have constructors. Instead, they use the\n      // getInitialState and componentWillMount methods for initialization.\n\n      var initialState = this.getInitialState ? this.getInitialState() : null;\n      if (process.env.NODE_ENV !== 'production') {\n        // We allow auto-mocks to proceed as if they're returning null.\n        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {\n          // This is probably bad practice. Consider warning here and\n          // deprecating this convenience.\n          initialState = null;\n        }\n      }\n      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;\n\n      this.state = initialState;\n    };\n    Constructor.prototype = new ReactClassComponent();\n    Constructor.prototype.constructor = Constructor;\n\n    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n\n    mixSpecIntoComponent(Constructor, spec);\n\n    // Initialize the defaultProps property after all mixins have been merged.\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This is a tag to indicate that the use of these method names is ok,\n      // since it's used with createClass. If it's not, then it's likely a\n      // mistake so we'll warn you to use the static property, property\n      // initializer or constructor respectively.\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps.isReactClassApproved = {};\n      }\n      if (Constructor.prototype.getInitialState) {\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\n      }\n    }\n\n    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactClassInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    return Constructor;\n  },\n\n  injection: {\n    injectMixin: function (mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n\n};\n\nmodule.exports = ReactClass;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactClass.js\n ** module id = 72\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactClass.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\n'use strict';\n\nvar ReactNoopUpdateQueue = __webpack_require__(88);\n\nvar canDefineProperty = __webpack_require__(31);\nvar emptyObject = __webpack_require__(20);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction ReactComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nReactComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nReactComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;\n  }\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback);\n  }\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nReactComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback);\n  }\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\nif (process.env.NODE_ENV !== 'production') {\n  var deprecatedAPIs = {\n    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],\n    setProps: ['setProps', 'Instead, call render again at the top level.']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    if (canDefineProperty) {\n      Object.defineProperty(ReactComponent.prototype, methodName, {\n        get: function () {\n          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;\n          return undefined;\n        }\n      });\n    }\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nmodule.exports = ReactComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponent.js\n ** module id = 73\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponent.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOM\n */\n\n/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactDOMTextComponent = __webpack_require__(77);\nvar ReactDefaultInjection = __webpack_require__(79);\nvar ReactInstanceHandles = __webpack_require__(19);\nvar ReactMount = __webpack_require__(6);\nvar ReactPerf = __webpack_require__(8);\nvar ReactReconciler = __webpack_require__(16);\nvar ReactUpdates = __webpack_require__(9);\nvar ReactVersion = __webpack_require__(48);\n\nvar findDOMNode = __webpack_require__(49);\nvar renderSubtreeIntoContainer = __webpack_require__(192);\nvar warning = __webpack_require__(4);\n\nReactDefaultInjection.inject();\n\nvar render = ReactPerf.measure('React', 'render', ReactMount.render);\n\nvar React = {\n  findDOMNode: findDOMNode,\n  render: render,\n  unmountComponentAtNode: ReactMount.unmountComponentAtNode,\n  version: ReactVersion,\n\n  /* eslint-disable camelcase */\n  unstable_batchedUpdates: ReactUpdates.batchedUpdates,\n  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer\n};\n\n// Inject the runtime into a devtools global hook regardless of browser.\n// Allows for debugging when the hook is injected on the page.\n/* eslint-enable camelcase */\nif (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({\n    CurrentOwner: ReactCurrentOwner,\n    InstanceHandles: ReactInstanceHandles,\n    Mount: ReactMount,\n    Reconciler: ReactReconciler,\n    TextComponent: ReactDOMTextComponent\n  });\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  var ExecutionEnvironment = __webpack_require__(5);\n  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {\n\n    // First check if devtools is not installed\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n      // If we're in Chrome or Firefox, provide a download link if not installed.\n      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');\n      }\n    }\n\n    // If we're in IE8, check to see if we are in compatibility mode and provide\n    // information on preventing compatibility mode\n    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;\n\n    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />') : undefined;\n\n    var expectedFeatures = [\n    // shims\n    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,\n\n    // shams\n    Object.create, Object.freeze];\n\n    for (var i = 0; i < expectedFeatures.length; i++) {\n      if (!expectedFeatures[i]) {\n        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = React;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOM.js\n ** module id = 74\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOM.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMFeatureFlags\n */\n\n'use strict';\n\nvar ReactDOMFeatureFlags = {\n  useCreateElement: false\n};\n\nmodule.exports = ReactDOMFeatureFlags;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMFeatureFlags.js\n ** module id = 75\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMFeatureFlags.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelect\n */\n\n'use strict';\n\nvar LinkedValueUtils = __webpack_require__(43);\nvar ReactMount = __webpack_require__(6);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar warning = __webpack_require__(4);\n\nvar valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);\n\nfunction updateOptionsIfPendingUpdateAndMounted() {\n  if (this._rootNodeID && this._wrapperState.pendingUpdate) {\n    this._wrapperState.pendingUpdate = false;\n\n    var props = this._currentElement.props;\n    var value = LinkedValueUtils.getValue(props);\n\n    if (value != null) {\n      updateOptions(this, Boolean(props.multiple), value);\n    }\n  }\n}\n\nfunction getDeclarationErrorAddendum(owner) {\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n * @private\n */\nfunction checkSelectPropTypes(inst, props) {\n  var owner = inst._currentElement._owner;\n  LinkedValueUtils.checkPropTypes('select', props, owner);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    if (props.multiple) {\n      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;\n    } else {\n      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;\n    }\n  }\n}\n\n/**\n * @param {ReactDOMComponent} inst\n * @param {boolean} multiple\n * @param {*} propValue A stringable (with `multiple`, a list of stringables).\n * @private\n */\nfunction updateOptions(inst, multiple, propValue) {\n  var selectedValue, i;\n  var options = ReactMount.getNode(inst._rootNodeID).options;\n\n  if (multiple) {\n    selectedValue = {};\n    for (i = 0; i < propValue.length; i++) {\n      selectedValue['' + propValue[i]] = true;\n    }\n    for (i = 0; i < options.length; i++) {\n      var selected = selectedValue.hasOwnProperty(options[i].value);\n      if (options[i].selected !== selected) {\n        options[i].selected = selected;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    selectedValue = '' + propValue;\n    for (i = 0; i < options.length; i++) {\n      if (options[i].value === selectedValue) {\n        options[i].selected = true;\n        return;\n      }\n    }\n    if (options.length) {\n      options[0].selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> native component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\nvar ReactDOMSelect = {\n  valueContextKey: valueContextKey,\n\n  getNativeProps: function (inst, props, context) {\n    return assign({}, props, {\n      onChange: inst._wrapperState.onChange,\n      value: undefined\n    });\n  },\n\n  mountWrapper: function (inst, props) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkSelectPropTypes(inst, props);\n    }\n\n    var value = LinkedValueUtils.getValue(props);\n    inst._wrapperState = {\n      pendingUpdate: false,\n      initialValue: value != null ? value : props.defaultValue,\n      onChange: _handleChange.bind(inst),\n      wasMultiple: Boolean(props.multiple)\n    };\n  },\n\n  processChildContext: function (inst, props, context) {\n    // Pass down initial value so initial generated markup has correct\n    // `selected` attributes\n    var childContext = assign({}, context);\n    childContext[valueContextKey] = inst._wrapperState.initialValue;\n    return childContext;\n  },\n\n  postUpdateWrapper: function (inst) {\n    var props = inst._currentElement.props;\n\n    // After the initial mount, we control selected-ness manually so don't pass\n    // the context value down\n    inst._wrapperState.initialValue = undefined;\n\n    var wasMultiple = inst._wrapperState.wasMultiple;\n    inst._wrapperState.wasMultiple = Boolean(props.multiple);\n\n    var value = LinkedValueUtils.getValue(props);\n    if (value != null) {\n      inst._wrapperState.pendingUpdate = false;\n      updateOptions(inst, Boolean(props.multiple), value);\n    } else if (wasMultiple !== Boolean(props.multiple)) {\n      // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n      if (props.defaultValue != null) {\n        updateOptions(inst, Boolean(props.multiple), props.defaultValue);\n      } else {\n        // Revert the select back to its default unselected state.\n        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');\n      }\n    }\n  }\n};\n\nfunction _handleChange(event) {\n  var props = this._currentElement.props;\n  var returnValue = LinkedValueUtils.executeOnChange(props, event);\n\n  this._wrapperState.pendingUpdate = true;\n  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);\n  return returnValue;\n}\n\nmodule.exports = ReactDOMSelect;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelect.js\n ** module id = 76\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelect.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = __webpack_require__(69);\nvar DOMPropertyOperations = __webpack_require__(42);\nvar ReactComponentBrowserEnvironment = __webpack_require__(44);\nvar ReactMount = __webpack_require__(6);\n\nvar assign = __webpack_require__(3);\nvar escapeTextContentForBrowser = __webpack_require__(32);\nvar setTextContent = __webpack_require__(56);\nvar validateDOMNesting = __webpack_require__(59);\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function (props) {\n  // This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID);\n      // Populate node cache\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n\n});\n\nmodule.exports = ReactDOMTextComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMTextComponent.js\n ** module id = 77\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMTextComponent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultBatchingStrategy\n */\n\n'use strict';\n\nvar ReactUpdates = __webpack_require__(9);\nvar Transaction = __webpack_require__(30);\n\nvar assign = __webpack_require__(3);\nvar emptyFunction = __webpack_require__(10);\n\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function () {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  }\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)\n};\n\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n\nfunction ReactDefaultBatchingStrategyTransaction() {\n  this.reinitializeTransaction();\n}\n\nassign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  }\n});\n\nvar transaction = new ReactDefaultBatchingStrategyTransaction();\n\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function (callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      callback(a, b, c, d, e);\n    } else {\n      transaction.perform(callback, null, a, b, c, d, e);\n    }\n  }\n};\n\nmodule.exports = ReactDefaultBatchingStrategy;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultBatchingStrategy.js\n ** module id = 78\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultBatchingStrategy.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultInjection\n */\n\n'use strict';\n\nvar BeforeInputEventPlugin = __webpack_require__(137);\nvar ChangeEventPlugin = __webpack_require__(139);\nvar ClientReactRootIndex = __webpack_require__(140);\nvar DefaultEventPluginOrder = __webpack_require__(142);\nvar EnterLeaveEventPlugin = __webpack_require__(143);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar HTMLDOMPropertyConfig = __webpack_require__(146);\nvar ReactBrowserComponentMixin = __webpack_require__(148);\nvar ReactComponentBrowserEnvironment = __webpack_require__(44);\nvar ReactDefaultBatchingStrategy = __webpack_require__(78);\nvar ReactDOMComponent = __webpack_require__(152);\nvar ReactDOMTextComponent = __webpack_require__(77);\nvar ReactEventListener = __webpack_require__(162);\nvar ReactInjection = __webpack_require__(163);\nvar ReactInstanceHandles = __webpack_require__(19);\nvar ReactMount = __webpack_require__(6);\nvar ReactReconcileTransaction = __webpack_require__(167);\nvar SelectEventPlugin = __webpack_require__(173);\nvar ServerReactRootIndex = __webpack_require__(174);\nvar SimpleEventPlugin = __webpack_require__(175);\nvar SVGDOMPropertyConfig = __webpack_require__(172);\n\nvar alreadyInjected = false;\n\nfunction inject() {\n  if (alreadyInjected) {\n    // TODO: This is currently true because these injections are shared between\n    // the client and the server package. They should be built independently\n    // and not share any injection state. Then this problem will be solved.\n    return;\n  }\n  alreadyInjected = true;\n\n  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);\n\n  /**\n   * Inject modules for resolving DOM hierarchy and plugin ordering.\n   */\n  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);\n  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);\n  ReactInjection.EventPluginHub.injectMount(ReactMount);\n\n  /**\n   * Some important event plugins included by default (without having to require\n   * them).\n   */\n  ReactInjection.EventPluginHub.injectEventPluginsByName({\n    SimpleEventPlugin: SimpleEventPlugin,\n    EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n    ChangeEventPlugin: ChangeEventPlugin,\n    SelectEventPlugin: SelectEventPlugin,\n    BeforeInputEventPlugin: BeforeInputEventPlugin\n  });\n\n  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);\n\n  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);\n\n  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);\n\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\n  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');\n\n  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);\n  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n\n  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);\n\n  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);\n\n  if (process.env.NODE_ENV !== 'production') {\n    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';\n    if (/[?&]react_perf\\b/.test(url)) {\n      var ReactDefaultPerf = __webpack_require__(159);\n      ReactDefaultPerf.start();\n    }\n  }\n}\n\nmodule.exports = {\n  inject: inject\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultInjection.js\n ** module id = 79\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultInjection.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElementValidator\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(7);\nvar ReactPropTypeLocations = __webpack_require__(28);\nvar ReactPropTypeLocationNames = __webpack_require__(27);\nvar ReactCurrentOwner = __webpack_require__(12);\n\nvar canDefineProperty = __webpack_require__(31);\nvar getIteratorFn = __webpack_require__(53);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = ReactCurrentOwner.current.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nvar loggedTypeFailures = {};\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);\n  if (addenda === null) {\n    // we already showed the warning\n    return;\n  }\n  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;\n}\n\n/**\n * Shared warning and monitoring code for the key warnings.\n *\n * @internal\n * @param {string} messageType A key used for de-duping warnings.\n * @param {ReactElement} element Component that requires a key.\n * @param {*} parentType element's parent's type.\n * @returns {?object} A set of addenda to use in the warning message, or null\n * if the warning has already been shown before (and shouldn't be shown again).\n */\nfunction getAddendaForKeyUse(messageType, element, parentType) {\n  var addendum = getDeclarationErrorAddendum();\n  if (!addendum) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      addendum = ' Check the top-level render call using <' + parentName + '>.';\n    }\n  }\n\n  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});\n  if (memoizer[addendum]) {\n    return null;\n  }\n  memoizer[addendum] = true;\n\n  var addenda = {\n    parentOrOwner: addendum,\n    url: ' See https://fb.me/react-warning-keys for more information.',\n    childOwner: null\n  };\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';\n  }\n\n  return addenda;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (ReactElement.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement.isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    // Entry iterators provide implicit keys.\n    if (iteratorFn) {\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (ReactElement.isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assert that the props are valid\n *\n * @param {string} componentName Name of the component for error messages.\n * @param {object} propTypes Map of prop name to a ReactPropType\n * @param {object} props\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @private\n */\nfunction checkPropTypes(componentName, propTypes, props, location) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error;\n      // Prop type validation may throw. In case they do, we don't want to\n      // fail the render phase where it didn't fail before. So we log it.\n      // After these have been cleaned up, we'll let them throw.\n      try {\n        // This is intentionally an invariant that gets caught. It's the same\n        // behavior as without this statement except with a better message.\n        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;\n        error = propTypes[propName](props, propName, componentName, location);\n      } catch (ex) {\n        error = ex;\n      }\n      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n\n        var addendum = getDeclarationErrorAddendum();\n        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  if (componentClass.propTypes) {\n    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;\n  }\n}\n\nvar ReactElementValidator = {\n\n  createElement: function (type, props, children) {\n    var validType = typeof type === 'string' || typeof type === 'function';\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;\n\n    var element = ReactElement.createElement.apply(this, arguments);\n\n    // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n    if (element == null) {\n      return element;\n    }\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n    if (validType) {\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], type);\n      }\n    }\n\n    validatePropTypes(element);\n\n    return element;\n  },\n\n  createFactory: function (type) {\n    var validatedFactory = ReactElementValidator.createElement.bind(null, type);\n    // Legacy hook TODO: Warn if this is accessed\n    validatedFactory.type = type;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (canDefineProperty) {\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function () {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n    }\n\n    return validatedFactory;\n  },\n\n  cloneElement: function (element, props, children) {\n    var newElement = ReactElement.cloneElement.apply(this, arguments);\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], newElement.type);\n    }\n    validatePropTypes(newElement);\n    return newElement;\n  }\n\n};\n\nmodule.exports = ReactElementValidator;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElementValidator.js\n ** module id = 80\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElementValidator.js?");
},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEmptyComponent\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(7);\nvar ReactEmptyComponentRegistry = __webpack_require__(82);\nvar ReactReconciler = __webpack_require__(16);\n\nvar assign = __webpack_require__(3);\n\nvar placeholderElement;\n\nvar ReactEmptyComponentInjection = {\n  injectEmptyComponent: function (component) {\n    placeholderElement = ReactElement.createElement(component);\n  }\n};\n\nfunction registerNullComponentID() {\n  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);\n}\n\nvar ReactEmptyComponent = function (instantiate) {\n  this._currentElement = null;\n  this._rootNodeID = null;\n  this._renderedComponent = instantiate(placeholderElement);\n};\nassign(ReactEmptyComponent.prototype, {\n  construct: function (element) {},\n  mountComponent: function (rootID, transaction, context) {\n    transaction.getReactMountReady().enqueue(registerNullComponentID, this);\n    this._rootNodeID = rootID;\n    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);\n  },\n  receiveComponent: function () {},\n  unmountComponent: function (rootID, transaction, context) {\n    ReactReconciler.unmountComponent(this._renderedComponent);\n    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);\n    this._rootNodeID = null;\n    this._renderedComponent = null;\n  }\n});\n\nReactEmptyComponent.injection = ReactEmptyComponentInjection;\n\nmodule.exports = ReactEmptyComponent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEmptyComponent.js\n ** module id = 81\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEmptyComponent.js?")},function(module,exports){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEmptyComponentRegistry\n */\n\n'use strict';\n\n// This registry keeps track of the React IDs of the components that rendered to\n// `null` (in reality a placeholder such as `noscript`)\nvar nullComponentIDsRegistry = {};\n\n/**\n * @param {string} id Component's `_rootNodeID`.\n * @return {boolean} True if the component is rendered to null.\n */\nfunction isNullComponentID(id) {\n  return !!nullComponentIDsRegistry[id];\n}\n\n/**\n * Mark the component as having rendered to null.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction registerNullComponentID(id) {\n  nullComponentIDsRegistry[id] = true;\n}\n\n/**\n * Unmark the component as having rendered to null: it renders to something now.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction deregisterNullComponentID(id) {\n  delete nullComponentIDsRegistry[id];\n}\n\nvar ReactEmptyComponentRegistry = {\n  isNullComponentID: isNullComponentID,\n  registerNullComponentID: registerNullComponentID,\n  deregisterNullComponentID: deregisterNullComponentID\n};\n\nmodule.exports = ReactEmptyComponentRegistry;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEmptyComponentRegistry.js\n ** module id = 82\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEmptyComponentRegistry.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactErrorUtils\n * @typechecks\n */\n\n'use strict';\n\nvar caughtError = null;\n\n/**\n * Call a function while guarding against errors that happens within it.\n *\n * @param {?String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} a First argument\n * @param {*} b Second argument\n */\nfunction invokeGuardedCallback(name, func, a, b) {\n  try {\n    return func(a, b);\n  } catch (x) {\n    if (caughtError === null) {\n      caughtError = x;\n    }\n    return undefined;\n  }\n}\n\nvar ReactErrorUtils = {\n  invokeGuardedCallback: invokeGuardedCallback,\n\n  /**\n   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event\n   * handler are sure to be rethrown by rethrowCaughtError.\n   */\n  invokeGuardedCallbackWithCatch: invokeGuardedCallback,\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    if (caughtError) {\n      var error = caughtError;\n      caughtError = null;\n      throw error;\n    }\n  }\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * To help development we can get better devtools integration by simulating a\n   * real browser event.\n   */\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {\n      var boundFunc = func.bind(null, a, b);\n      var evtType = 'react-' + name;\n      fakeNode.addEventListener(evtType, boundFunc, false);\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n      fakeNode.removeEventListener(evtType, boundFunc, false);\n    };\n  }\n}\n\nmodule.exports = ReactErrorUtils;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactErrorUtils.js\n ** module id = 83\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactErrorUtils.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInputSelection\n */\n\n'use strict';\n\nvar ReactDOMSelection = __webpack_require__(156);\n\nvar containsNode = __webpack_require__(62);\nvar focusNode = __webpack_require__(63);\nvar getActiveElement = __webpack_require__(64);\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\nvar ReactInputSelection = {\n\n  hasSelectionCapabilities: function (elem) {\n    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n  },\n\n  getSelectionInformation: function () {\n    var focusedElem = getActiveElement();\n    return {\n      focusedElem: focusedElem,\n      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null\n    };\n  },\n\n  /**\n   * @restoreSelection: If any selection information was potentially lost,\n   * restore it. This is useful when performing operations that could remove dom\n   * nodes and place them back in, resulting in focus being lost.\n   */\n  restoreSelection: function (priorSelectionInformation) {\n    var curFocusedElem = getActiveElement();\n    var priorFocusedElem = priorSelectionInformation.focusedElem;\n    var priorSelectionRange = priorSelectionInformation.selectionRange;\n    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);\n      }\n      focusNode(priorFocusedElem);\n    }\n  },\n\n  /**\n   * @getSelection: Gets the selection bounds of a focused textarea, input or\n   * contentEditable node.\n   * -@input: Look up selection bounds of this input\n   * -@return {start: selectionStart, end: selectionEnd}\n   */\n  getSelection: function (input) {\n    var selection;\n\n    if ('selectionStart' in input) {\n      // Modern browser with input or textarea.\n      selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      };\n    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {\n      // IE8 input.\n      var range = document.selection.createRange();\n      // There can only be one selection per document in IE, so it must\n      // be in our element.\n      if (range.parentElement() === input) {\n        selection = {\n          start: -range.moveStart('character', -input.value.length),\n          end: -range.moveEnd('character', -input.value.length)\n        };\n      }\n    } else {\n      // Content editable or old IE textarea.\n      selection = ReactDOMSelection.getOffsets(input);\n    }\n\n    return selection || { start: 0, end: 0 };\n  },\n\n  /**\n   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n   * the input.\n   * -@input     Set selection bounds of this input or textarea\n   * -@offsets   Object of same form that is returned from get*\n   */\n  setSelection: function (input, offsets) {\n    var start = offsets.start;\n    var end = offsets.end;\n    if (typeof end === 'undefined') {\n      end = start;\n    }\n\n    if ('selectionStart' in input) {\n      input.selectionStart = start;\n      input.selectionEnd = Math.min(end, input.value.length);\n    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {\n      var range = input.createTextRange();\n      range.collapse(true);\n      range.moveStart('character', start);\n      range.moveEnd('character', end - start);\n      range.select();\n    } else {\n      ReactDOMSelection.setOffsets(input, offsets);\n    }\n  }\n};\n\nmodule.exports = ReactInputSelection;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInputSelection.js\n ** module id = 84\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInputSelection.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMarkupChecksum\n */\n\n'use strict';\n\nvar adler32 = __webpack_require__(184);\n\nvar TAG_END = /\\/?>/;\n\nvar ReactMarkupChecksum = {\n  CHECKSUM_ATTR_NAME: 'data-react-checksum',\n\n  /**\n   * @param {string} markup Markup string\n   * @return {string} Markup string with checksum attribute attached\n   */\n  addChecksumToMarkup: function (markup) {\n    var checksum = adler32(markup);\n\n    // Add checksum (handle both parent tags and self-closing tags)\n    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '=\"' + checksum + '\"$&');\n  },\n\n  /**\n   * @param {string} markup to use\n   * @param {DOMElement} element root React element\n   * @returns {boolean} whether or not the markup is the same\n   */\n  canReuseMarkup: function (markup, element) {\n    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);\n    var markupChecksum = adler32(markup);\n    return markupChecksum === existingChecksum;\n  }\n};\n\nmodule.exports = ReactMarkupChecksum;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMarkupChecksum.js\n ** module id = 85\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMarkupChecksum.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChildUpdateTypes\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(25);\n\n/**\n * When a component's children are updated, a series of update configuration\n * objects are created in order to batch and serialize the required changes.\n *\n * Enumerates all the possible types of update configurations.\n *\n * @internal\n */\nvar ReactMultiChildUpdateTypes = keyMirror({\n  INSERT_MARKUP: null,\n  MOVE_EXISTING: null,\n  REMOVE_NODE: null,\n  SET_MARKUP: null,\n  TEXT_CONTENT: null\n});\n\nmodule.exports = ReactMultiChildUpdateTypes;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChildUpdateTypes.js\n ** module id = 86\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChildUpdateTypes.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNativeComponent\n */\n\n'use strict';\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\n\nvar autoGenerateWrapperClass = null;\nvar genericComponentClass = null;\n// This registry keeps track of wrapper classes around native tags.\nvar tagToComponentClass = {};\nvar textComponentClass = null;\n\nvar ReactNativeComponentInjection = {\n  // This accepts a class that receives the tag string. This is a catch all\n  // that can render any kind of tag.\n  injectGenericComponentClass: function (componentClass) {\n    genericComponentClass = componentClass;\n  },\n  // This accepts a text component class that takes the text string to be\n  // rendered as props.\n  injectTextComponentClass: function (componentClass) {\n    textComponentClass = componentClass;\n  },\n  // This accepts a keyed object with classes as values. Each key represents a\n  // tag. That particular tag will use this class instead of the generic one.\n  injectComponentClasses: function (componentClasses) {\n    assign(tagToComponentClass, componentClasses);\n  }\n};\n\n/**\n * Get a composite component wrapper class for a specific tag.\n *\n * @param {ReactElement} element The tag for which to get the class.\n * @return {function} The React class constructor function.\n */\nfunction getComponentClassForElement(element) {\n  if (typeof element.type === 'function') {\n    return element.type;\n  }\n  var tag = element.type;\n  var componentClass = tagToComponentClass[tag];\n  if (componentClass == null) {\n    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);\n  }\n  return componentClass;\n}\n\n/**\n * Get a native internal component class for a specific tag.\n *\n * @param {ReactElement} element The element to create.\n * @return {function} The internal class constructor function.\n */\nfunction createInternalComponent(element) {\n  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;\n  return new genericComponentClass(element.type, element.props);\n}\n\n/**\n * @param {ReactText} text\n * @return {ReactComponent}\n */\nfunction createInstanceForText(text) {\n  return new textComponentClass(text);\n}\n\n/**\n * @param {ReactComponent} component\n * @return {boolean}\n */\nfunction isTextComponent(component) {\n  return component instanceof textComponentClass;\n}\n\nvar ReactNativeComponent = {\n  getComponentClassForElement: getComponentClassForElement,\n  createInternalComponent: createInternalComponent,\n  createInstanceForText: createInstanceForText,\n  isTextComponent: isTextComponent,\n  injection: ReactNativeComponentInjection\n};\n\nmodule.exports = ReactNativeComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactNativeComponent.js\n ** module id = 87\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactNativeComponent.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNoopUpdateQueue\n */\n\n'use strict';\n\nvar warning = __webpack_require__(4);\n\nfunction warnTDZ(publicInstance, callerName) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {},\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    warnTDZ(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    warnTDZ(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    warnTDZ(publicInstance, 'setState');\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    warnTDZ(publicInstance, 'setProps');\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    warnTDZ(publicInstance, 'replaceProps');\n  }\n\n};\n\nmodule.exports = ReactNoopUpdateQueue;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactNoopUpdateQueue.js\n ** module id = 88\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactNoopUpdateQueue.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypes\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(7);\nvar ReactPropTypeLocationNames = __webpack_require__(27);\n\nvar emptyFunction = __webpack_require__(10);\nvar getIteratorFn = __webpack_require__(53);\n\n/**\n * Collection of methods that allow declaration and validation of props that are\n * supplied to React components. Example usage:\n *\n *   var Props = require('ReactPropTypes');\n *   var MyArticle = React.createClass({\n *     propTypes: {\n *       // An optional string prop named \"description\".\n *       description: Props.string,\n *\n *       // A required enum prop named \"category\".\n *       category: Props.oneOf(['News','Photos']).isRequired,\n *\n *       // A prop named \"dialog\" that requires an instance of Dialog.\n *       dialog: Props.instanceOf(Dialog).isRequired\n *     },\n *     render: function() { ... }\n *   });\n *\n * A more formal specification of how these methods are used:\n *\n *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n *   decl := ReactPropTypes.{type}(.isRequired)?\n *\n * Each and every declaration produces a function with the same signature. This\n * allows the creation of custom validation functions. For example:\n *\n *  var MyLink = React.createClass({\n *    propTypes: {\n *      // An optional string or URI prop named \"href\".\n *      href: function(props, propName, componentName) {\n *        var propValue = props[propName];\n *        if (propValue != null && typeof propValue !== 'string' &&\n *            !(propValue instanceof URI)) {\n *          return new Error(\n *            'Expected a string or an URI for ' + propName + ' in ' +\n *            componentName\n *          );\n *        }\n *      }\n *    },\n *    render: function() {...}\n *  });\n *\n * @internal\n */\n\nvar ANONYMOUS = '<<anonymous>>';\n\nvar ReactPropTypes = {\n  array: createPrimitiveTypeChecker('array'),\n  bool: createPrimitiveTypeChecker('boolean'),\n  func: createPrimitiveTypeChecker('function'),\n  number: createPrimitiveTypeChecker('number'),\n  object: createPrimitiveTypeChecker('object'),\n  string: createPrimitiveTypeChecker('string'),\n\n  any: createAnyTypeChecker(),\n  arrayOf: createArrayOfTypeChecker,\n  element: createElementTypeChecker(),\n  instanceOf: createInstanceTypeChecker,\n  node: createNodeChecker(),\n  objectOf: createObjectOfTypeChecker,\n  oneOf: createEnumTypeChecker,\n  oneOfType: createUnionTypeChecker,\n  shape: createShapeTypeChecker\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    componentName = componentName || ANONYMOUS;\n    propFullName = propFullName || propName;\n    if (props[propName] == null) {\n      var locationName = ReactPropTypeLocationNames[location];\n      if (isRequired) {\n        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));\n      }\n      return null;\n    } else {\n      return validate(props, propName, componentName, location, propFullName);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nfunction createPrimitiveTypeChecker(expectedType) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== expectedType) {\n      var locationName = ReactPropTypeLocationNames[location];\n      // `propValue` being instance of, say, date/regexp, pass the 'object'\n      // check, but we can offer a more precise error message here rather than\n      // 'of type `object`'.\n      var preciseType = getPreciseType(propValue);\n\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createAnyTypeChecker() {\n  return createChainableTypeChecker(emptyFunction.thatReturns(null));\n}\n\nfunction createArrayOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    if (!Array.isArray(propValue)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var propType = getPropType(propValue);\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n    }\n    for (var i = 0; i < propValue.length; i++) {\n      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');\n      if (error instanceof Error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createElementTypeChecker() {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!ReactElement.isValidElement(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createInstanceTypeChecker(expectedClass) {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!(props[propName] instanceof expectedClass)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var expectedClassName = expectedClass.name || ANONYMOUS;\n      var actualClassName = getClassName(props[propName]);\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createEnumTypeChecker(expectedValues) {\n  if (!Array.isArray(expectedValues)) {\n    return createChainableTypeChecker(function () {\n      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');\n    });\n  }\n\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    for (var i = 0; i < expectedValues.length; i++) {\n      if (propValue === expectedValues[i]) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    var valuesString = JSON.stringify(expectedValues);\n    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createObjectOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n    }\n    for (var key in propValue) {\n      if (propValue.hasOwnProperty(key)) {\n        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createUnionTypeChecker(arrayOfTypeCheckers) {\n  if (!Array.isArray(arrayOfTypeCheckers)) {\n    return createChainableTypeChecker(function () {\n      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');\n    });\n  }\n\n  function validate(props, propName, componentName, location, propFullName) {\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (checker(props, propName, componentName, location, propFullName) == null) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createNodeChecker() {\n  function validate(props, propName, componentName, location, propFullName) {\n    if (!isNode(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createShapeTypeChecker(shapeTypes) {\n  function validate(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n    }\n    for (var key in shapeTypes) {\n      var checker = shapeTypes[key];\n      if (!checker) {\n        continue;\n      }\n      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);\n      if (error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction isNode(propValue) {\n  switch (typeof propValue) {\n    case 'number':\n    case 'string':\n    case 'undefined':\n      return true;\n    case 'boolean':\n      return !propValue;\n    case 'object':\n      if (Array.isArray(propValue)) {\n        return propValue.every(isNode);\n      }\n      if (propValue === null || ReactElement.isValidElement(propValue)) {\n        return true;\n      }\n\n      var iteratorFn = getIteratorFn(propValue);\n      if (iteratorFn) {\n        var iterator = iteratorFn.call(propValue);\n        var step;\n        if (iteratorFn !== propValue.entries) {\n          while (!(step = iterator.next()).done) {\n            if (!isNode(step.value)) {\n              return false;\n            }\n          }\n        } else {\n          // Iterator will provide entry [k,v] tuples rather than values.\n          while (!(step = iterator.next()).done) {\n            var entry = step.value;\n            if (entry) {\n              if (!isNode(entry[1])) {\n                return false;\n              }\n            }\n          }\n        }\n      } else {\n        return false;\n      }\n\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Equivalent of `typeof` but with special handling for array and regexp.\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n  if (Array.isArray(propValue)) {\n    return 'array';\n  }\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return 'object';\n  }\n  return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// See `createPrimitiveTypeChecker`.\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n  if (propType === 'object') {\n    if (propValue instanceof Date) {\n      return 'date';\n    } else if (propValue instanceof RegExp) {\n      return 'regexp';\n    }\n  }\n  return propType;\n}\n\n// Returns class name of the object, if any.\nfunction getClassName(propValue) {\n  if (!propValue.constructor || !propValue.constructor.name) {\n    return '<<anonymous>>';\n  }\n  return propValue.constructor.name;\n}\n\nmodule.exports = ReactPropTypes;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypes.js\n ** module id = 89\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypes.js?");
},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\nvar ReactRootIndexInjection = {\n  /**\n   * @param {function} _createReactRootIndex\n   */\n  injectCreateReactRootIndex: function (_createReactRootIndex) {\n    ReactRootIndex.createReactRootIndex = _createReactRootIndex;\n  }\n};\n\nvar ReactRootIndex = {\n  createReactRootIndex: null,\n  injection: ReactRootIndexInjection\n};\n\nmodule.exports = ReactRootIndex;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactRootIndex.js\n ** module id = 90\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactRootIndex.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ViewportMetrics\n */\n\n'use strict';\n\nvar ViewportMetrics = {\n\n  currentScrollLeft: 0,\n\n  currentScrollTop: 0,\n\n  refreshScrollValues: function (scrollPosition) {\n    ViewportMetrics.currentScrollLeft = scrollPosition.x;\n    ViewportMetrics.currentScrollTop = scrollPosition.y;\n  }\n\n};\n\nmodule.exports = ViewportMetrics;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ViewportMetrics.js\n ** module id = 91\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ViewportMetrics.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule accumulateInto\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n *\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  var currentIsArray = Array.isArray(current);\n  var nextIsArray = Array.isArray(next);\n\n  if (currentIsArray && nextIsArray) {\n    current.push.apply(current, next);\n    return current;\n  }\n\n  if (currentIsArray) {\n    current.push(next);\n    return current;\n  }\n\n  if (nextIsArray) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nmodule.exports = accumulateInto;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/accumulateInto.js\n ** module id = 92\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/accumulateInto.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule forEachAccumulated\n */\n\n'use strict';\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n */\nvar forEachAccumulated = function (arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n};\n\nmodule.exports = forEachAccumulated;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/forEachAccumulated.js\n ** module id = 93\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/forEachAccumulated.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentAccessor\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\nmodule.exports = getTextContentAccessor;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getTextContentAccessor.js\n ** module id = 94\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getTextContentAccessor.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextInputElement\n */\n\n'use strict';\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  'color': true,\n  'date': true,\n  'datetime': true,\n  'datetime-local': true,\n  'email': true,\n  'month': true,\n  'number': true,\n  'password': true,\n  'range': true,\n  'search': true,\n  'tel': true,\n  'text': true,\n  'time': true,\n  'url': true,\n  'week': true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');\n}\n\nmodule.exports = isTextInputElement;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isTextInputElement.js\n ** module id = 95\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isTextInputElement.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nexports.__esModule = true;\nexports['default'] = createStore;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _utilsIsPlainObject = __webpack_require__(99);\n\nvar _utilsIsPlainObject2 = _interopRequireDefault(_utilsIsPlainObject);\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = {\n  INIT: '@@redux/INIT'\n};\n\nexports.ActionTypes = ActionTypes;\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [initialState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, initialState) {\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = initialState;\n  var listeners = [];\n  var isDispatching = false;\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    listeners.push(listener);\n\n    return function unsubscribe() {\n      var index = listeners.indexOf(listener);\n      listeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!_utilsIsPlainObject2['default'](action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    listeners.slice().forEach(function (listener) {\n      return listener();\n    });\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  };\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/createStore.js\n ** module id = 96\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/createStore.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nexports.__esModule = true;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _createStore = __webpack_require__(96);\n\nvar _createStore2 = _interopRequireDefault(_createStore);\n\nvar _utilsCombineReducers = __webpack_require__(195);\n\nvar _utilsCombineReducers2 = _interopRequireDefault(_utilsCombineReducers);\n\nvar _utilsBindActionCreators = __webpack_require__(194);\n\nvar _utilsBindActionCreators2 = _interopRequireDefault(_utilsBindActionCreators);\n\nvar _utilsApplyMiddleware = __webpack_require__(193);\n\nvar _utilsApplyMiddleware2 = _interopRequireDefault(_utilsApplyMiddleware);\n\nvar _utilsCompose = __webpack_require__(98);\n\nvar _utilsCompose2 = _interopRequireDefault(_utilsCompose);\n\nexports.createStore = _createStore2['default'];\nexports.combineReducers = _utilsCombineReducers2['default'];\nexports.bindActionCreators = _utilsBindActionCreators2['default'];\nexports.applyMiddleware = _utilsApplyMiddleware2['default'];\nexports.compose = _utilsCompose2['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/index.js\n ** module id = 97\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/index.js?")},function(module,exports){eval('/**\n * Composes single-argument functions from right to left.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing functions from right to\n * left. For example, compose(f, g, h) is identical to arg => f(g(h(arg))).\n */\n"use strict";\n\nexports.__esModule = true;\nexports["default"] = compose;\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  return function (arg) {\n    return funcs.reduceRight(function (composed, f) {\n      return f(composed);\n    }, arg);\n  };\n}\n\nmodule.exports = exports["default"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/compose.js\n ** module id = 98\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/compose.js?')},function(module,exports){eval("'use strict';\n\nexports.__esModule = true;\nexports['default'] = isPlainObject;\nvar fnToString = function fnToString(fn) {\n  return Function.prototype.toString.call(fn);\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\n\nfunction isPlainObject(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  var proto = typeof obj.constructor === 'function' ? Object.getPrototypeOf(obj) : Object.prototype;\n\n  if (proto === null) {\n    return true;\n  }\n\n  var constructor = proto.constructor;\n\n  return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === fnToString(Object);\n}\n\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/isPlainObject.js\n ** module id = 99\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/isPlainObject.js?")},function(module,exports){eval('/**\n * Applies a function to every key-value pair inside an object.\n *\n * @param {Object} obj The source object.\n * @param {Function} fn The mapper function that receives the value and the key.\n * @returns {Object} A new object that contains the mapped values for the keys.\n */\n"use strict";\n\nexports.__esModule = true;\nexports["default"] = mapValues;\n\nfunction mapValues(obj, fn) {\n  return Object.keys(obj).reduce(function (result, key) {\n    result[key] = fn(obj[key], key);\n    return result;\n  }, {});\n}\n\nmodule.exports = exports["default"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/mapValues.js\n ** module id = 100\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/mapValues.js?')},function(module,exports){eval('module.exports = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNDgwIDYwIj48c3R5bGU+LnN0MHtmaWxsOiM5ODk3OTg7fSAuc3Qxe2ZpbGw6IzI5QUFFMTt9IC5zdDJ7ZmlsbDpub25lO3N0cm9rZTojMjlBQUUxO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDt9IC5zdDN7ZmlsbDpub25lO3N0cm9rZTojMjlBQUUxO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5OjEuODgyOSw0LjcwNzM7fSAuc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzI5QUFFMTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheToxLjI1OTMsMy4xNDgyO30gLnN0NXtmaWxsOm5vbmU7c3Ryb2tlOiMyOUFBRTE7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6MS44OTc2LDQuNzQ0MTt9IC5zdDZ7ZmlsbDpub25lO3N0cm9rZTojMjlBQUUxO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5OjEuOTE0OCw0Ljc4Nzt9IC5zdDd7ZmlsbDpub25lO3N0cm9rZTojMjlBQUUxO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5OjEuOTg4MSw0Ljk3MDE7fSAuc3Q4e2ZpbGw6I0E1QTVBNTt9PC9zdHlsZT48cGF0aCBjbGFzcz0ic3QwIiBkPSJNNTUgNTIuNEw0MC42IDM4YzIuOS0zLjUgNC42LTggNC42LTEyLjhDNDUuMiAxNCAzNi4yIDUgMjUuMSA1IDE0IDUgNSAxNCA1IDI1LjFjMCAxMS4xIDkgMjAuMSAyMC4xIDIwLjEgNC45IDAgOS40LTEuNyAxMi44LTQuNkw1Mi40IDU1bDIuNi0yLjZ6TTcuMSAyNS4xYzAtOS45IDguMS0xOCAxOC0xOHMxOCA4LjEgMTggMTgtOC4xIDE4LTE4IDE4LTE4LTguMS0xOC0xOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE1IDUyLjRMMTAwLjYgMzhjMi45LTMuNSA0LjYtOCA0LjYtMTIuOEMxMDUuMiAxNCA5Ni4yIDUgODUuMSA1IDc0IDUgNjUgMTQgNjUgMjUuMWMwIDExLjEgOSAyMC4xIDIwLjEgMjAuMSA0LjkgMCA5LjQtMS43IDEyLjgtNC42TDExMi40IDU1bDIuNi0yLjZ6TTY3LjEgMjUuMWMwLTkuOSA4LjEtMTggMTgtMThzMTggOC4xIDE4IDE4LTguMSAxOC0xOCAxOC0xOC04LjEtMTgtMTh6TTEzMi4xIDdjLTQuMiAwLTcuNiAzLjQtNy42IDcuNiAwIDEuNC40IDIuNyAxIDMuOGw2LjYgMTEuMyA2LjUtMTEuM2MuNi0xLjEgMS0yLjQgMS0zLjggMC00LjItMy4zLTcuNi03LjUtNy42em0wIDkuOGMtMS4zIDAtMi4zLTEtMi4zLTIuMyAwLTEuMyAxLTIuMyAyLjMtMi4zIDEuMyAwIDIuMyAxIDIuMyAyLjMgMCAxLjMtMS4xIDIuMy0yLjMgMi4zek0xNjcuOSAzMC4zYy00LjIgMC03LjYgMy40LTcuNiA3LjYgMCAxLjQuNCAyLjcgMSAzLjhsNi41IDExLjMgNi42LTExLjNjLjYtMS4xIDEtMi40IDEtMy44LjEtNC4yLTMuMy03LjYtNy41LTcuNnptMCA5LjhjLTEuMyAwLTIuMy0xLTIuMy0yLjMgMC0xLjMgMS0yLjMgMi4zLTIuMyAxLjMgMCAyLjMgMSAyLjMgMi4zIDAgMS4zLTEgMi4zLTIuMyAyLjN6Ii8+PHBhdGggaWQ9IlhNTElEXzE1XyIgY2xhc3M9InN0MiIgZD0iTTEzMi42IDI4LjRoMSIvPjxwYXRoIGlkPSJYTUxJRF8xNF8iIGNsYXNzPSJzdDMiIGQ9Ik0xMzguNCAyOC40aDEwLjgiLz48cGF0aCBpZD0iWE1MSURfMTNfIiBjbGFzcz0ic3QyIiBkPSJNMTUxLjUgMjguNGgxdjEiLz48cGF0aCBpZD0iWE1MSURfMTJfIiBjbGFzcz0ic3Q0IiBkPSJNMTUyLjUgMzIuNnYyLjgiLz48cGF0aCBpZD0iWE1MSURfMTFfIiBjbGFzcz0ic3QyIiBkPSJNMTUyLjUgMzd2MWgtMSIvPjxwYXRoIGlkPSJYTUxJRF8xMF8iIGNsYXNzPSJzdDUiIGQ9Ik0xNDYuOCAzOGgtNC4zIi8+PHBhdGggaWQ9IlhNTElEXzlfIiBjbGFzcz0ic3QyIiBkPSJNMTQwLjEgMzhoLTF2MSIvPjxwYXRoIGlkPSJYTUxJRF84XyIgY2xhc3M9InN0NiIgZD0iTTEzOS4xIDQzLjh2NC4zIi8+PHBhdGggaWQ9IlhNTElEXzdfIiBjbGFzcz0ic3QyIiBkPSJNMTM5LjEgNTAuNXYxaDEiLz48cGF0aCBpZD0iWE1MSURfNl8iIGNsYXNzPSJzdDciIGQ9Ik0xNDUuMSA1MS41aDE4LjQiLz48cGF0aCBpZD0iWE1MSURfNV8iIGNsYXNzPSJzdDIiIGQ9Ik0xNjYgNTEuNWgxIi8+PHBhdGggY2xhc3M9InN0MCIgZD0iTTIwNiAzNC42bDYuMSAyMC40TDIzNSA1bC01MCAyNCAyMSA1LjZ6bTYuNyAxNC41bC00LjYtMTYuNi0xNi44LTQuMyAzOS42LTE4LjktMTguMiAzOS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yNjYgMzQuNmw2LjEgMjAuNEwyOTUgNWwtNTAgMjQgMjEgNS42em02LjcgMTQuNWwtNC42LTE2LjYtMTYuOC00LjMgMzkuNi0xOC45LTE4LjIgMzkuOHoiLz48ZyBpZD0iWE1MSURfMjRfIj48cGF0aCBpZD0iWE1MSURfMjZfIiBjbGFzcz0ic3QxIiBkPSJNMzUzLjQ3OCA1NS4wMjZMMzA0Ljk3IDYuNTJsMS40ODYtMS40ODYgNDguNTA3IDQ4LjUwN3oiLz48cGF0aCBpZD0iWE1MSURfMjVfIiBjbGFzcz0ic3QxIiBkPSJNMzA0Ljk2NiA1My40OEwzNTMuNDc0IDQuOTdsMS40ODQgMS40ODUtNDguNTA3IDQ4LjUwN3oiLz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTM5MCA1Yy05LjIgMC0xNi43IDcuNS0xNi43IDE2LjcgMCAzIC44IDUuOSAyLjIgOC4zTDM5MCA1NWwxNC40LTI1YzEuNC0yLjUgMi4yLTUuMyAyLjItOC4zLjEtOS4yLTcuNC0xNi43LTE2LjYtMTYuN3ptMCAyMS43Yy0yLjggMC01LTIuMi01LTVzMi4yLTUgNS01IDUgMi4yIDUgNWMwIDIuNy0yLjIgNS01IDV6Ii8+PHBhdGggY2xhc3M9InN0OCIgZD0iTTQ2My45IDkuMmMtMy42LTIuNC03LjctMy44LTEyLjEtNC4xLS4yIDAtLjMgMC0uNS0uMWgtMi41bC0uOC4xYy0uNS4xLTEgLjEtMS41LjItNy4yIDEuMS0xMyA0LjgtMTcuMiAxMC45LTIuNCAzLjYtMy44IDcuNy00LjEgMTIuMSAwIC4xIDAgLjMtLjEuNXYyLjVsLjEuN2MuMS41LjEgMS4xLjIgMS42IDEuMiA3LjggNS4zIDEzLjggMTIgMTcuOSA0IDIuNSA4LjYgMy42IDEzLjUgMy41IDExLjgtLjQgMjEuNS04LjcgMjMuNy0yMC4yLjEtLjYuMi0xLjMuMy0yIDAtLjMuMS0uNy4xLTEgMC0uMSAwLS4zLjEtLjR2LTIuNmwtLjEtLjhjLS4xLS41LS4xLTEtLjItMS41LTEuMi03LjMtNC45LTEzLjEtMTAuOS0xNy4zem0tNi45LTFjNC44IDEuNSA4LjYgNC4zIDExLjcgOC42bC43LjktNy41IDMuNS0uMy0xYy0xLjMtMy45LTMuMS03LjMtNS42LTEwLjVsLTItMi41IDMgMXptMy43IDI3LjJsLS4yIDEtMS0uMmMtNi4zLTEuNS0xMi42LTEuNS0xOC45IDBsLS45LjItLjMtLjhjLS44LTIuMi0uOC04LjggMC0xMS4xbC4zLS45LjkuMmM2LjMgMS41IDEyLjYgMS42IDE4LjkgMGwxLS4yLjIgMWMuNiAzLjYuNiA3LjEgMCAxMC44ek00NDguMyA4LjJjLjQtLjMuOS0uOCAxLjctLjguNyAwIDEuMy40IDEuNy44IDMuNiAzLjMgNi4yIDcuNCA3LjkgMTIuMSAwIC4xLjEuMi4xLjNsLjMgMS4yLTEgLjJjLTIuOS43LTUuOSAxLjEtOC44IDEuMS0zIDAtNi4xLS40LTkuMS0xLjFsLTEuMS0uMy40LTFjLjEtLjQuMy0uNy40LTEuMS4zLS44LjYtMS42IDEtMi4zIDEuNS0zLjYgMy44LTYuNiA2LjUtOS4xem0tMTcgOC40YzMuMS00LjIgNi45LTYuOSAxMS42LTguNGwzLTEtMiAyLjVjLTIuNSAzLjItNC40IDYuNi01LjYgMTAuNGwtLjMgMS03LjQtMy42LjctLjl6bS0yLjEgMjMuMmMtMi45LTYuNS0yLjktMTMgMC0xOS41bC40LS45IDggMy44LS4xLjdjLS44IDQuMS0uOCA4LjIgMCAxMi4zbC4xLjctOCAzLjgtLjQtLjl6bTEzLjggMTJjLTQuNy0xLjUtOC41LTQuMy0xMS42LTguNGwtLjctLjkgMS4xLS41YzEuNS0uNyAyLjktMS40IDQuMy0yLjFsMi0xIC4zIDFjMS4zIDMuOCAzLjEgNy4yIDUuNiAxMC40bDIgMi41LTMtMXptOC43IDBjLS40LjMtLjkuOC0xLjcuOC0uOCAwLTEuMy0uNC0xLjctLjgtMy42LTMuMy02LjItNy4zLTcuOC0xMiAwLS4xLS4xLS4yLS4xLS4zbC0uMi0uOC43LS41YzIuNS0xLjEgNy43LTEuMiA5LjMtMS4yIDEuNSAwIDYuNi4xIDguOSAxLjJsLjguNC0uMy44Yy0uNiAxLjgtMS4zIDMuNS0yLjMgNS4yLTEuNCAyLjctMy40IDUuMi01LjYgNy4yem0xNy4xLTguNWMtMy4xIDQuMi02LjkgNy0xMS43IDguNmwtMy4xIDEgMi0yLjVjMi41LTMuMiA0LjQtNi42IDUuNy0xMC41bC4zLTEgMSAuNWMxLjguOSAzLjYgMS43IDUuNCAyLjVsMS4xLjUtLjcuOXptMi0zLjZsLS41LjctLjgtLjRjLTEuMi0uNS0yLjMtMS4xLTMuNS0xLjZsLTMuNi0xLjcuMS0uN2MuOC00IC44LTguMSAwLTEyLjFsLS4xLS43IDcuOC0zLjYuNS42YzMgMy44IDMgMTQuNy4xIDE5LjV6Ii8+PC9zdmc+"\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scss/resources/icons.svg\n ** module id = 101\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scss/resources/icons.svg?')},function(module,exports){eval("module.exports = function(module) {\r\n	if(!module.webpackPolyfill) {\r\n		module.deprecate = function() {};\r\n		module.paths = [];\r\n		// module.parent = undefined by default\r\n		module.children = [];\r\n		module.webpackPolyfill = 1;\r\n	}\r\n	return module;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 102\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?")},function(module,exports){eval("module.exports = ansiHTML;\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar re_ansi = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/;\n\nvar _defColors = {\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n};\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n};\nvar _openTags = {\n  '1': 'font-weight:bold', // bold\n  '2': 'opacity:0.8', // dim\n  '3': '<i>', // italic\n  '4': '<u>', // underscore\n  '8': 'display:none', // hidden\n  '9': '<del>', // delete\n};\nvar _closeTags = {\n  '23': '</i>', // reset italic\n  '24': '</u>', // reset underscore\n  '29': '</del>' // reset delete\n};\n[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>';\n});\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML(text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!re_ansi.test(text)) {\n    return text;\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = [];\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)*m/g, function (match, seq) {\n    var ot = _openTags[seq];\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) {\n        ansiCodes.pop();\n        return '</span>';\n      }\n      // Open tag.\n      ansiCodes.push(seq);\n      return ot[0] == '<' ? ot : '<span style=\"' + ot + ';\">';\n    }\n\n    var ct = _closeTags[seq];\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop();\n      return ct;\n    }\n    return '';\n  });\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length;\n  (l > 0) && (ret += Array(l + 1).join('</span>'));\n\n  return ret;\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors != 'object') {\n    throw new Error('`colors` parameter must be an Object.');\n  }\n\n  var _finalColors = {};\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null;\n    if (!hex) {\n      _finalColors[key] = _defColors[key];\n      continue;\n    }\n    if ('reset' == key) {\n    	if(typeof hex == 'string'){\n    		hex = [hex];\n    	}\n      if (!Array.isArray(hex) || hex.length == 0 || hex.some(function (h) {\n          return typeof h != 'string';\n        })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');\n      }\n      var defHexColor = _defColors[key];\n      if(!hex[0]){\n      	hex[0] = defHexColor[0];\n      }\n      if (hex.length == 1 || !hex[1]) {\n      	hex = [hex[0]];\n        hex.push(defHexColor[1]);\n      }\n\n      hex = hex.slice(0, 2);\n    } else if (typeof hex != 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');\n    }\n    _finalColors[key] = hex;\n  }\n  _setTags(_finalColors);\n};\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function(){\n	_setTags(_defColors);\n};\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {\n  get open() {\n    return _openTags;\n  },\n  get close() {\n    return _closeTags;\n  }\n};\n\nfunction _setTags(colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey;\n\n  for (var code in _styles) {\n    var color = _styles[code];\n    var oriColor = colors[color] || '000';\n    _openTags[code] = 'color:#' + oriColor;\n    code = parseInt(code);\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor;\n  }\n}\n\nansiHTML.reset();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ansi-html/index.js\n ** module id = 103\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/ansi-html/index.js?")},function(module,exports){eval("'use strict';\nmodule.exports = function () {\n	return /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ansi-regex/index.js\n ** module id = 104\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/ansi-regex/index.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(135);\n\nvar _Keys = __webpack_require__(35);\n\nvar _Keys2 = _interopRequireDefault(_Keys);\n\nvar _ComponentsSearchCancelButton = __webpack_require__(107);\n\nvar _ComponentsSearchCancelButton2 = _interopRequireDefault(_ComponentsSearchCancelButton);\n\nvar _ComponentsSearchSearchBox = __webpack_require__(109);\n\nvar _ComponentsSearchSearchBox2 = _interopRequireDefault(_ComponentsSearchSearchBox);\n\nvar _ComponentsLonLatInputLonLatInput = __webpack_require__(106);\n\nvar _ComponentsLonLatInputLonLatInput2 = _interopRequireDefault(_ComponentsLonLatInputLonLatInput);\n\nvar _ComponentsTileExporterExporter = __webpack_require__(112);\n\nvar _ComponentsTileExporterExporter2 = _interopRequireDefault(_ComponentsTileExporterExporter);\n\n__webpack_require__(199);\n\n_ComponentsTileExporterExporter2['default'].initScene();\n_ComponentsTileExporterExporter2['default'].attachEvents();\n\nvar SearchBoxWrapper = (function (_Component) {\n  _inherits(SearchBoxWrapper, _Component);\n\n  function SearchBoxWrapper() {\n    _classCallCheck(this, SearchBoxWrapper);\n\n    _get(Object.getPrototypeOf(SearchBoxWrapper.prototype), 'constructor', this).apply(this, arguments);\n  }\n\n  _createClass(SearchBoxWrapper, [{\n    key: 'render',\n    value: function render() {\n\n      var searchConfig = {\n        placeholder: 'Search address or or place',\n        childClass: 'searchBox',\n        key: _Keys2['default'].search\n      };\n      return _react2['default'].createElement(\n        'div',\n        { className: 'row' },\n        _react2['default'].createElement(\n          'div',\n          { className: 'col-md-12' },\n          _react2['default'].createElement(_ComponentsSearchSearchBox2['default'], {\n            config: searchConfig })\n        )\n      );\n    }\n  }]);\n\n  return SearchBoxWrapper;\n})(_react.Component);\n\n(0, _reactDom.render)(_react2['default'].createElement(SearchBoxWrapper, null), document.getElementById('search-bar'));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/App.js\n ** module id = 105\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/App.js?");
},function(module,exports,__webpack_require__){eval('"use strict";\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar LonLatInput = _react2["default"].createClass({\n  displayName: "LonLatInput",\n\n  getInitialState: function getInitialState() {\n    return {\n      searchResult: [],\n      dataIndex: -1,\n      filterText: this.props.label || ""\n    };\n  },\n\n  componentDidMount: function componentDidMount() {\n    this.refs.latInput.focus();\n  },\n\n  handleChange: function handleChange(event) {\n    console.log(event);\n    // var currentType = this.refs.lonInput.value;\n    // if(currentType.length > 0) {\n    //   var matchingVals = [];\n    //   this.setState({\n    //       filterText : currentType\n    //     },this.makeCall());\n    //   } else {\n    //     this.setState({\n    //       searchResult: [],\n    //       filterText : ""\n    //     })\n    // }\n  },\n\n  setInputValue: function setInputValue(val) {\n    this.setState({\n      filterText: val\n    });\n  },\n\n  render: function render() {\n\n    return _react2["default"].createElement(\n      "div",\n      null,\n      _react2["default"].createElement(\n        "div",\n        { className: "form-group" },\n        _react2["default"].createElement(\n          "label",\n          { "for": "lon" },\n          "Longitude"\n        ),\n        _react2["default"].createElement("input", { type: "text",\n          className: "form-control",\n          id: "lon",\n          placeholder: "-74.0059700",\n          ref: "lonInput",\n          disabled: "true" })\n      ),\n      _react2["default"].createElement(\n        "div",\n        { className: "form-group" },\n        _react2["default"].createElement(\n          "label",\n          { "for": "lat" },\n          "Latitude"\n        ),\n        _react2["default"].createElement("input", { type: "text",\n          className: "form-control",\n          id: "lat",\n          placeholder: "40.7142700",\n          ref: "latInput",\n          disabled: "true" })\n      )\n    );\n  }\n});\n\nmodule.exports = LonLatInput;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/LonLatInput/LonLatInput.js\n ** module id = 106\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/LonLatInput/LonLatInput.js?')},function(module,exports,__webpack_require__){eval('"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar CancelButton = (function (_Component) {\n  _inherits(CancelButton, _Component);\n\n  function CancelButton() {\n    _classCallCheck(this, CancelButton);\n\n    _get(Object.getPrototypeOf(CancelButton.prototype), "constructor", this).apply(this, arguments);\n  }\n\n  _createClass(CancelButton, [{\n    key: "render",\n    value: function render() {\n      return _react2["default"].createElement(\n        "div",\n        { id: "cancelButton", onClick: this.clear },\n        " hello "\n      );\n    }\n  }]);\n\n  return CancelButton;\n})(_react.Component);\n\nexports["default"] = CancelButton;\nmodule.exports = exports["default"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/Search/CancelButton.js\n ** module id = 107\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/Search/CancelButton.js?')},function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _ResultRow = __webpack_require__(60);\n\nvar _ResultRow2 = _interopRequireDefault(_ResultRow);\n\nvar _SearchTermRow = __webpack_require__(110);\n\nvar _SearchTermRow2 = _interopRequireDefault(_SearchTermRow);\n\nvar ResultTable = (function (_Component) {\n  _inherits(ResultTable, _Component);\n\n  function ResultTable() {\n    _classCallCheck(this, ResultTable);\n\n    _get(Object.getPrototypeOf(ResultTable.prototype), 'constructor', this).apply(this, arguments);\n  }\n\n  _createClass(ResultTable, [{\n    key: 'render',\n\n    //turning off poi search for now  Dec, 2015\n\n    value: function render() {\n\n      var rows = [];\n      var rowIndex = 0;\n\n      var _props = this.props;\n      var searchData = _props.searchData;\n      var dataIndex = _props.dataIndex;\n      var pointAction = _props.pointAction;\n\n      searchData.forEach(function (result) {\n        rows.push(_react2['default'].createElement(_ResultRow2['default'], { data: result,\n          key: result.properties.gid,\n          rowIndex: rowIndex,\n          dataIndex: dataIndex,\n          pointAction: pointAction }));\n        rowIndex++;\n      });\n\n      return _react2['default'].createElement(\n        'ul',\n        { className: 'table-view search-table' },\n        rows\n      );\n    }\n  }]);\n\n  return ResultTable;\n})(_react.Component);\n\nexports['default'] = ResultTable;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/Search/ResultTable.js\n ** module id = 108\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/Search/ResultTable.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _react = __webpack_require__(18);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _lodash = __webpack_require__(134);\n\nvar _ResultRow = __webpack_require__(60);\n\nvar _ResultRow2 = _interopRequireDefault(_ResultRow);\n\nvar _ResultTable = __webpack_require__(108);\n\nvar _ResultTable2 = _interopRequireDefault(_ResultTable);\n\nvar _ReduxStore = __webpack_require__(38);\n\nvar _ReduxStore2 = _interopRequireDefault(_ReduxStore);\n\nvar _ReduxAction = __webpack_require__(36);\n\nvar SearchBox = _react2['default'].createClass({\n  displayName: 'SearchBox',\n\n  makeAutoCompleteCall: function makeAutoCompleteCall(currentInput) {\n    var _this = this;\n\n    var baseurl = 'https://search.mapzen.com/v1';\n\n    var callurl = baseurl + '/autocomplete' + '?text=' + currentInput;\n    callurl += '&api_key=' + this.props.config.key;\n\n    var request = new XMLHttpRequest();\n    request.open('GET', callurl, true);\n    request.onload = function () {\n      if (request.status >= 200 && request.status < 400) {\n        // Success!\n        var resp = JSON.parse(request.responseText);\n        _this.setState({ searchResult: resp.features });\n      } else {\n        // when there is no search result?\n      }\n    };\n\n    request.onerror = function () {\n      // when there is no search result / error?\n    };\n\n    request.send();\n  },\n\n  makeSearchCall: function makeSearchCall() {\n    var _this2 = this;\n\n    var baseurl = 'https://search.mapzen.com/v1';\n\n    var callurl = baseurl + '/search' + '?text=' + this.state.filterText;\n    callurl += '&api_key=' + this.props.config.key;\n\n    var request = new XMLHttpRequest();\n    request.open('GET', callurl, true);\n    request.onload = function () {\n      if (request.status >= 200 && request.status < 400) {\n        // Success!\n        var resp = JSON.parse(request.responseText);\n        _this2.setState({ searchResult: resp.features });\n      } else {\n        // when there is no search result?\n      }\n    };\n\n    request.onerror = function () {\n      // when there is no search result / error?\n    };\n    request.send();\n  },\n\n  componentWillMount: function componentWillMount() {\n    //make search call debounce\n    this.makeCall = (0, _lodash.debounce)(function () {\n      this.makeAutoCompleteCall.apply(this, [this.state.filterText]);\n    }, 250);\n  },\n\n  getInitialState: function getInitialState() {\n    return {\n      searchResult: [],\n      dataIndex: -1,\n      filterText: this.props.label || \"\",\n      endpoint: 'autocomplete'\n    };\n  },\n\n  componentDidMount: function componentDidMount() {\n    this.refs.searchInput.focus();\n  },\n\n  handleKeyDown: function handleKeyDown(event) {\n    var key = event.which || event.keyCode;\n    var self = this;\n\n    var currentDataIndex = this.state.dataIndex;\n\n    switch (key) {\n      case 13:\n        if (currentDataIndex !== -1) {\n          var data = self.state.searchResult[currentDataIndex];\n          self.pointAction(data);\n        } else {\n          self.makeSearchCall();\n        }\n      case 38:\n        currentDataIndex--;\n        currentDataIndex += self.state.searchResult.length;\n        currentDataIndex %= self.state.searchResult.length;\n        break;\n      case 40:\n        currentDataIndex++;\n        currentDataIndex %= self.state.searchResult.length;\n        break;\n    }\n\n    this.setState({\n      dataIndex: currentDataIndex\n    });\n\n    event.stopPropagation();\n  },\n\n  pointAction: function pointAction(data) {\n\n    var selectedPoint = {\n      name: data.properties.label,\n      gid: data.properties.gid,\n      lat: data.geometry.coordinates[1],\n      lon: data.geometry.coordinates[0]\n    };\n\n    var latLon = {\n      lat: selectedPoint.lat,\n      lon: selectedPoint.lon\n    };\n\n    _ReduxStore2['default'].dispatch((0, _ReduxAction.updatePoint)(latLon));\n\n    this.setInputValue(selectedPoint.name);\n    this.setState({\n      dataIndex: -1\n    });\n\n    document.getElementById('exportBtn').disabled = false;\n    document.getElementById('lon').innerHTML = latLon.lon;\n    document.getElementById('lat').innerHTML = latLon.lat;\n  },\n\n  handleChange: function handleChange() {\n\n    var currentType = this.refs.searchInput.value;\n    if (currentType.length > 0) {\n      var matchingVals = [];\n      this.setState({\n        filterText: currentType\n      }, this.makeCall());\n    } else {\n      this.setState({\n        searchResult: [],\n        filterText: \"\",\n        dataIndex: -1\n      });\n    }\n  },\n\n  setInputValue: function setInputValue(val) {\n    this.setState({\n      filterText: val\n    }, function () {\n      this.deactivateSearching();\n    });\n  },\n\n  deactivateSearching: function deactivateSearching() {\n    this.setState({\n      searchTerm: [],\n      searchResult: []\n    });\n  },\n\n  render: function render() {\n    var config = this.props.config;\n    var _state = this.state;\n    var searchResult = _state.searchResult;\n    var dataIndex = _state.dataIndex;\n\n    return _react2['default'].createElement(\n      'div',\n      { 'class': 'searchBoxContainer' },\n      _react2['default'].createElement('div', {\n        className: 'search-icon' }),\n      _react2['default'].createElement('input', {\n        className: 'form-control search-bar',\n        placeholder: config.placeholder,\n        ref: 'searchInput',\n        type: 'search',\n        value: this.state.filterText,\n        onChange: this.handleChange,\n        onKeyDown: this.handleKeyDown }),\n      _react2['default'].createElement(_ResultTable2['default'], { searchData: searchResult,\n        dataIndex: dataIndex,\n        centerPoint: config.focusPoint,\n        pointAction: this.pointAction })\n    );\n  }\n});\n\n////here all maps spells are!\n//convert lat/lon to mercator style number\nfunction long2tile(lon, zoom) {\n  return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));\n}\nfunction lat2tile(lat, zoom) {\n  return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));\n}\n\nmodule.exports = SearchBox;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/Search/SearchBox.js\n ** module id = 109\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/Search/SearchBox.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar React = __webpack_require__(18);\n\nvar SearchTermRow = React.createClass({\n  displayName: 'SearchTermRow',\n\n  handleClick: function handleClick() {\n\n    //This category search doesn't work currently\n    var locationArr = [];\n\n    var baseurl = 'https://search.mapzen.com/v1';\n    var point = this.props.centerPoint;\n\n    var callurl = baseurl + \"/reverse?lat=\" + point.lat + \"&lon=\" + point.lon + \"&categories= \" + this.props.searchTerm;\n\n    var request = new XMLHttpRequest();\n    request.open('GET', callurl, true);\n    request.onload = function () {\n      if (request.status >= 200 && request.status < 400) {\n        // Success!\n        var data = JSON.parse(request.responseText);\n        data.features.forEach(function (datum) {\n          locationArr.push({\n            name: datum.properties.text,\n            lat: datum.geometry.coordinates[1],\n            lon: datum.geometry.coordinates[0]\n          });\n          self.props.addPOIMarkers(locationArr);\n        });\n        self.props.setInputValue(self.props.searchTerm);\n        self.props.deactivateSearching();\n      } else {\n        // when there is no search result?\n      }\n    };\n\n    request.onerror = function () {\n      // when there is no search result / error?\n    };\n\n    request.send();\n  },\n\n  render: function render() {\n\n    return React.createElement(\n      'li',\n      { className: 'table-view-cell serch-term-result',\n        onClick: this.handleClick },\n      ' ',\n      this.props.searchTerm,\n      ' '\n    );\n  }\n});\nmodule.exports = SearchTermRow;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/Search/SearchTermRow.js\n ** module id = 110\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/Search/SearchTermRow.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _d3 = __webpack_require__(40);\n\nvar _d32 = _interopRequireDefault(_d3);\n\nvar _three = __webpack_require__(34);\n\nvar _three2 = _interopRequireDefault(_three);\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nfunction d3threeD(exports) {\n\n    var DEGS_TO_RADS = Math.PI / 180,\n        UNIT_SIZE = 1;\n\n    var DIGIT_0 = 48,\n        DIGIT_9 = 57,\n        COMMA = 44,\n        SPACE = 32,\n        PERIOD = 46,\n        MINUS = 45;\n\n    function transformSVGPath(pathStr) {\n\n        var paths = [];\n        var path = new _three2['default'].Shape();\n\n        var idx = 1,\n            len = pathStr.length,\n            activeCmd,\n            x = 0,\n            y = 0,\n            nx = 0,\n            ny = 0,\n            firstX = null,\n            firstY = null,\n            x1 = 0,\n            x2 = 0,\n            y1 = 0,\n            y2 = 0,\n            rx = 0,\n            ry = 0,\n            xar = 0,\n            laf = 0,\n            sf = 0,\n            cx,\n            cy;\n\n        function eatNum() {\n            var sidx,\n                c,\n                isFloat = false,\n                s;\n            // eat delims\n            while (idx < len) {\n                c = pathStr.charCodeAt(idx);\n                if (c !== COMMA && c !== SPACE) break;\n                idx++;\n            }\n            if (c === MINUS) sidx = idx++;else sidx = idx;\n            // eat number\n            while (idx < len) {\n                c = pathStr.charCodeAt(idx);\n                if (DIGIT_0 <= c && c <= DIGIT_9) {\n                    idx++;\n                    continue;\n                } else if (c === PERIOD) {\n                    idx++;\n                    isFloat = true;\n                    continue;\n                }\n\n                s = pathStr.substring(sidx, idx);\n                return isFloat ? parseFloat(s) : parseInt(s);\n            }\n\n            s = pathStr.substring(sidx);\n            return isFloat ? parseFloat(s) : parseInt(s);\n        }\n\n        function nextIsNum() {\n            var c;\n            // do permanently eat any delims...\n            while (idx < len) {\n                c = pathStr.charCodeAt(idx);\n                if (c !== COMMA && c !== SPACE) break;\n                idx++;\n            }\n            c = pathStr.charCodeAt(idx);\n            return c === MINUS || DIGIT_0 <= c && c <= DIGIT_9;\n        }\n\n        var canRepeat;\n        var enteredSub = false;\n        var zSeen = false;\n        activeCmd = pathStr[0];\n\n        while (idx <= len) {\n            canRepeat = true;\n            switch (activeCmd) {\n                // moveto commands, become lineto's if repeated\n                case 'M':\n                    enteredSub = false;\n                    x = eatNum();\n                    y = eatNum();\n                    path.moveTo(x, y);\n                    activeCmd = 'L';\n                    break;\n                case 'm':\n                    x += eatNum();\n                    y += eatNum();\n                    path.moveTo(x, y);\n                    activeCmd = 'l';\n                    break;\n                case 'Z':\n                case 'z':\n                    // z is a special case. This ends a segment and starts\n                    // a new path. Since the three.js path is continuous\n                    // we should start a new path here. This also draws a\n                    // line from the current location to the start location.\n                    canRepeat = false;\n                    if (x !== firstX || y !== firstY) path.lineTo(firstX, firstY);\n\n                    paths.push(path);\n\n                    // reset the elements\n                    firstX = null;\n                    firstY = null;\n\n                    // avoid x,y being set incorrectly\n                    enteredSub = true;\n\n                    path = new _three2['default'].Shape();\n\n                    zSeen = true;\n\n                    break;\n                // - lines!\n                case 'L':\n                case 'H':\n                case 'V':\n                    nx = activeCmd === 'V' ? x : eatNum();\n                    ny = activeCmd === 'H' ? y : eatNum();\n                    path.lineTo(nx, ny);\n                    x = nx;\n                    y = ny;\n                    break;\n                case 'l':\n                case 'h':\n                case 'v':\n                    nx = activeCmd === 'v' ? x : x + eatNum();\n                    ny = activeCmd === 'h' ? y : y + eatNum();\n                    path.lineTo(nx, ny);\n                    x = nx;\n                    y = ny;\n                    break;\n                // - cubic bezier\n                case 'C':\n                    x1 = eatNum();y1 = eatNum();\n                case 'S':\n                    if (activeCmd === 'S') {\n                        x1 = 2 * x - x2;y1 = 2 * y - y2;\n                    }\n                    x2 = eatNum();\n                    y2 = eatNum();\n                    nx = eatNum();\n                    ny = eatNum();\n                    path.bezierCurveTo(x1, y1, x2, y2, nx, ny);\n                    x = nx;y = ny;\n                    break;\n                case 'c':\n                    x1 = x + eatNum();\n                    y1 = y + eatNum();\n                case 's':\n                    if (activeCmd === 's') {\n                        x1 = 2 * x - x2;\n                        y1 = 2 * y - y2;\n                    }\n                    x2 = x + eatNum();\n                    y2 = y + eatNum();\n                    nx = x + eatNum();\n                    ny = y + eatNum();\n                    path.bezierCurveTo(x1, y1, x2, y2, nx, ny);\n                    x = nx;y = ny;\n                    break;\n                // - quadratic bezier\n                case 'Q':\n                    x1 = eatNum();y1 = eatNum();\n                case 'T':\n                    if (activeCmd === 'T') {\n                        x1 = 2 * x - x1;\n                        y1 = 2 * y - y1;\n                    }\n                    nx = eatNum();\n                    ny = eatNum();\n                    path.quadraticCurveTo(x1, y1, nx, ny);\n                    x = nx;\n                    y = ny;\n                    break;\n                case 'q':\n                    x1 = x + eatNum();\n                    y1 = y + eatNum();\n                case 't':\n                    if (activeCmd === 't') {\n                        x1 = 2 * x - x1;\n                        y1 = 2 * y - y1;\n                    }\n                    nx = x + eatNum();\n                    ny = y + eatNum();\n                    path.quadraticCurveTo(x1, y1, nx, ny);\n                    x = nx;y = ny;\n                    break;\n                // - elliptical arc\n                case 'A':\n                    rx = eatNum();\n                    ry = eatNum();\n                    xar = eatNum() * DEGS_TO_RADS;\n                    laf = eatNum();\n                    sf = eatNum();\n                    nx = eatNum();\n                    ny = eatNum();\n                    if (rx !== ry) {\n                        console.warn(\"Forcing elliptical arc to be a circular one :(\", rx, ry);\n                    }\n                    // SVG implementation notes does all the math for us! woo!\n                    // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                    // step1, using x1 as x1'\n                    x1 = Math.cos(xar) * (x - nx) / 2 + Math.sin(xar) * (y - ny) / 2;\n                    y1 = -Math.sin(xar) * (x - nx) / 2 + Math.cos(xar) * (y - ny) / 2;\n                    // step 2, using x2 as cx'\n                    var norm = Math.sqrt((rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) / (rx * rx * y1 * y1 + ry * ry * x1 * x1));\n                    if (laf === sf) norm = -norm;\n                    x2 = norm * rx * y1 / ry;\n                    y2 = norm * -ry * x1 / rx;\n                    // step 3\n                    cx = Math.cos(xar) * x2 - Math.sin(xar) * y2 + (x + nx) / 2;\n                    cy = Math.sin(xar) * x2 + Math.cos(xar) * y2 + (y + ny) / 2;\n\n                    var u = new _three2['default'].Vector2(1, 0),\n                        v = new _three2['default'].Vector2((x1 - x2) / rx, (y1 - y2) / ry);\n                    var startAng = Math.acos(u.dot(v) / u.length() / v.length());\n                    if (u.x * v.y - u.y * v.x < 0) startAng = -startAng;\n\n                    // we can reuse 'v' from start angle as our 'u' for delta angle\n                    u.x = (-x1 - x2) / rx;\n                    u.y = (-y1 - y2) / ry;\n\n                    var deltaAng = Math.acos(v.dot(u) / v.length() / u.length());\n                    // This normalization ends up making our curves fail to triangulate...\n                    if (v.x * u.y - v.y * u.x < 0) deltaAng = -deltaAng;\n                    if (!sf && deltaAng > 0) deltaAng -= Math.PI * 2;\n                    if (sf && deltaAng < 0) deltaAng += Math.PI * 2;\n\n                    path.absarc(cx, cy, rx, startAng, startAng + deltaAng, sf);\n                    x = nx;\n                    y = ny;\n                    break;\n\n                case ' ':\n                    // if it's an empty space, just skip it, and see if we can find a real command\n                    break;\n\n                default:\n                    throw new Error(\"weird path command: \" + activeCmd);\n            }\n            if (firstX === null && !enteredSub) {\n                firstX = x;\n                firstY = y;\n            }\n\n            // just reissue the command\n            if (canRepeat && nextIsNum()) continue;\n            activeCmd = pathStr[idx++];\n        }\n\n        if (zSeen) {\n            return paths;\n        } else {\n            paths.push(path);\n            return paths;\n        }\n    }\n\n    function applySVGTransform(obj, tstr) {\n\n        var idx = tstr.indexOf('('),\n            len = tstr.length,\n            cmd = tstr.substring(0, idx++);\n        function eatNum() {\n            var sidx,\n                c,\n                isFloat = false,\n                s;\n            // eat delims\n            while (idx < len) {\n                c = tstr.charCodeAt(idx);\n                if (c !== COMMA && c !== SPACE) break;\n                idx++;\n            }\n            if (c === MINUS) sidx = idx++;else sidx = idx;\n            // eat number\n            while (idx < len) {\n                c = tstr.charCodeAt(idx);\n                if (DIGIT_0 <= c && c <= DIGIT_9) {\n                    idx++;\n                    continue;\n                } else if (c === PERIOD) {\n                    idx++;\n                    isFloat = true;\n                    continue;\n                }\n\n                s = tstr.substring(sidx, idx);\n                return isFloat ? parseFloat(s) : parseInt(s);\n            }\n\n            s = tstr.substring(sidx);\n            return isFloat ? parseFloat(s) : parseInt(s);\n        }\n        switch (cmd) {\n            case 'translate':\n                obj.position.x = Math.floor(eatNum() * UNIT_SIZE);\n                obj.position.y = Math.floor(eatNum() * UNIT_SIZE);\n                break;\n            case 'scale':\n                obj.scale.x = Math.floor(eatNum() * UNIT_SIZE);\n                obj.scale.y = Math.floor(eatNum() * UNIT_SIZE);\n                break;\n            default:\n                console.warn(\"don't understand transform\", tstr);\n                break;\n        }\n    }\n\n    var extrudeDefaults = {\n        amount: 20,\n        bevelEnabled: true,\n        material: 0,\n        extrudeMaterial: 0\n    };\n\n    function commonSetAttribute(name, value) {\n        switch (name) {\n            case 'x':\n                this.position.x = Math.floor(value * UNIT_SIZE);\n                break;\n\n            case 'y':\n                this.position.y = Math.floor(value * UNIT_SIZE);\n                break;\n\n            case 'class':\n                this.clazz = value;\n                break;\n\n            case 'stroke':\n            case 'fill':\n                if (typeof value !== 'string') value = value.toString();\n                this.material.color.setHex(parseInt(value.substring(1), 16));\n                break;\n\n            case 'transform':\n                applySVGTransform(this, value);\n                break;\n\n            case 'd':\n                var shape = transformSVGPath(value),\n                    geom = shape.extrude(extrudeDefaults);\n                this.geometry = geom;\n                this.geometry.boundingSphere = { radius: 3 * UNIT_SIZE };\n                this.scale.set(UNIT_SIZE, UNIT_SIZE, UNIT_SIZE);\n\n                break;\n\n            default:\n                throw new Error(\"no setter for: \" + name);\n        }\n    }\n    function commonSetAttributeNS(namespace, name, value) {\n        this.setAttribute(name, value);\n    }\n\n    function Group(parentThing) {\n        _three2['default'].Object3D.call(this);\n\n        this.d3class = '';\n\n        parentThing.add(this);\n    };\n    Group.prototype = new _three2['default'].Object3D();\n    Group.prototype.constructor = Group;\n    Group.prototype.d3tag = 'g';\n    Group.prototype.setAttribute = commonSetAttribute;\n    Group.prototype.setAttributeNS = commonSetAttributeNS;\n\n    function fabGroup() {\n        return new Group(this);\n    }\n\n    function Mesh(parentThing, tag, geometry, material) {\n        _three2['default'].Mesh.call(this, geometry, material);\n\n        this.d3tag = tag;\n        this.d3class = '';\n\n        parentThing.add(this);\n    }\n    Mesh.prototype = new _three2['default'].Mesh();\n    Mesh.prototype.constructor = Mesh;\n    Mesh.prototype.setAttribute = commonSetAttribute;\n    Mesh.prototype.setAttributeNS = commonSetAttributeNS;\n\n    var SPHERE_SEGS = 16,\n        SPHERE_RINGS = 16,\n        DEFAULT_COLOR = 0xcc0000;\n\n    var sharedSphereGeom = null,\n        sharedCubeGeom = null;\n\n    function fabSphere() {\n        if (!sharedSphereGeom) sharedSphereGeom = new _three2['default'].SphereGeometry(UNIT_SIZE / 2, SPHERE_SEGS, SPHERE_RINGS);\n        var material = new _three2['default'].MeshLambertMaterial({\n            color: DEFAULT_COLOR\n        });\n        return new Mesh(this, 'sphere', sharedSphereGeom, material);\n    }\n\n    function fabCube() {\n        if (!sharedCubeGeom) sharedCubeGeom = new _three2['default'].CubeGeometry(UNIT_SIZE, UNIT_SIZE, UNIT_SIZE);\n        var material = new _three2['default'].MeshLambertMaterial({\n            color: DEFAULT_COLOR\n        });\n        return new Mesh(this, 'cube', sharedCubeGeom, material);\n    }\n\n    function fabPath() {\n        // start with a cube that we will replace with the path once it gets created\n        if (!sharedCubeGeom) sharedCubeGeom = new _three2['default'].CubeGeometry(UNIT_SIZE, UNIT_SIZE, UNIT_SIZE);\n        var material = new _three2['default'].MeshLambertMaterial({\n            color: DEFAULT_COLOR\n        });\n        return new Mesh(this, 'path', sharedCubeGeom, material);\n    }\n\n    function Scene() {\n        _three2['default'].Scene.call(this);\n        this.renderer = null;\n        this.camera = null;\n        this.controls = null;\n        this._d3_width = null;\n        this._d3_height = null;\n    }\n    Scene.prototype = new _three2['default'].Scene();\n    Scene.prototype.constructor = Scene;\n    Scene.prototype._setBounds = function () {\n        this.renderer.setSize(this._d3_width, this._d3_height);\n        var aspect = this.camera.aspect;\n        this.camera.position.set(this._d3_width * UNIT_SIZE / 2, this._d3_height * UNIT_SIZE / 2, Math.max(this._d3_width * UNIT_SIZE / Math.sqrt(2), this._d3_height * UNIT_SIZE / Math.sqrt(2)));\n        this.controls.target.set(this.camera.position.x, this.camera.position.y, 0);\n        console.log(\"camera:\", this.camera.position.x, this.camera.position.y, this.camera.position.z);\n\n        //this.camera.position.z = 1000;\n    };\n    Scene.prototype.setAttribute = function (name, value) {\n        switch (name) {\n            case 'width':\n                this._d3_width = value;\n                if (this._d3_height) this._setBounds();\n                break;\n            case 'height':\n                this._d3_height = value;\n                if (this._d3_width) this._setBounds();\n                break;\n        }\n    };\n\n    function fabVis() {\n        var camera, scene, controls, renderer;\n\n        // - scene\n        scene = new Scene();\n        threeJsScene = scene;\n\n        // - camera\n        camera = scene.camera = new _three2['default'].PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000);\n        /*\n         camera = scene.camera = new THREE.OrthographicCamera(\n         window.innerWidth / -2, window.innerWidth / 2,\n         window.innerHeight / 2, window.innerHeight / -2,\n         1, 50000);\n         */\n        scene.add(camera);\n\n        // - controls\n        // from misc_camera_trackball.html example\n        controls = scene.controls = new _three2['default'].TrackballControls(camera);\n        controls.rotateSpeed = 1.0;\n        controls.zoomSpeed = 1.2;\n        controls.panSpeed = 0.8;\n\n        controls.noZoom = false;\n        controls.noPan = false;\n\n        controls.staticMoving = true;\n        controls.dynamicDampingFactor = 0.3;\n\n        controls.keys = [65, 83, 68];\n\n        controls.addEventListener('change', render);\n\n        // - light\n        /*\n         var pointLight = new THREE.PointLight(0xFFFFFF);\n         pointLight.position.set(10, 50, 130);\n         scene.add(pointLight);\n         */\n\n        var spotlight = new _three2['default'].SpotLight(0xffffff);\n        spotlight.position.set(-50000, 50000, 100000);\n        scene.add(spotlight);\n\n        var backlight = new _three2['default'].SpotLight(0x888888);\n        backlight.position.set(50000, -50000, -100000);\n        scene.add(backlight);\n\n        /*\n         var ambientLight = new THREE.AmbientLight(0x888888);\n         scene.add(ambientLight);\n         */\n\n        function helperPlanes(maxBound) {\n            var geom = new _three2['default'].PlaneGeometry(maxBound, maxBound, 4, 4);\n            for (var i = 0; i < 4; i++) {\n                var color, cx, cy;\n                switch (i) {\n                    case 0:\n                        color = 0xff0000;\n                        cx = maxBound / 2;\n                        cy = maxBound / 2;\n                        break;\n                    case 1:\n                        color = 0x00ff00;\n                        cx = maxBound / 2;\n                        cy = -maxBound / 2;\n                        break;\n                    case 2:\n                        color = 0x0000ff;\n                        cx = -maxBound / 2;\n                        cy = -maxBound / 2;\n                        break;\n                    case 3:\n                        color = 0xffff00;\n                        cx = -maxBound / 2;\n                        cy = maxBound / 2;\n                        break;\n                }\n                var material = new _three2['default'].MeshLambertMaterial({ color: color });\n                var mesh = new _three2['default'].Mesh(geom, material);\n                mesh.position.set(cx, cy, -1);\n\n                scene.add(mesh);\n            }\n        }\n        //helperPlanes(UNIT_SIZE * 225);\n\n        // - renderer\n        renderer = scene.renderer = new _three2['default'].WebGLRenderer({\n            // too slow...\n            //antialias: true,\n        });\n        this.appendChild(renderer.domElement);\n\n        // - stats\n        var stats = new Stats();\n        stats.domElement.style.position = 'absolute';\n        stats.domElement.style.top = '0px';\n        stats.domElement.style.zIndex = 100;\n        this.appendChild(stats.domElement);\n\n        function animate() {\n            requestAnimationFrame(animate, renderer.domElement);\n            controls.update();\n        }\n\n        function render() {\n            renderer.render(scene, camera);\n            stats.update();\n        }\n\n        animate();\n\n        return scene;\n    };\n\n    d3.selection.prototype.append3d = function (name) {\n        var append;\n        switch (name) {\n            case 'svg':\n                append = fabVis;\n                break;\n\n            case 'g':\n                append = fabGroup;\n                break;\n\n            case 'path':\n                append = fabPath;\n                break;\n\n            case 'text':\n            case 'line':\n            case 'rect':\n                throw new Error(\"Did not implement: \" + name);\n                break;\n\n            case 'sphere':\n                append = fabSphere;\n                break;\n        }\n\n        return this.select(append);\n    };\n    d3.selection.enter.prototype.append3d = d3.selection.prototype.append3d;\n\n    function select3d_selector(constraint) {\n        var tagCheck = null,\n            classCheck = null,\n            idxPeriod = constraint.indexOf('.');\n        if (idxPeriod === -1) {\n            tagCheck = constraint;\n        } else if (idxPeriod === 0) {\n            classCheck = constraint.substring(1);\n        } else {\n            tagCheck = constraint.substring(0, idxPeriod);\n            classCheck = constraint.substring(idxPeriod + 1);\n        }\n        return function () {\n            var results = [];\n            for (var i = 0; i < this.children.length; i++) {\n                var kid = this.children[i];\n                if ((!tagCheck || kid.d3tag === tagCheck) && (!classCheck || kid.d3class === classCheck)) results.push(kid);\n            }\n            return results;\n        };\n    }\n\n    d3.selection.prototype.select3d = function (constraint) {\n        return this.select(select3d_selector(constraint));\n    };\n    d3.selection.prototype.selectAll3d = function (constraint) {\n        return this.selectAll(select3d_selector(constraint));\n    };\n\n    return {\n        exportSVG: transformSVGPath\n    };\n}\n\nmodule.exports = d3threeD;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/TileExporter/D3-Three.js\n ** module id = 111\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/TileExporter/D3-Three.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _d3 = __webpack_require__(40);\n\nvar _d32 = _interopRequireDefault(_d3);\n\nvar _three = __webpack_require__(34);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _D3Three = __webpack_require__(111);\n\nvar _D3Three2 = _interopRequireDefault(_D3Three);\n\nvar _OBJExporter = __webpack_require__(113);\n\nvar _OBJExporter2 = _interopRequireDefault(_OBJExporter);\n\nvar _OrbitControl = __webpack_require__(114);\n\nvar _OrbitControl2 = _interopRequireDefault(_OrbitControl);\n\nvar _PreviewMap = __webpack_require__(115);\n\nvar _PreviewMap2 = _interopRequireDefault(_PreviewMap);\n\nvar _Keys = __webpack_require__(35);\n\nvar _Keys2 = _interopRequireDefault(_Keys);\n\nvar _ReduxStore = __webpack_require__(38);\n\nvar _ReduxStore2 = _interopRequireDefault(_ReduxStore);\n\nvar _ReduxAction = __webpack_require__(36);\n\nvar _ReduxReducer = __webpack_require__(37);\n\nvar _ReduxReducer2 = _interopRequireDefault(_ReduxReducer);\n\nvar TileExporter = (function () {\n\n  var renderer;\n  var scene, camera, controls, buildingGroup, exporter;\n\n  var tileLon, tileLat;\n\n  var w, h;\n\n  var dthreed = new _D3Three2['default']();\n  var exporter = new _OBJExporter2['default']();\n\n  var uniforms = {\n    time: { type: \"f\", value: 1.0 },\n    resolution: { type: \"v2\", value: new _three2['default'].Vector2() }\n  };\n\n  var config = {\n    baseURL: \"http://vector.mapzen.com/osm\",\n    dataKind: \"earth,water,buildings,landuse\",\n    fileFormat: \"json\",\n    zoomLevel: 16\n  };\n\n  function initScene() {\n    w = window.innerWidth;\n    h = window.innerHeight;\n    /// Global : renderer\n    renderer = new _three2['default'].WebGLRenderer({ antialias: true });\n    renderer.setClearColor(\"0xb0b0b0\");\n    renderer.setSize(w, h);\n\n    /// Global : scene\n    scene = new _three2['default'].Scene();\n\n    /// Global : camera\n    camera = new _three2['default'].PerspectiveCamera(20, w / h, 1, 1000000);\n    camera.position.set(0, 0, 500);\n    camera.lookAt(new _three2['default'].Vector3(0, 0, 0));\n\n    /// direct light\n    var light = new _three2['default'].DirectionalLight(0xffffff);\n    light.position.set(1, 1, 1);\n    light.rotation.set(2, 1, 1);\n    scene.add(light);\n\n    /// ambient light\n    var ambientLight = new _three2['default'].AmbientLight(0xffffff);\n    scene.add(ambientLight);\n\n    //orbit control\n    controls = new _OrbitControl2['default'](camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.25;\n    controls.enableZoom = false;\n\n    //attach renderer to DOM\n    document.body.appendChild(renderer.domElement);\n    //initiating animate of rendere at the same time\n    animate();\n  }\n\n  function animate() {\n    requestAnimationFrame(animate);\n    controls.update();\n    uniforms.time.value += 0.05;\n    renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n\n    w = window.innerWidth;\n    h = window.innerHeight;\n    camera.aspect = w / h;\n    camera.updateProjectionMatrix();\n    renderer.setSize(w, h);\n  }\n\n  function attachEvents() {\n    var exportBtn = document.getElementById('exportBtn');\n\n    exportBtn.addEventListener('click', function () {\n      //var inputLon = document.getElementById('lon').value;\n      //var inputLat = document.getElementById('lat').value;\n      fetchTheTile(buildQueryURL());\n    });\n\n    var nwBtn = document.getElementById('preview-north-west');\n    var nBtn = document.getElementById('preview-north');\n    var neBtn = document.getElementById('preview-north-east');\n\n    var wBtn = document.getElementById('preview-west');\n\n    var eBtn = document.getElementById('preview-east');\n\n    var swBtn = document.getElementById('preview-south-west');\n    var sBtn = document.getElementById('preview-south');\n    var seBtn = document.getElementById('preview-south-east');\n\n    //navigating tile\n    nwBtn.addEventListener('click', function () {\n      navigateTile(-1, -1);\n    });\n    nBtn.addEventListener('click', function () {\n      navigateTile(0, -1);\n    });\n    neBtn.addEventListener('click', function () {\n      navigateTile(1, -1);\n    });\n\n    wBtn.addEventListener('click', function () {\n      navigateTile(-1, 0);\n    });\n    eBtn.addEventListener('click', function () {\n      navigateTile(1, 0);\n    });\n\n    swBtn.addEventListener('click', function () {\n      navigateTile(-1, 1);\n    });\n    sBtn.addEventListener('click', function () {\n      navigateTile(0, 1);\n    });\n    seBtn.addEventListener('click', function () {\n      navigateTile(1, 1);\n    });\n\n    var zoomRad = document.zoomRadio.zoomLevel;\n    var prev = null;\n\n    for (var i = 0; i < zoomRad.length; i++) {\n      zoomRad[i].onclick = function () {\n        if (this !== prev) {\n          prev = this;\n        }\n        var zoomLevel = parseInt(prev.value);\n        _ReduxStore2['default'].dispatch((0, _ReduxAction.updateZoom)(zoomLevel));\n      };\n    }\n\n    //for mobile ui, toggle main control\n    var mainControl = document.getElementById('main-control');\n    document.getElementById('hide-toggle').addEventListener('click', function () {\n      if (mainControl.style.display !== 'none') {\n        mainControl.style.display = 'none';\n        this.innerHTML = 'Show control';\n      } else {\n        mainControl.style.display = 'block';\n        this.innerHTML = 'Hide control';\n      }\n    });\n\n    window.addEventListener('resize', onWindowResize, false);\n\n    //check query string\n    checkQueries();\n  }\n\n  function checkQueries() {\n    var _lon = getParameterByName('lon');\n    var _lat = getParameterByName('lat');\n    var _zoom = getParameterByName('zoom');\n\n    if (_lon !== null && _lat !== null && _zoom !== null) {\n\n      _zoom = _zoom.replace(/[^0-9]+/g, '');\n\n      document.getElementById('lat').innerHTML = _lat;\n      document.getElementById('lon').innerHTML = _lon;\n\n      document.zoomRadio.zoomLevel.value = _zoom;\n      config.zoomLevel = _zoom;\n\n      _ReduxStore2['default'].dispatch((0, _ReduxAction.updatePointZoom)({\n        lat: _lat,\n        lon: _lon,\n        zoom: _zoom\n      }));\n      fetchTheTile(buildQueryURL());\n      document.getElementById('exportBtn').disabled = false;\n    }\n  }\n\n  function navigateTile(eastWest, northSouth) {\n\n    if (tileLon) {\n      tileLon += eastWest;\n      tileLat += northSouth;\n\n      var zoom = _ReduxStore2['default'].getState().zoom;\n\n      var callURL = config.baseURL + '/' + config.dataKind + '/' + zoom + '/' + tileLon + '/' + tileLat + '.' + config.fileFormat + '?api_key=' + _Keys2['default'].vectorTile;\n      var centerLon = tile2Lon(tileLon, zoom);\n      var centerLat = tile2Lat(tileLat, zoom);\n\n      var lonLatZoom = {\n        lon: centerLon,\n        lat: centerLat,\n        zoom: zoom\n      };\n\n      _ReduxStore2['default'].dispatch((0, _ReduxAction.updatePoint)({\n        lon: centerLon,\n        lat: centerLat\n      }));\n\n      //store.dispatch(updatePointZoom(lonLatZoom))\n      fetchTheTile(callURL);\n\n      updateQueryString(lonLatZoom);\n\n      document.getElementById('lat').innerHTML = centerLat;\n      document.getElementById('lon').innerHTML = centerLon;\n    } else {\n      console.log('please select a place');\n    }\n  }\n\n  function buildQueryURL() {\n\n    var inputLon = _ReduxStore2['default'].getState().lon; //parseFloat(lon);//-74.0059700;\n    var inputLat = _ReduxStore2['default'].getState().lat; //parseFloat(lat);//40.7142700;\n    var zoom = _ReduxStore2['default'].getState().zoom;\n    config.zoomLevel = zoom;\n\n    updateQueryString({\n      'lon': inputLon,\n      'lat': inputLat,\n      'zoom': zoom\n    });\n\n    //falttening geocode by converting them to mercator tile nums\n    tileLon = long2tile(inputLon, zoom);\n    tileLat = lat2tile(inputLat, zoom);\n\n    var callURL = config.baseURL + '/' + config.dataKind + '/' + zoom + '/' + tileLon + '/' + tileLat + '.' + config.fileFormat + '?api_key=' + _Keys2['default'].vectorTile;\n    return callURL;\n  }\n\n  var tileX, tileY, tileW, tileH;\n\n  function fetchTheTile(callURL) {\n\n    setLoadingBar(true);\n\n    var buildings = [];\n    var heights = [];\n\n    //get rid of current Tile from scene if there is any\n    scene.remove(buildingGroup);\n    //get rid of current preview\n    _PreviewMap2['default'].destroy();\n\n    //get lon/lat for mercator tile num\n    var centerLon = tile2Lon(tileLon, config.zoomLevel);\n    var centerLat = tile2Lat(tileLat, config.zoomLevel);\n\n    var previewProjection = _d32['default'].geo.mercator().center([centerLon, centerLat])\n    //this are carved based on zoom 16\n    .scale(600000 * 100 / 58 * Math.pow(2, config.zoomLevel - 16)).precision(.0).translate([0, 0]);\n\n    var projection = _d32['default'].geo.mercator().center([centerLon, centerLat]).scale(1000000).precision(.0).translate([0, 0]);\n    //draw previewmap\n    _PreviewMap2['default'].drawData(tileLon, tileLat);\n\n    // converting d3 path(svg) to three shape\n    //converting geocode to mercator tile nums\n    _d32['default'].json(callURL, function (err, json) {\n      if (err) console.log('err!');else {\n        for (obj in json) {\n          var j;\n          for (j = 0; j < json[obj].features.length; j++) {\n\n            var geoFeature = json[obj].features[j];\n            var previewPath = _d32['default'].geo.path().projection(previewProjection);\n            var path = _d32['default'].geo.path().projection(projection);\n\n            var defaultHeight = 25;\n\n            if (obj === 'earth') {\n              var b = path.bounds(geoFeature);\n              tileX = b[0][0];\n              tileY = b[0][1];\n              tileW = b[1][0] - b[0][0];\n              tileH = b[1][1] - b[0][1];\n              defaultHeight = 10;\n            } else if (obj === 'water') {\n              defaultHeight = 6;\n            } else if (obj === 'landuse') {\n              defaultHeight = 13;\n            }\n\n            //path = d3.geo.path().projection(projection);\n            var feature = path(geoFeature);\n            var previewFeature = previewPath(geoFeature);\n\n            if (feature !== undefined) {\n              if (previewFeature.indexOf('a') > 0) ;\n\n              // 'a' command is not implemented in d3-three, skipiping for now.\n              if (feature.indexOf('a') > 0) ;else {\n                var mesh = dthreed.exportSVG(feature);\n                buildings.push(mesh);\n                var h = geoFeature.properties['height'] + 10 || defaultHeight;\n                heights.push(h);\n              }\n            }\n          }\n        }\n\n        var obj = {};\n        obj.paths = buildings;\n\n        obj.amounts = heights || defaultHeight;\n        buildingGroup = new _three2['default'].Group();\n        //buildingGroup.rotation.x = Math.PI;\n        buildingGroup.translateX(-(tileX + tileW) / 2);\n        buildingGroup.translateY((tileY + tileH) / 2);\n\n        scene.add(buildingGroup);\n        addGeoObject(obj);\n      }\n      setLoadingBar(false);\n    });\n  }\n\n  function addGeoObject(svgObject) {\n    var path,\n        material,\n        amount,\n        simpleShapes,\n        simpleShape,\n        shape3d,\n        toAdd,\n        results = [];\n\n    var thePaths = svgObject.paths;\n    var theAmounts = svgObject.amounts;\n\n    var color = new _three2['default'].Color(\"#5c5c5c\");\n\n    // material = new THREE.MeshLambertMaterial({\n    //   color: color\n    // });\n\n    material = new _three2['default'].ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: document.getElementById('vertexShader').textContent,\n      fragmentShader: document.getElementById('fragmentShader').textContent,\n      side: _three2['default'].DoubleSide,\n      shading: _three2['default'].FlatShading,\n      fog: true\n    });\n\n    var i, j, k, len1;\n\n    for (i = 0; i < thePaths.length; i++) {\n      amount = theAmounts[i];\n      simpleShapes = thePaths[i];\n      len1 = simpleShapes.length;\n\n      //adding all the buildings to the group!\n      for (j = 0; j < len1; ++j) {\n\n        simpleShape = simpleShapes[j];\n        try {\n          shape3d = simpleShape.extrude({\n            amount: amount / 6,\n            bevelEnabled: false\n          });\n\n          for (k = 0; k < shape3d.vertices.length; k++) {\n            var v = shape3d.vertices[k];\n            v.setY(-v.y);\n          }\n\n          var mesh = new _three2['default'].Mesh(shape3d, material);\n          reverseWindingOrder(mesh);\n          buildingGroup.add(mesh);\n        } catch (e) {\n          console.log('it could not exturde geometry, it can be because of duplicated point of svg.');\n        }\n      }\n    }\n    enableDownloadLink();\n  }\n\n  function reverseWindingOrder(object3D) {\n    // This function is written by Immugio at Stack Overflow\n    // http://stackoverflow.com/questions/28630097/flip-mirror-any-object-with-three-js\n    // it had TODO: Something is missing, the objects are flipped alright but the light reflection on them is somehow broken\n    // this application ignored light reflection using flat shade material\n\n    if (object3D.type === \"Mesh\") {\n\n      var geometry = object3D.geometry;\n\n      for (var i = 0, l = geometry.faces.length; i < l; i++) {\n        var face = geometry.faces[i];\n        var temp = face.a;\n        face.a = face.c;\n        face.c = temp;\n      }\n\n      var faceVertexUvs = geometry.faceVertexUvs[0];\n\n      for (i = 0, l = faceVertexUvs.length; i < l; i++) {\n\n        var vector2 = faceVertexUvs[i][0];\n        faceVertexUvs[i][0] = faceVertexUvs[i][2];\n        faceVertexUvs[i][2] = vector2;\n      }\n\n      geometry.computeFaceNormals();\n      //geometry.computeVertexNormals();\n    }\n\n    if (object3D.children) {\n      for (var j = 0, jl = object3D.children.length; j < jl; j++) {\n        reverseWindingOrder(object3D.children[j]);\n      }\n    }\n  }\n\n  function enableDownloadLink() {\n\n    var buildingObj = exportToObj();\n    var exportA = document.getElementById('exportA');\n    exportA.className = \"\";\n    exportA.download = 'tile' + tileLon + '-' + tileLat + '-' + _ReduxStore2['default'].getState().zoom + '.obj';\n\n    var blob = new Blob([buildingObj], { type: 'text' });\n    var url = URL.createObjectURL(blob);\n    exportA.href = url;\n  }\n\n  function exportToObj() {\n    var result = exporter.parse(scene);\n    return result;\n  }\n\n  function updateQueryString(paramObj) {\n    var url = window.location.origin + window.location.pathname;\n    var newUrl = url + '?';\n    var params = [];\n    for (var key in paramObj) {\n      params.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(paramObj[key]));\n    }\n    newUrl += params.join(\"&\");\n    window.history.replaceState({}, '', newUrl);\n  }\n\n  function getParameterByName(name, url) {\n    if (!url) url = window.location.href;\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return '';\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n  }\n\n  function setLoadingBar(on) {\n    if (on) document.getElementById('loading-bar').style.display = 'block';else document.getElementById('loading-bar').style.display = 'none';\n  }\n\n  return {\n    initScene: initScene,\n    attachEvents: attachEvents\n  };\n})();\n\n////here all maps spells are!\n//convert lat/lon to mercator style number\nfunction long2tile(lon, zoom) {\n  return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));\n}\nfunction lat2tile(lat, zoom) {\n  return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));\n}\n\n//shold check it will work\nfunction tile2Lon(tileLon, zoom) {\n  return (tileLon * 360 / Math.pow(2, zoom) - 180).toFixed(10);\n}\n\nfunction tile2Lat(tileLat, zoom) {\n  return (360 / Math.PI * Math.atan(Math.pow(Math.E, Math.PI - 2 * Math.PI * tileLat / Math.pow(2, zoom))) - 90).toFixed(10);\n}\n\nmodule.exports = TileExporter;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/TileExporter/Exporter.js\n ** module id = 112\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/TileExporter/Exporter.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _three = __webpack_require__(34);\n\nvar _three2 = _interopRequireDefault(_three);\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n_three2['default'].OBJExporter = function () {};\n\n_three2['default'].OBJExporter.prototype = {\n\n  constructor: _three2['default'].OBJExporter,\n\n  parse: function parse(object) {\n\n    var output = '';\n\n    var indexVertex = 0;\n    var indexVertexUvs = 0;\n    var indexNormals = 0;\n\n    var parseMesh = function parseMesh(mesh) {\n\n      var nbVertex = 0;\n      var nbVertexUvs = 0;\n      var nbNormals = 0;\n\n      var geometry = mesh.geometry;\n\n      if (geometry instanceof _three2['default'].Geometry) {\n\n        output += 'o ' + mesh.name + '\\n';\n\n        var vertices = geometry.vertices;\n\n        for (var i = 0, l = vertices.length; i < l; i++) {\n\n          var vertex = vertices[i].clone();\n          vertex.applyMatrix4(mesh.matrixWorld);\n\n          output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n          nbVertex++;\n        }\n\n        // uvs\n\n        var faces = geometry.faces;\n        var faceVertexUvs = geometry.faceVertexUvs[0];\n        var hasVertexUvs = faces.length === faceVertexUvs.length;\n\n        if (hasVertexUvs) {\n\n          for (var i = 0, l = faceVertexUvs.length; i < l; i++) {\n\n            var vertexUvs = faceVertexUvs[i];\n\n            for (var j = 0, jl = vertexUvs.length; j < jl; j++) {\n\n              var uv = vertexUvs[j];\n\n              output += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n              nbVertexUvs++;\n            }\n          }\n        }\n\n        // normals\n\n        var normalMatrixWorld = new _three2['default'].Matrix3();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (var i = 0, l = faces.length; i < l; i++) {\n\n          var face = faces[i];\n          var vertexNormals = face.vertexNormals;\n\n          if (vertexNormals.length === 3) {\n\n            for (var j = 0, jl = vertexNormals.length; j < jl; j++) {\n\n              var normal = vertexNormals[j].clone();\n              normal.applyMatrix3(normalMatrixWorld);\n\n              output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n              nbNormals++;\n            }\n          } else {\n\n            var normal = face.normal.clone();\n            normal.applyMatrix3(normalMatrixWorld);\n\n            for (var j = 0; j < 3; j++) {\n\n              output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n              nbNormals++;\n            }\n          }\n        }\n\n        // faces\n\n        for (var i = 0, j = 1, l = faces.length; i < l; i++, j += 3) {\n\n          var face = faces[i];\n\n          output += 'f ';\n          output += indexVertex + face.a + 1 + '/' + (hasVertexUvs ? indexVertexUvs + j : '') + '/' + (indexNormals + j) + ' ';\n          output += indexVertex + face.b + 1 + '/' + (hasVertexUvs ? indexVertexUvs + j + 1 : '') + '/' + (indexNormals + j + 1) + ' ';\n          output += indexVertex + face.c + 1 + '/' + (hasVertexUvs ? indexVertexUvs + j + 2 : '') + '/' + (indexNormals + j + 2) + '\\n';\n        }\n      } else {\n\n        console.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', mesh);\n        // TODO: Support only BufferGeometry and use use setFromObject()\n      }\n\n      // update index\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    };\n\n    object.traverse(function (child) {\n\n      if (child instanceof _three2['default'].Mesh) parseMesh(child);\n    });\n\n    return output;\n  }\n\n};\n\nmodule.exports = _three2['default'].OBJExporter;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/TileExporter/OBJ-Exporter.js\n ** module id = 113\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/TileExporter/OBJ-Exporter.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _three = __webpack_require__(34);\n\nvar _three2 = _interopRequireDefault(_three);\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n/*global THREE, console */\n\n// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n// supported.\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n//\n// This is a drop-in replacement for (most) TrackballControls used in examples.\n// That is, include this js file and wherever you see:\n//      controls = new THREE.TrackballControls( camera );\n//      controls.target.z = 150;\n// Simple substitute \"OrbitControls\" and the control should work as-is.\n\n_three2['default'].OrbitControls = function (object, domElement) {\n\n  this.object = object;\n  this.domElement = domElement !== undefined ? domElement : document;\n\n  // API\n\n  // Set to false to disable this control\n  this.enabled = true;\n\n  // \"target\" sets the location of focus, where the control orbits around\n  // and where it pans with respect to.\n  this.target = new _three2['default'].Vector3();\n\n  // center is old, deprecated; use \"target\" instead\n  this.center = this.target;\n\n  // This option actually enables dollying in and out; left as \"zoom\" for\n  // backwards compatibility\n  this.noZoom = false;\n  this.zoomSpeed = 1.0;\n\n  // Limits to how far you can dolly in and out\n  this.minDistance = 0;\n  this.maxDistance = Infinity;\n\n  // Set to true to disable this control\n  this.noRotate = false;\n  this.rotateSpeed = 1.0;\n\n  // Set to true to disable this control\n  this.noPan = false;\n  this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n  // Set to true to automatically rotate around the target\n  this.autoRotate = false;\n  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  this.minPolarAngle = 0; // radians\n  this.maxPolarAngle = Math.PI; // radians\n\n  // Set to true to disable use of the keys\n  this.noKeys = false;\n\n  // The four arrow keys\n  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n  ////////////\n  // internals\n\n  var scope = this;\n\n  var EPS = 0.000001;\n\n  var rotateStart = new _three2['default'].Vector2();\n  var rotateEnd = new _three2['default'].Vector2();\n  var rotateDelta = new _three2['default'].Vector2();\n\n  var panStart = new _three2['default'].Vector2();\n  var panEnd = new _three2['default'].Vector2();\n  var panDelta = new _three2['default'].Vector2();\n  var panOffset = new _three2['default'].Vector3();\n\n  var offset = new _three2['default'].Vector3();\n\n  var dollyStart = new _three2['default'].Vector2();\n  var dollyEnd = new _three2['default'].Vector2();\n  var dollyDelta = new _three2['default'].Vector2();\n\n  var phiDelta = 0;\n  var thetaDelta = 0;\n  var scale = 1;\n  var pan = new _three2['default'].Vector3();\n\n  var lastPosition = new _three2['default'].Vector3();\n\n  var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\n\n  var state = STATE.NONE;\n\n  // for reset\n\n  this.target0 = this.target.clone();\n  this.position0 = this.object.position.clone();\n\n  // so camera.up is the orbit axis\n\n  var quat = new _three2['default'].Quaternion().setFromUnitVectors(object.up, new _three2['default'].Vector3(0, 1, 0));\n  var quatInverse = quat.clone().inverse();\n\n  // events\n\n  var changeEvent = { type: 'change' };\n  var startEvent = { type: 'start' };\n  var endEvent = { type: 'end' };\n\n  this.rotateLeft = function (angle) {\n\n    if (angle === undefined) {\n\n      angle = getAutoRotationAngle();\n    }\n\n    thetaDelta -= angle;\n  };\n\n  this.rotateUp = function (angle) {\n\n    if (angle === undefined) {\n\n      angle = getAutoRotationAngle();\n    }\n\n    phiDelta -= angle;\n  };\n\n  // pass in distance in world space to move left\n  this.panLeft = function (distance) {\n\n    var te = this.object.matrix.elements;\n\n    // get X column of matrix\n    panOffset.set(te[0], te[1], te[2]);\n    panOffset.multiplyScalar(-distance);\n\n    pan.add(panOffset);\n  };\n\n  // pass in distance in world space to move up\n  this.panUp = function (distance) {\n\n    var te = this.object.matrix.elements;\n\n    // get Y column of matrix\n    panOffset.set(te[4], te[5], te[6]);\n    panOffset.multiplyScalar(distance);\n\n    pan.add(panOffset);\n  };\n\n  // pass in x,y of change desired in pixel space,\n  // right and down are positive\n  this.pan = function (deltaX, deltaY) {\n\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n    if (scope.object.fov !== undefined) {\n\n      // perspective\n      var position = scope.object.position;\n      var offset = position.clone().sub(scope.target);\n      var targetDistance = offset.length();\n\n      // half of the fov is center to top of screen\n      targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n\n      // we actually don't use screenWidth, since perspective camera is fixed to screen height\n      scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);\n      scope.panUp(2 * deltaY * targetDistance / element.clientHeight);\n    } else if (scope.object.top !== undefined) {\n\n      // orthographic\n      scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);\n      scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);\n    } else {\n\n      // camera neither orthographic or perspective\n      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n    }\n  };\n\n  this.dollyIn = function (dollyScale) {\n\n    if (dollyScale === undefined) {\n\n      dollyScale = getZoomScale();\n    }\n\n    scale /= dollyScale;\n  };\n\n  this.dollyOut = function (dollyScale) {\n\n    if (dollyScale === undefined) {\n\n      dollyScale = getZoomScale();\n    }\n\n    scale *= dollyScale;\n  };\n\n  this.update = function () {\n\n    var position = this.object.position;\n\n    offset.copy(position).sub(this.target);\n\n    // rotate offset to \"y-axis-is-up\" space\n    offset.applyQuaternion(quat);\n\n    // angle from z-axis around y-axis\n\n    var theta = Math.atan2(offset.x, offset.z);\n\n    // angle from y-axis\n\n    var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n    if (this.autoRotate) {\n\n      this.rotateLeft(getAutoRotationAngle());\n    }\n\n    theta += thetaDelta;\n    phi += phiDelta;\n\n    // restrict phi to be between desired limits\n    phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n    // restrict phi to be betwee EPS and PI-EPS\n    phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n    var radius = offset.length() * scale;\n\n    // restrict radius to be between desired limits\n    radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n    // move target to panned location\n    this.target.add(pan);\n\n    offset.x = radius * Math.sin(phi) * Math.sin(theta);\n    offset.y = radius * Math.cos(phi);\n    offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n    // rotate offset back to \"camera-up-vector-is-up\" space\n    offset.applyQuaternion(quatInverse);\n\n    position.copy(this.target).add(offset);\n\n    this.object.lookAt(this.target);\n\n    thetaDelta = 0;\n    phiDelta = 0;\n    scale = 1;\n    pan.set(0, 0, 0);\n\n    if (lastPosition.distanceToSquared(this.object.position) > EPS) {\n\n      this.dispatchEvent(changeEvent);\n\n      lastPosition.copy(this.object.position);\n    }\n  };\n\n  this.reset = function () {\n\n    state = STATE.NONE;\n\n    this.target.copy(this.target0);\n    this.object.position.copy(this.position0);\n\n    this.update();\n  };\n\n  function getAutoRotationAngle() {\n\n    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n  }\n\n  function getZoomScale() {\n\n    return Math.pow(0.95, scope.zoomSpeed);\n  }\n\n  function onMouseDown(event) {\n\n    if (scope.enabled === false) return;\n    event.preventDefault();\n\n    if (event.button === 0) {\n      if (scope.noRotate === true) return;\n\n      state = STATE.ROTATE;\n\n      rotateStart.set(event.clientX, event.clientY);\n    } else if (event.button === 1) {\n      if (scope.noZoom === true) return;\n\n      state = STATE.DOLLY;\n\n      dollyStart.set(event.clientX, event.clientY);\n    } else if (event.button === 2) {\n      if (scope.noPan === true) return;\n\n      state = STATE.PAN;\n\n      panStart.set(event.clientX, event.clientY);\n    }\n\n    scope.domElement.addEventListener('mousemove', onMouseMove, false);\n    scope.domElement.addEventListener('mouseup', onMouseUp, false);\n    scope.dispatchEvent(startEvent);\n  }\n\n  function onMouseMove(event) {\n\n    if (scope.enabled === false) return;\n\n    event.preventDefault();\n\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n    if (state === STATE.ROTATE) {\n\n      if (scope.noRotate === true) return;\n\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart);\n\n      // rotating across whole screen goes 360 degrees around\n      scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n      // rotating up and down along whole screen attempts to go 360, but limited to 180\n      scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n      rotateStart.copy(rotateEnd);\n    } else if (state === STATE.DOLLY) {\n\n      if (scope.noZoom === true) return;\n\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n\n      if (dollyDelta.y > 0) {\n\n        scope.dollyIn();\n      } else {\n\n        scope.dollyOut();\n      }\n\n      dollyStart.copy(dollyEnd);\n    } else if (state === STATE.PAN) {\n\n      if (scope.noPan === true) return;\n\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart);\n\n      scope.pan(panDelta.x, panDelta.y);\n\n      panStart.copy(panEnd);\n    }\n\n    scope.update();\n  }\n\n  function onMouseUp() /* event */{\n\n    if (scope.enabled === false) return;\n\n    scope.domElement.removeEventListener('mousemove', onMouseMove, false);\n    scope.domElement.removeEventListener('mouseup', onMouseUp, false);\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  function onMouseWheel(event) {\n\n    if (scope.enabled === false || scope.noZoom === true) return;\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    var delta = 0;\n\n    if (event.wheelDelta !== undefined) {\n      // WebKit / Opera / Explorer 9\n\n      delta = event.wheelDelta;\n    } else if (event.detail !== undefined) {\n      // Firefox\n\n      delta = -event.detail;\n    }\n\n    if (delta > 0) {\n\n      scope.dollyOut();\n    } else {\n\n      scope.dollyIn();\n    }\n\n    scope.update();\n    scope.dispatchEvent(startEvent);\n    scope.dispatchEvent(endEvent);\n  }\n\n  function onKeyDown(event) {\n\n    if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;\n\n    switch (event.keyCode) {\n\n      case scope.keys.UP:\n        scope.pan(0, scope.keyPanSpeed);\n        scope.update();\n        break;\n\n      case scope.keys.BOTTOM:\n        scope.pan(0, -scope.keyPanSpeed);\n        scope.update();\n        break;\n\n      case scope.keys.LEFT:\n        scope.pan(scope.keyPanSpeed, 0);\n        scope.update();\n        break;\n\n      case scope.keys.RIGHT:\n        scope.pan(-scope.keyPanSpeed, 0);\n        scope.update();\n        break;\n\n    }\n  }\n\n  function touchstart(event) {\n\n    if (scope.enabled === false) return;\n\n    switch (event.touches.length) {\n\n      case 1:\n        // one-fingered touch: rotate\n\n        if (scope.noRotate === true) return;\n\n        state = STATE.TOUCH_ROTATE;\n\n        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        break;\n\n      case 2:\n        // two-fingered touch: dolly\n\n        if (scope.noZoom === true) return;\n\n        state = STATE.TOUCH_DOLLY;\n\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        dollyStart.set(0, distance);\n        break;\n\n      case 3:\n        // three-fingered touch: pan\n\n        if (scope.noPan === true) return;\n\n        state = STATE.TOUCH_PAN;\n\n        panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n        break;\n\n      default:\n\n        state = STATE.NONE;\n\n    }\n\n    scope.dispatchEvent(startEvent);\n  }\n\n  function touchmove(event) {\n\n    if (scope.enabled === false) return;\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n    switch (event.touches.length) {\n\n      case 1:\n        // one-fingered touch: rotate\n\n        if (scope.noRotate === true) return;\n        if (state !== STATE.TOUCH_ROTATE) return;\n\n        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        rotateDelta.subVectors(rotateEnd, rotateStart);\n\n        // rotating across whole screen goes 360 degrees around\n        scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\n        scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n        rotateStart.copy(rotateEnd);\n\n        scope.update();\n        break;\n\n      case 2:\n        // two-fingered touch: dolly\n\n        if (scope.noZoom === true) return;\n        if (state !== STATE.TOUCH_DOLLY) return;\n\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        dollyEnd.set(0, distance);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n\n          scope.dollyOut();\n        } else {\n\n          scope.dollyIn();\n        }\n\n        dollyStart.copy(dollyEnd);\n\n        scope.update();\n        break;\n\n      case 3:\n        // three-fingered touch: pan\n\n        if (scope.noPan === true) return;\n        if (state !== STATE.TOUCH_PAN) return;\n\n        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n        panDelta.subVectors(panEnd, panStart);\n\n        scope.pan(panDelta.x, panDelta.y);\n\n        panStart.copy(panEnd);\n\n        scope.update();\n        break;\n\n      default:\n\n        state = STATE.NONE;\n\n    }\n  }\n\n  function touchend() /* event */{\n\n    if (scope.enabled === false) return;\n\n    scope.dispatchEvent(endEvent);\n    state = STATE.NONE;\n  }\n\n  this.domElement.addEventListener('contextmenu', function (event) {\n    event.preventDefault();\n  }, false);\n  this.domElement.addEventListener('mousedown', onMouseDown, false);\n  this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n  this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n\n  this.domElement.addEventListener('touchstart', touchstart, false);\n  this.domElement.addEventListener('touchend', touchend, false);\n  this.domElement.addEventListener('touchmove', touchmove, false);\n\n  window.addEventListener('keydown', onKeyDown, false);\n\n  // force an update at start\n  this.update();\n};\n\n_three2['default'].OrbitControls.prototype = Object.create(_three2['default'].EventDispatcher.prototype);\n\nmodule.exports = _three2['default'].OrbitControls;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/TileExporter/OrbitControl.js\n ** module id = 114\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/TileExporter/OrbitControl.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _d3 = __webpack_require__(40);\n\nvar _d32 = _interopRequireDefault(_d3);\n\nvar _Keys = __webpack_require__(35);\n\nvar _Keys2 = _interopRequireDefault(_Keys);\n\nvar _ReduxStore = __webpack_require__(38);\n\nvar _ReduxStore2 = _interopRequireDefault(_ReduxStore);\n\nvar _ReduxAction = __webpack_require__(36);\n\nvar _ReduxReducer = __webpack_require__(37);\n\nvar _ReduxReducer2 = _interopRequireDefault(_ReduxReducer);\n\nvar PreviewMap = (function () {\n\n  var width, height;\n  var neSvg, nSvg, nwSvg, eSvg, svg, wSvg, seSvg, sSvg, swSvg;\n\n  var tileLon, tileLat;\n\n  var config = {\n    baseURL: \"http://vector.mapzen.com/osm\",\n    dataKind: \"earth,water,buildings\",\n    fileFormat: \"json\"\n  };\n\n  function init() {\n\n    width = 100;\n    height = 100;\n\n    neSvg = _d32['default'].select('#preview-north-east').append('svg').attr('width', width).attr('height', height);\n\n    nSvg = _d32['default'].select('#preview-north').append('svg').attr('width', width).attr('height', height);\n\n    nwSvg = _d32['default'].select('#preview-north-west').append('svg').attr('width', width).attr('height', height);\n\n    eSvg = _d32['default'].select('#preview-east').append('svg').attr('width', width).attr('height', height);\n\n    svg = _d32['default'].select('#preview-center').append('svg').attr('width', width).attr('height', height);\n\n    wSvg = _d32['default'].select('#preview-west').append('svg').attr('width', width).attr('height', height);\n\n    seSvg = _d32['default'].select('#preview-south-east').append('svg').attr('width', width).attr('height', height);\n\n    sSvg = _d32['default'].select('#preview-south').append('svg').attr('width', width).attr('height', height);\n\n    swSvg = _d32['default'].select('#preview-south-west').append('svg').attr('width', width).attr('height', height);\n  }\n\n  function drawData(_tileLon, _tileLat) {\n\n    tileLon = _tileLon;\n    tileLat = _tileLat;\n\n    drawTheTile(buildQueryURL(1, -1), neSvg);\n    drawTheTile(buildQueryURL(0, -1), nSvg);\n    drawTheTile(buildQueryURL(-1, -1), nwSvg);\n\n    drawTheTile(buildQueryURL(1, 0), eSvg);\n    drawTheTile(buildQueryURL(0, 0), svg);\n    drawTheTile(buildQueryURL(-1, 0), wSvg);\n\n    drawTheTile(buildQueryURL(1, 1), seSvg);\n    drawTheTile(buildQueryURL(0, 1), sSvg);\n    drawTheTile(buildQueryURL(-1, 1), swSvg);\n  }\n\n  function drawTheTile(url, element) {\n\n    var zoom = _ReduxStore2['default'].getState().zoom;\n\n    _d32['default'].json(url.callURL, function (err, json) {\n      var previewProjection = _d32['default'].geo.mercator().center([url.centerLatLon.lon, url.centerLatLon.lat])\n      //this are carved based on zoom 16, fit into 100px * 100px rect\n      .scale(600000 * 100 / 57 * Math.pow(2, zoom - 16)).precision(.0).translate([0, 0]);\n\n      if (err) console.log('err!');else {\n        for (var obj in json) {\n          var j;\n\n          for (j = 0; j < json[obj].features.length; j++) {\n            var geoFeature = json[obj].features[j];\n            var previewPath = _d32['default'].geo.path().projection(previewProjection);\n            var previewFeature = previewPath(geoFeature);\n\n            if (previewFeature !== undefined) {\n              if (previewFeature.indexOf('a') > 0) ;else {\n                element.append('path').attr('d', previewFeature);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n\n  function destroy() {\n\n    neSvg.selectAll('*').remove();\n    nSvg.selectAll('*').remove();\n    nwSvg.selectAll('*').remove();\n    eSvg.selectAll('*').remove();\n    svg.selectAll('*').remove();\n    wSvg.selectAll('*').remove();\n    seSvg.selectAll('*').remove();\n    sSvg.selectAll('*').remove();\n    swSvg.selectAll('*').remove();\n  }\n\n  function buildQueryURL(eastWest, northSouth) {\n\n    // var inputLon = store.getState().lon; //parseFloat(lon);//-74.0059700;\n    // var inputLat = store.getState().lat;//parseFloat(lat);//40.7142700;\n    var zoom = _ReduxStore2['default'].getState().zoom;\n\n    //falttening geocode by converting them to mercator tile nums\n    var tLon = tileLon; //= long2tile(inputLon, zoom);\n    var tLat = tileLat; //= lat2tile(inputLat , zoom);\n\n    tLon += eastWest;\n    tLat += northSouth;\n\n    var callURL = config.baseURL + '/' + config.dataKind + '/' + zoom + '/' + tLon + '/' + tLat + '.' + config.fileFormat + '?api_key=' + _Keys2['default'].vectorTile;\n\n    var centerLatLon = {\n      lat: tile2Lat(tLat, zoom),\n      lon: tile2Lon(tLon, zoom)\n    };\n    return {\n      callURL: callURL,\n      centerLatLon: centerLatLon\n    };\n  }\n\n  init();\n\n  return {\n    drawData: drawData,\n    destroy: destroy\n  };\n})();\n\nfunction tile2Lon(tileLon, zoom) {\n  return (tileLon * 360 / Math.pow(2, zoom) - 180).toFixed(10);\n}\n\nfunction tile2Lat(tileLat, zoom) {\n  return (360 / Math.PI * Math.atan(Math.pow(Math.E, Math.PI - 2 * Math.PI * tileLat / Math.pow(2, zoom))) - 90).toFixed(10);\n}\n\nmodule.exports = PreviewMap;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/Components/TileExporter/PreviewMap.js\n ** module id = 115\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/Components/TileExporter/PreviewMap.js?")},function(module,exports){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n	var list = [];\r\n\r\n	// return the list of modules as css string\r\n	list.toString = function toString() {\r\n		var result = [];\r\n		for(var i = 0; i < this.length; i++) {\r\n			var item = this[i];\r\n			if(item[2]) {\r\n				result.push("@media " + item[2] + "{" + item[1] + "}");\r\n			} else {\r\n				result.push(item[1]);\r\n			}\r\n		}\r\n		return result.join("");\r\n	};\r\n\r\n	// import a list of modules into the list\r\n	list.i = function(modules, mediaQuery) {\r\n		if(typeof modules === "string")\r\n			modules = [[null, modules, ""]];\r\n		var alreadyImportedModules = {};\r\n		for(var i = 0; i < this.length; i++) {\r\n			var id = this[i][0];\r\n			if(typeof id === "number")\r\n				alreadyImportedModules[id] = true;\r\n		}\r\n		for(i = 0; i < modules.length; i++) {\r\n			var item = modules[i];\r\n			// skip already imported module\r\n			// this implementation is not 100% perfect for weird media query combinations\r\n			//  when a module is imported multiple times with different media queries.\r\n			//  I hope this will never occur (Hey this way we have smaller bundles)\r\n			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n				if(mediaQuery && !item[2]) {\r\n					item[2] = mediaQuery;\r\n				} else if(mediaQuery) {\r\n					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n				}\r\n				list.push(item);\r\n			}\r\n		}\r\n	};\r\n	return list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 116\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?')},function(module,exports){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelize\n * @typechecks\n */\n\n"use strict";\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize(\'background-color\')\n *   < "backgroundColor"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/camelize.js\n ** module id = 117\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/camelize.js?')},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelizeStyleName\n * @typechecks\n */\n\n'use strict';\n\nvar camelize = __webpack_require__(117);\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/camelizeStyleName.js\n ** module id = 118\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/camelizeStyleName.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createArrayFromMixed\n * @typechecks\n */\n\n'use strict';\n\nvar toArray = __webpack_require__(130);\n\n/**\n * Perform a heuristic test to determine if an object is \"array-like\".\n *\n *   A monk asked Joshu, a Zen master, \"Has a dog Buddha nature?\"\n *   Joshu replied: \"Mu.\"\n *\n * This function determines if its argument has \"array nature\": it returns\n * true if the argument is an actual array, an `arguments' object, or an\n * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).\n *\n * It will return false for other array-like objects like Filelist.\n *\n * @param {*} obj\n * @return {boolean}\n */\nfunction hasArrayNature(obj) {\n  return(\n    // not null/false\n    !!obj && (\n    // arrays are objects, NodeLists are functions in Safari\n    typeof obj == 'object' || typeof obj == 'function') &&\n    // quacks like an array\n    'length' in obj &&\n    // not window\n    !('setInterval' in obj) &&\n    // no DOM node should be considered an array-like\n    // a 'select' element has 'length' and 'item' properties on IE8\n    typeof obj.nodeType != 'number' && (\n    // a real array\n    Array.isArray(obj) ||\n    // arguments\n    'callee' in obj ||\n    // HTMLCollection/NodeList\n    'item' in obj)\n  );\n}\n\n/**\n * Ensure that the argument is an array by wrapping it in an array if it is not.\n * Creates a copy of the argument if it is already an array.\n *\n * This is mostly useful idiomatically:\n *\n *   var createArrayFromMixed = require('createArrayFromMixed');\n *\n *   function takesOneOrMoreThings(things) {\n *     things = createArrayFromMixed(things);\n *     ...\n *   }\n *\n * This allows you to treat `things' as an array, but accept scalars in the API.\n *\n * If you need to convert an array-like object, like `arguments`, into an array\n * use toArray instead.\n *\n * @param {*} obj\n * @return {array}\n */\nfunction createArrayFromMixed(obj) {\n  if (!hasArrayNature(obj)) {\n    return [obj];\n  } else if (Array.isArray(obj)) {\n    return obj.slice();\n  } else {\n    return toArray(obj);\n  }\n}\n\nmodule.exports = createArrayFromMixed;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/createArrayFromMixed.js\n ** module id = 119\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/createArrayFromMixed.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createNodesFromMarkup\n * @typechecks\n */\n\n/*eslint-disable fb-www/unsafe-html*/\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar createArrayFromMixed = __webpack_require__(119);\nvar getMarkupWrap = __webpack_require__(65);\nvar invariant = __webpack_require__(2);\n\n/**\n * Dummy container used to render all markup.\n */\nvar dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Pattern used by `getNodeName`.\n */\nvar nodeNamePattern = /^\\s*<(\\w+)/;\n\n/**\n * Extracts the `nodeName` of the first element in a string of markup.\n *\n * @param {string} markup String of markup.\n * @return {?string} Node name of the supplied markup.\n */\nfunction getNodeName(markup) {\n  var nodeNameMatch = markup.match(nodeNamePattern);\n  return nodeNameMatch && nodeNameMatch[1].toLowerCase();\n}\n\n/**\n * Creates an array containing the nodes rendered from the supplied markup. The\n * optionally supplied `handleScript` function will be invoked once for each\n * <script> element that is rendered. If no `handleScript` function is supplied,\n * an exception is thrown if any <script> elements are rendered.\n *\n * @param {string} markup A string of valid HTML markup.\n * @param {?function} handleScript Invoked once for each rendered <script>.\n * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.\n */\nfunction createNodesFromMarkup(markup, handleScript) {\n  var node = dummyNode;\n  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;\n  var nodeName = getNodeName(markup);\n\n  var wrap = nodeName && getMarkupWrap(nodeName);\n  if (wrap) {\n    node.innerHTML = wrap[1] + markup + wrap[2];\n\n    var wrapDepth = wrap[0];\n    while (wrapDepth--) {\n      node = node.lastChild;\n    }\n  } else {\n    node.innerHTML = markup;\n  }\n\n  var scripts = node.getElementsByTagName('script');\n  if (scripts.length) {\n    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;\n    createArrayFromMixed(scripts).forEach(handleScript);\n  }\n\n  var nodes = createArrayFromMixed(node.childNodes);\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n  return nodes;\n}\n\nmodule.exports = createNodesFromMarkup;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/createNodesFromMarkup.js\n ** module id = 120\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/createNodesFromMarkup.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getUnboundedScrollPosition\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Gets the scroll position of the supplied element or window.\n *\n * The return values are unbounded, unlike `getScrollPosition`. This means they\n * may be negative or exceed the element boundaries (which is possible using\n * inertial scrolling).\n *\n * @param {DOMWindow|DOMElement} scrollable\n * @return {object} Map with `x` and `y` keys.\n */\nfunction getUnboundedScrollPosition(scrollable) {\n  if (scrollable === window) {\n    return {\n      x: window.pageXOffset || document.documentElement.scrollLeft,\n      y: window.pageYOffset || document.documentElement.scrollTop\n    };\n  }\n  return {\n    x: scrollable.scrollLeft,\n    y: scrollable.scrollTop\n  };\n}\n\nmodule.exports = getUnboundedScrollPosition;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/getUnboundedScrollPosition.js\n ** module id = 121\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/getUnboundedScrollPosition.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenate\n * @typechecks\n */\n\n'use strict';\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/hyphenate.js\n ** module id = 122\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/hyphenate.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenateStyleName\n * @typechecks\n */\n\n'use strict';\n\nvar hyphenate = __webpack_require__(122);\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/hyphenateStyleName.js\n ** module id = 123\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/hyphenateStyleName.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isNode\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\n'use strict';\n\nfunction isNode(object) {\n  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/isNode.js\n ** module id = 124\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/isNode.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextNode\n * @typechecks\n */\n\n'use strict';\n\nvar isNode = __webpack_require__(124);\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/isTextNode.js\n ** module id = 125\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/isTextNode.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule mapObject\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Executes the provided `callback` once for each enumerable own property in the\n * object and constructs a new object from the results. The `callback` is\n * invoked with three arguments:\n *\n *  - the property value\n *  - the property name\n *  - the object being traversed\n *\n * Properties that are added after the call to `mapObject` will not be visited\n * by `callback`. If the values of existing properties are changed, the value\n * passed to `callback` will be the value at the time `mapObject` visits them.\n * Properties that are deleted before being visited are not visited.\n *\n * @grep function objectMap()\n * @grep function objMap()\n *\n * @param {?object} object\n * @param {function} callback\n * @param {*} context\n * @return {?object}\n */\nfunction mapObject(object, callback, context) {\n  if (!object) {\n    return null;\n  }\n  var result = {};\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result[name] = callback.call(context, object[name], name, object);\n    }\n  }\n  return result;\n}\n\nmodule.exports = mapObject;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/mapObject.js\n ** module id = 126\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/mapObject.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule memoizeStringOnly\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Memoizes the return value of a function that accepts one string argument.\n *\n * @param {function} callback\n * @return {function}\n */\nfunction memoizeStringOnly(callback) {\n  var cache = {};\n  return function (string) {\n    if (!cache.hasOwnProperty(string)) {\n      cache[string] = callback.call(this, string);\n    }\n    return cache[string];\n  };\n}\n\nmodule.exports = memoizeStringOnly;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/memoizeStringOnly.js\n ** module id = 127\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/memoizeStringOnly.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule performance\n * @typechecks\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar performance;\n\nif (ExecutionEnvironment.canUseDOM) {\n  performance = window.performance || window.msPerformance || window.webkitPerformance;\n}\n\nmodule.exports = performance || {};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/performance.js\n ** module id = 128\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/performance.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule performanceNow\n * @typechecks\n */\n\n'use strict';\n\nvar performance = __webpack_require__(128);\n\nvar performanceNow;\n\n/**\n * Detect if we can use `window.performance.now()` and gracefully fallback to\n * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now\n * because of Facebook's testing infrastructure.\n */\nif (performance.now) {\n  performanceNow = function () {\n    return performance.now();\n  };\n} else {\n  performanceNow = function () {\n    return Date.now();\n  };\n}\n\nmodule.exports = performanceNow;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/performanceNow.js\n ** module id = 129\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/performanceNow.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule toArray\n * @typechecks\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Convert array-like objects to arrays.\n *\n * This API assumes the caller knows the contents of the data type. For less\n * well defined inputs use createArrayFromMixed.\n *\n * @param {object|function|filelist} obj\n * @return {array}\n */\nfunction toArray(obj) {\n  var length = obj.length;\n\n  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in\n  // old versions of Safari).\n  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;\n\n  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;\n\n  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;\n\n  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs\n  // without method will throw during the slice call and skip straight to the\n  // fallback.\n  if (obj.hasOwnProperty) {\n    try {\n      return Array.prototype.slice.call(obj);\n    } catch (e) {\n      // IE < 9 does not support Array#slice on collections objects\n    }\n  }\n\n  // Fall back to copying key by key. This assumes all keys have a value,\n  // so will not preserve sparsely populated inputs.\n  var ret = Array(length);\n  for (var ii = 0; ii < length; ii++) {\n    ret[ii] = obj[ii];\n  }\n  return ret;\n}\n\nmodule.exports = toArray;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fbjs/lib/toArray.js\n ** module id = 130\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/fbjs/lib/toArray.js?")},function(module,exports,__webpack_require__){eval("module.exports = {\n  XmlEntities: __webpack_require__(133),\n  Html4Entities: __webpack_require__(132),\n  Html5Entities: __webpack_require__(67),\n  AllHtmlEntities: __webpack_require__(67)\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/html-entities/index.js\n ** module id = 131\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/html-entities/index.js?")},function(module,exports){eval("var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'Oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'oelig', 'oelig', 'scaron', 'scaron', 'yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];\nvar HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];\n\nvar alphaIndex = {};\nvar numIndex = {};\n\nvar i = 0;\nvar length = HTML_ALPHA.length;\nwhile (i < length) {\n    var a = HTML_ALPHA[i];\n    var c = HTML_CODES[i];\n    alphaIndex[a] = String.fromCharCode(c);\n    numIndex[c] = a;\n    i++;\n}\n\n/**\n * @constructor\n */\nfunction Html4Entities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.decode = function(str) {\n    if (str.length === 0) {\n        return '';\n    }\n    return str.replace(/&(#?[\\w\\d]+);?/g, function(s, entity) {\n        var chr;\n        if (entity.charAt(0) === \"#\") {\n            var code = entity.charAt(1).toLowerCase() === 'x' ?\n                parseInt(entity.substr(2), 16) :\n                parseInt(entity.substr(1));\n\n            if (!(isNaN(code) || code < -32768 || code > 65535)) {\n                chr = String.fromCharCode(code);\n            }\n        } else {\n            chr = alphaIndex[entity];\n        }\n        return chr || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.decode = function(str) {\n    return new Html4Entities().decode(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encode = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var alpha = numIndex[str.charCodeAt(i)];\n        result += alpha ? \"&\" + alpha + \";\" : str.charAt(i);\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encode = function(str) {\n    return new Html4Entities().encode(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encodeNonUTF = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var cc = str.charCodeAt(i);\n        var alpha = numIndex[cc];\n        if (alpha) {\n            result += \"&\" + alpha + \";\";\n        } else if (cc < 32 || cc > 126) {\n            result += \"&#\" + cc + \";\";\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encodeNonUTF = function(str) {\n    return new Html4Entities().encodeNonUTF(str);\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.prototype.encodeNonASCII = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\nHtml4Entities.encodeNonASCII = function(str) {\n    return new Html4Entities().encodeNonASCII(str);\n};\n\nmodule.exports = Html4Entities;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/html-entities/lib/html4-entities.js\n ** module id = 132\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/html-entities/lib/html4-entities.js?");
},function(module,exports){eval("var ALPHA_INDEX = {\n    '&lt': '<',\n    '&gt': '>',\n    '&quot': '\"',\n    '&apos': '\\'',\n    '&amp': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&apos;': '\\'',\n    '&amp;': '&'\n};\n\nvar CHAR_INDEX = {\n    60: 'lt',\n    62: 'gt',\n    34: 'quot',\n    39: 'apos',\n    38: 'amp'\n};\n\nvar CHAR_S_INDEX = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&apos;',\n    '&': '&amp;'\n};\n\n/**\n * @constructor\n */\nfunction XmlEntities() {}\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encode = function(str) {\n    if (str.length === 0) {\n        return '';\n    }\n    return str.replace(/<|>|\"|'|&/g, function(s) {\n        return CHAR_S_INDEX[s];\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encode = function(str) {\n    return new XmlEntities().encode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.decode = function(str) {\n    if (str.length === 0) {\n        return '';\n    }\n    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {\n        if (s.charAt(1) === '#') {\n            var code = s.charAt(2).toLowerCase() === 'x' ?\n                parseInt(s.substr(3), 16) :\n                parseInt(s.substr(2));\n\n            if (isNaN(code) || code < -32768 || code > 65535) {\n                return '';\n            }\n            return String.fromCharCode(code);\n        }\n        return ALPHA_INDEX[s] || s;\n    });\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.decode = function(str) {\n    return new XmlEntities().decode(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encodeNonUTF = function(str) {\n    var strLength = str.length;\n    if (strLength === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLength) {\n        var c = str.charCodeAt(i);\n        var alpha = CHAR_INDEX[c];\n        if (alpha) {\n            result += \"&\" + alpha + \";\";\n            i++;\n            continue;\n        }\n        if (c < 32 || c > 126) {\n            result += '&#' + c + ';';\n        } else {\n            result += str.charAt(i);\n        }\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encodeNonUTF = function(str) {\n    return new XmlEntities().encodeNonUTF(str);\n };\n\n/**\n * @param {String} str\n * @returns {String}\n */\nXmlEntities.prototype.encodeNonASCII = function(str) {\n    var strLenght = str.length;\n    if (strLenght === 0) {\n        return '';\n    }\n    var result = '';\n    var i = 0;\n    while (i < strLenght) {\n        var c = str.charCodeAt(i);\n        if (c <= 255) {\n            result += str[i++];\n            continue;\n        }\n        result += '&#' + c + ';';\n        i++;\n    }\n    return result;\n};\n\n/**\n * @param {String} str\n * @returns {String}\n */\n XmlEntities.encodeNonASCII = function(str) {\n    return new XmlEntities().encodeNonASCII(str);\n };\n\nmodule.exports = XmlEntities;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/html-entities/lib/xml-entities.js\n ** module id = 133\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/html-entities/lib/xml-entities.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n * @license\n * lodash 3.10.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -d -o ./index.js`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '3.10.1';\n\n  /** Used to compose bitmasks for wrapper metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256;\n\n  /** Used as default options for `_.trunc`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect when a function becomes hot. */\n  var HOT_COUNT = 150,\n      HOT_SPAN = 16;\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reUnescapedHtml = /[&<>\"'`]/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n  /**\n   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)\n   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).\n   */\n  var reRegExpChars = /^[:!,]|[\\\\^$.*+?()[\\]{}|\\/]|(^[0-9a-fA-Fnrtuvx])|([\\n\\r\\u2028\\u2029])/g,\n      reHasRegExpChars = RegExp(reRegExpChars.source);\n\n  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n  var reComboMark = /[\\u0300-\\u036f\\ufe20-\\ufe23]/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect hexadecimal string values. */\n  var reHasHexPrefix = /^0[xX]/;\n\n  /** Used to detect host constructors (Safari > 5). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^\\d+$/;\n\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to match words to create compound words. */\n  var reWords = (function() {\n    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\n    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n  }());\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',\n    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[mapTag] = cloneableTags[setTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\n  var deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled regexes. */\n  var regexpEscapes = {\n    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',\n    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',\n    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',\n    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',\n    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\n\n  /** Detect free variable `window`. */\n  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /**\n   * Used as a reference to the global object.\n   *\n   * The `this` value is used if it's the global object to avoid Greasemonkey's\n   * restricted `window` object, otherwise the `window` object is used.\n   */\n  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `compareAscending` which compares values and\n   * sorts them in ascending order without guaranteeing a stable sort.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function baseCompareAscending(value, other) {\n    if (value !== other) {\n      var valIsNull = value === null,\n          valIsUndef = value === undefined,\n          valIsReflexive = value === value;\n\n      var othIsNull = other === null,\n          othIsUndef = other === undefined,\n          othIsReflexive = other === other;\n\n      if ((value > other && !othIsNull) || !valIsReflexive ||\n          (valIsNull && !othIsUndef && othIsReflexive) ||\n          (valIsUndef && othIsReflexive)) {\n        return 1;\n      }\n      if ((value < other && !valIsNull) || !othIsReflexive ||\n          (othIsNull && !valIsUndef && valIsReflexive) ||\n          (othIsUndef && valIsReflexive)) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromRight) {\n    var length = array.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isFunction` without support for environments\n   * with incorrect `typeof` results.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n   */\n  function baseIsFunction(value) {\n    // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n    // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n    return typeof value == 'function' || false;\n  }\n\n  /**\n   * Converts `value` to a string if it's not one. An empty string is returned\n   * for `null` or `undefined` values.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    return value == null ? '' : (value + '');\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the first character not found in `chars`.\n   */\n  function charsLeftIndex(string, chars) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the last character not found in `chars`.\n   */\n  function charsRightIndex(string, chars) {\n    var index = string.length;\n\n    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n   * sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareAscending(object, other) {\n    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n  }\n\n  /**\n   * Used by `_.sortByOrder` to compare multiple properties of a value to another\n   * and stable sort them.\n   *\n   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,\n   * a value is sorted in ascending order if its corresponding order is \"asc\", and\n   * descending if \"desc\".\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {boolean[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n        var order = orders[index];\n        return result * ((order === 'asc' || order === true) ? 1 : -1);\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  /**\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @param {string} leadingChar The capture group for a leading character.\n   * @param {string} whitespaceChar The capture group for a whitespace character.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {\n    if (leadingChar) {\n      chr = regexpEscapes[chr];\n    } else if (whitespaceChar) {\n      chr = stringEscapes[chr];\n    }\n    return '\\\\' + chr;\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 0 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is object-like.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n   * character code is whitespace.\n   *\n   * @private\n   * @param {number} charCode The character code to inspect.\n   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n   */\n  function isSpace(charCode) {\n    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      if (array[index] === placeholder) {\n        array[index] = PLACEHOLDER;\n        result[++resIndex] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * An implementation of `_.uniq` optimized for sorted arrays without support\n   * for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The function invoked per iteration.\n   * @returns {Array} Returns the new duplicate-value-free array.\n   */\n  function sortedUniq(array, iteratee) {\n    var seen,\n        index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value, index, array) : value;\n\n      if (!index || seen !== computed) {\n        seen = computed;\n        result[++resIndex] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the first non-whitespace character.\n   */\n  function trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedRightIndex(string) {\n    var index = string.length;\n\n    while (index-- && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the given `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utility\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // using `context` to mock `Date#getTime` use in `_.now`\n   * var mock = _.runInContext({\n   *   'Date': function() {\n   *     return { 'getTime': getTimeMock };\n   *   }\n   * });\n   *\n   * // or creating a suped-up `defer` in Node.js\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See https://es5.github.io/#x11.1.5 for more details.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for native method references. */\n    var arrayProto = Array.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to resolve the decompiled source of functions. */\n    var fnToString = Function.prototype.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Native method references. */\n    var ArrayBuffer = context.ArrayBuffer,\n        clearTimeout = context.clearTimeout,\n        parseFloat = context.parseFloat,\n        pow = Math.pow,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        Set = getNative(context, 'Set'),\n        setTimeout = context.setTimeout,\n        splice = arrayProto.splice,\n        Uint8Array = context.Uint8Array,\n        WeakMap = getNative(context, 'WeakMap');\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeCreate = getNative(Object, 'create'),\n        nativeFloor = Math.floor,\n        nativeIsArray = getNative(Array, 'isArray'),\n        nativeIsFinite = context.isFinite,\n        nativeKeys = getNative(Object, 'keys'),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = getNative(Date, 'now'),\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used as references for `-Infinity` and `Infinity`. */\n    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n    /** Used as references for the maximum length and index of an array. */\n    var MAX_ARRAY_LENGTH = 4294967295,\n        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n    /**\n     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n     * of an array-like value.\n     */\n    var MAX_SAFE_INTEGER = 9007199254740991;\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n     * Methods that operate on and return arrays, collections, and functions can\n     * be chained together. Methods that retrieve a single value or may return a\n     * primitive value will automatically end the chain returning the unwrapped\n     * value. Explicit chaining may be enabled using `_.chain`. The execution of\n     * chained methods is lazy, that is, execution is deferred until `_#value`\n     * is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n     * fusion is an optimization strategy which merge iteratee calls; this can help\n     * to avoid the creation of intermediate data structures and greatly reduce the\n     * number of iteratee executions.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n     * `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n     * and `where`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n     * `unescape`, `uniqueId`, `value`, and `words`\n     *\n     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n     * otherwise an unwrapped value is returned.\n     *\n     * @name _\n     * @constructor\n     * @category Chain\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(total, n) {\n     *   return total + n;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(n) {\n     *   return n * n;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The function whose prototype all chaining wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n     */\n    function LodashWrapper(value, chainAll, actions) {\n      this.__wrapped__ = value;\n      this.__actions__ = actions || [];\n      this.__chain__ = !!chainAll;\n    }\n\n    /**\n     * An object environment feature flags.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = POSITIVE_INFINITY;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = arrayCopy(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = arrayCopy(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = arrayCopy(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     *\n     * @private\n     * @static\n     * @name Cache\n     * @memberOf _.memoize\n     */\n    function MapCache() {\n      this.__data__ = {};\n    }\n\n    /**\n     * Removes `key` and its value from the cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n     */\n    function mapDelete(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n\n    /**\n     * Gets the cached value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the cached value.\n     */\n    function mapGet(key) {\n      return key == '__proto__' ? undefined : this.__data__[key];\n    }\n\n    /**\n     * Checks if a cached value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapHas(key) {\n      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n    }\n\n    /**\n     * Sets `value` to `key` of the cache.\n     *\n     * @private\n     * @name set\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to cache.\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache object.\n     */\n    function mapSet(key, value) {\n      if (key != '__proto__') {\n        this.__data__[key] = value;\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates a cache object to store unique values.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var length = values ? values.length : 0;\n\n      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n      while (length--) {\n        this.push(values[length]);\n      }\n    }\n\n    /**\n     * Checks if `value` is in `cache` mimicking the return signature of\n     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n     *\n     * @private\n     * @param {Object} cache The cache to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `0` if `value` is found, else `-1`.\n     */\n    function cacheIndexOf(cache, value) {\n      var data = cache.data,\n          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n      return result ? 0 : -1;\n    }\n\n    /**\n     * Adds `value` to the cache.\n     *\n     * @private\n     * @name push\n     * @memberOf SetCache\n     * @param {*} value The value to cache.\n     */\n    function cachePush(value) {\n      var data = this.data;\n      if (typeof value == 'string' || isObject(value)) {\n        data.set.add(value);\n      } else {\n        data.hash[value] = true;\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a new array joining `array` with `other`.\n     *\n     * @private\n     * @param {Array} array The array to join.\n     * @param {Array} other The other array to join.\n     * @returns {Array} Returns the new concatenated array.\n     */\n    function arrayConcat(array, other) {\n      var index = -1,\n          length = array.length,\n          othIndex = -1,\n          othLength = other.length,\n          result = Array(length + othLength);\n\n      while (++index < length) {\n        result[index] = array[index];\n      }\n      while (++othIndex < othLength) {\n        result[index++] = other[othIndex];\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayCopy(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEach` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEachRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEachRight(array, iteratee) {\n      var length = array.length;\n\n      while (length--) {\n        if (iteratee(array[length], length, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.every` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     */\n    function arrayEvery(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`\n     * with one argument: (value).\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function arrayExtremum(array, iteratee, comparator, exValue) {\n      var index = -1,\n          length = array.length,\n          computed = exValue,\n          result = computed;\n\n      while (++index < length) {\n        var value = array[index],\n            current = +iteratee(value);\n\n        if (comparator(current, computed)) {\n          computed = current;\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.filter` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function arrayFilter(array, predicate) {\n      var index = -1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.map` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function arrayMap(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n\n    /**\n     * Appends the elements of `values` to `array`.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to append.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayPush(array, values) {\n      var index = -1,\n          length = values.length,\n          offset = array.length;\n\n      while (++index < length) {\n        array[offset + index] = values[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.reduce` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the first element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n      var index = -1,\n          length = array.length;\n\n      if (initFromArray && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.reduceRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the last element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n      var length = array.length;\n      if (initFromArray && length) {\n        accumulator = array[--length];\n      }\n      while (length--) {\n        accumulator = iteratee(accumulator, array[length], length, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.some` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function arraySome(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `_.sum` for arrays without support for callback\n     * shorthands and `this` binding..\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function arraySum(array, iteratee) {\n      var length = array.length,\n          result = 0;\n\n      while (length--) {\n        result += +iteratee(array[length]) || 0;\n      }\n      return result;\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assign` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignDefaults(objectValue, sourceValue) {\n      return objectValue === undefined ? sourceValue : objectValue;\n    }\n\n    /**\n     * Used by `_.template` to customize its `_.assign` use.\n     *\n     * **Note:** This function is like `assignDefaults` except that it ignores\n     * inherited property values when checking if a property is `undefined`.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @param {string} key The key associated with the object and source values.\n     * @param {Object} object The destination object.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n      return (objectValue === undefined || !hasOwnProperty.call(object, key))\n        ? sourceValue\n        : objectValue;\n    }\n\n    /**\n     * A specialized version of `_.assign` for customizing assigned values without\n     * support for argument juggling, multiple sources, and `this` binding `customizer`\n     * functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     */\n    function assignWith(object, source, customizer) {\n      var index = -1,\n          props = keys(source),\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key],\n            result = customizer(value, source[key], key, object, source);\n\n        if ((result === result ? (result !== value) : (value === value)) ||\n            (value === undefined && !(key in object))) {\n          object[key] = result;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for argument juggling,\n     * multiple sources, and `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return source == null\n        ? object\n        : baseCopy(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.at` without support for string collections\n     * and individual key arguments.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {number[]|string[]} props The property names or indexes of elements to pick.\n     * @returns {Array} Returns the new array of picked elements.\n     */\n    function baseAt(collection, props) {\n      var index = -1,\n          isNil = collection == null,\n          isArr = !isNil && isArrayLike(collection),\n          length = isArr ? collection.length : 0,\n          propsLength = props.length,\n          result = Array(propsLength);\n\n      while(++index < propsLength) {\n        var key = props[index];\n        if (isArr) {\n          result[index] = isIndex(key, length) ? collection[key] : undefined;\n        } else {\n          result[index] = isNil ? undefined : collection[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @returns {Object} Returns `object`.\n     */\n    function baseCopy(source, props, object) {\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        object[key] = source[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.callback` which supports specifying the\n     * number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function baseCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (type == 'function') {\n        return thisArg === undefined\n          ? func\n          : bindCallback(func, thisArg, argCount);\n      }\n      if (func == null) {\n        return identity;\n      }\n      if (type == 'object') {\n        return baseMatches(func);\n      }\n      return thisArg === undefined\n        ? property(func)\n        : baseMatchesProperty(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `_.clone` without support for argument juggling\n     * and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The object `value` belongs to.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return arrayCopy(value, result);\n        }\n      } else {\n        var tag = objToString.call(value),\n            isFunc = tag == funcTag;\n\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return baseAssign(result, value);\n          }\n        } else {\n          return cloneableTags[tag]\n            ? initCloneByTag(value, tag, isDeep)\n            : (object ? value : {});\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length];\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate it with its clone.\n      stackA.push(value);\n      stackB.push(result);\n\n      // Recursively populate clone (susceptible to call stack limits).\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(prototype) {\n        if (isObject(prototype)) {\n          object.prototype = prototype;\n          var result = new object;\n          object.prototype = undefined;\n        }\n        return result || {};\n      };\n    }());\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts an index\n     * of where to slice the arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Object} args The arguments provide to `func`.\n     * @returns {number} Returns the timer id.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of `_.difference` which accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var length = array ? array.length : 0,\n          result = [];\n\n      if (!length) {\n        return result;\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n          valuesLength = values.length;\n\n      if (cache) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n        values = cache;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index];\n\n        if (isCommon && value === value) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === value) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (indexOf(values, value, 0) < 0) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the extremum value of `collection` invoking `iteratee` for each value\n     * in `collection` to generate the criterion by which the value is ranked.\n     * The `iteratee` is invoked with three arguments: (value, index|key, collection).\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(collection, iteratee, comparator, exValue) {\n      var computed = exValue,\n          result = computed;\n\n      baseEach(collection, function(value, index, collection) {\n        var current = +iteratee(value, index, collection);\n        if (comparator(current, computed) || (current === exValue && current === result)) {\n          computed = current;\n          result = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : (end >>> 0);\n      start >>>= 0;\n\n      while (start < length) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n     * without support for callback shorthands and `this` binding, which iterates\n     * over `collection` using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @param {boolean} [retKey] Specify returning the key of the found element\n     *  instead of the element itself.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFind(collection, predicate, eachFunc, retKey) {\n      var result;\n      eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n          result = retKey ? key : value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with added support for restricting\n     * flattening and specifying the start index.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isDeep, isStrict, result) {\n      result || (result = []);\n\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index];\n        if (isObjectLike(value) && isArrayLike(value) &&\n            (isStrict || isArray(value) || isArguments(value))) {\n          if (isDeep) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, isDeep, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n      return baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from those provided.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the new array of filtered property names.\n     */\n    function baseFunctions(object, props) {\n      var index = -1,\n          length = props.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var key = props[index];\n        if (isFunction(object[key])) {\n          result[++resIndex] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `get` without support for string paths\n     * and default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path of the property to get.\n     * @param {string} [pathKey] The key representation of path.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path, pathKey) {\n      if (object == null) {\n        return;\n      }\n      if (pathKey !== undefined && pathKey in toObject(object)) {\n        path = [pathKey];\n      }\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[path[index++]];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` without support for `this` binding\n     * `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = objToString.call(object);\n        if (objTag == argsTag) {\n          objTag = objectTag;\n        } else if (objTag != objectTag) {\n          objIsArr = isTypedArray(object);\n        }\n      }\n      if (!othIsArr) {\n        othTag = objToString.call(other);\n        if (othTag == argsTag) {\n          othTag = objectTag;\n        } else if (othTag != objectTag) {\n          othIsArr = isTypedArray(other);\n        }\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !(objIsArr || objIsObj)) {\n        return equalByTag(object, other, objTag);\n      }\n      if (!isLoose) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      // For more information on detecting circular references see https://es5.github.io/#JO.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == object) {\n          return stackB[length] == other;\n        }\n      }\n      // Add `object` and `other` to the stack of traversed objects.\n      stackA.push(object);\n      stackB.push(other);\n\n      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n      stackA.pop();\n      stackB.pop();\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} matchData The propery names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = toObject(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which does not clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        var key = matchData[0][0],\n            value = matchData[0][1];\n\n        return function(object) {\n          if (object == null) {\n            return false;\n          }\n          return object[key] === value && (value !== undefined || (key in toObject(object)));\n        };\n      }\n      return function(object) {\n        return baseIsMatch(object, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to compare.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      var isArr = isArray(path),\n          isCommon = isKey(path) && isStrictComparable(srcValue),\n          pathKey = (path + '');\n\n      path = toPath(path);\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        var key = pathKey;\n        object = toObject(object);\n        if ((isArr || !isCommon) && !(key in object)) {\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          if (object == null) {\n            return false;\n          }\n          key = last(path);\n          object = toObject(object);\n        }\n        return object[key] === srcValue\n          ? (srcValue !== undefined || (key in object))\n          : baseIsEqual(srcValue, object[key], undefined, true);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {Object} Returns `object`.\n     */\n    function baseMerge(object, source, customizer, stackA, stackB) {\n      if (!isObject(object)) {\n        return object;\n      }\n      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n          props = isSrcArr ? undefined : keys(source);\n\n      arrayEach(props || source, function(srcValue, key) {\n        if (props) {\n          key = srcValue;\n          srcValue = source[key];\n        }\n        if (isObjectLike(srcValue)) {\n          stackA || (stackA = []);\n          stackB || (stackB = []);\n          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n        }\n        else {\n          var value = object[key],\n              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n              isCommon = result === undefined;\n\n          if (isCommon) {\n            result = srcValue;\n          }\n          if ((result !== undefined || (isSrcArr && !(key in object))) &&\n              (isCommon || (result === result ? (result !== value) : (value === value)))) {\n            object[key] = result;\n          }\n        }\n      });\n      return object;\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n      var length = stackA.length,\n          srcValue = source[key];\n\n      while (length--) {\n        if (stackA[length] == srcValue) {\n          object[key] = stackB[length];\n          return;\n        }\n      }\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = result === undefined;\n\n      if (isCommon) {\n        result = srcValue;\n        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n          result = isArray(value)\n            ? value\n            : (isArrayLike(value) ? arrayCopy(value) : []);\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          result = isArguments(value)\n            ? toPlainObject(value)\n            : (isPlainObject(value) ? value : {});\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate\n      // it with its merged value.\n      stackA.push(srcValue);\n      stackB.push(result);\n\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n      } else if (result === result ? (result !== value) : (value === value)) {\n        object[key] = result;\n      }\n    }\n\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function basePropertyDeep(path) {\n      var pathKey = (path + '');\n      path = toPath(path);\n      return function(object) {\n        return baseGet(object, path, pathKey);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * index arguments and capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0;\n      while (length--) {\n        var index = indexes[length];\n        if (index != previous && isIndex(index)) {\n          var previous = index;\n          splice.call(array, index, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for argument juggling\n     * and returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(min, max) {\n      return min + nativeFloor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.reduce` and `_.reduceRight` without support\n     * for callback shorthands and `this` binding, which iterates over `collection`\n     * using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} accumulator The initial value.\n     * @param {boolean} initFromCollection Specify using the first or last element\n     *  of `collection` as the initial value.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the accumulated value.\n     */\n    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n      eachFunc(collection, function(value, index, collection) {\n        accumulator = initFromCollection\n          ? (initFromCollection = false, value)\n          : iteratee(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop detection.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortBy` which uses `comparer` to define\n     * the sort order of `array` and replaces criteria objects with their\n     * corresponding values.\n     *\n     * @private\n     * @param {Array} array The array to sort.\n     * @param {Function} comparer The function to define sort order.\n     * @returns {Array} Returns `array`.\n     */\n    function baseSortBy(array, comparer) {\n      var length = array.length;\n\n      array.sort(comparer);\n      while (length--) {\n        array[length] = array[length].value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.sortByOrder` without param guards.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseSortByOrder(collection, iteratees, orders) {\n      var callback = getCallback(),\n          index = -1;\n\n      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });\n\n      var result = baseMap(collection, function(value) {\n        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.sum` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function baseSum(collection, iteratee) {\n      var result = 0;\n      baseEach(collection, function(value, index, collection) {\n        result += +iteratee(value, index, collection) || 0;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The function invoked per iteration.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     */\n    function baseUniq(array, iteratee) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array.length,\n          isCommon = indexOf == baseIndexOf,\n          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n          seen = isLarge ? createCache() : null,\n          result = [];\n\n      if (seen) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n      } else {\n        isLarge = false;\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value, index, array) : value;\n\n        if (isCommon && value === value) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (indexOf(seen, computed, 0) < 0) {\n          if (iteratee || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * of `props`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, props) {\n      var index = -1,\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,\n     * and `_.takeWhile` without support for callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      var index = -1,\n          length = actions.length;\n\n      while (++index < length) {\n        var action = actions[index];\n        result = action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }\n      return result;\n    }\n\n    /**\n     * Performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return binaryIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * This function is like `binaryIndex` except that it invokes `iteratee` for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsUndef = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            isDef = computed !== undefined,\n            isReflexive = computed === computed;\n\n        if (valIsNaN) {\n          var setLow = isReflexive || retHighest;\n        } else if (valIsNull) {\n          setLow = isReflexive && isDef && (retHighest || computed != null);\n        } else if (valIsUndef) {\n          setLow = isReflexive && (retHighest || isDef);\n        } else if (computed == null) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * A specialized version of `baseCallback` which only supports `this` binding\n     * and specifying the number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function bindCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      if (thisArg === undefined) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n        case 5: return function(value, other, key, object, source) {\n          return func.call(thisArg, value, other, key, object, source);\n        };\n      }\n      return function() {\n        return func.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * Creates a clone of the given array buffer.\n     *\n     * @private\n     * @param {ArrayBuffer} buffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function bufferClone(buffer) {\n      var result = new ArrayBuffer(buffer.byteLength),\n          view = new Uint8Array(result);\n\n      view.set(new Uint8Array(buffer));\n      return result;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders) {\n      var holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partials.length,\n          result = Array(leftLength + argsLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders) {\n      var holdersIndex = -1,\n          holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partials.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[offset + holders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n     *\n     * @private\n     * @param {Function} setter The function to set keys and values of the accumulator object.\n     * @param {Function} [initializer] The function to initialize the accumulator object.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee, thisArg) {\n        var result = initializer ? initializer() : {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, iteratee(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, iteratee(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return restParam(function(object, sources) {\n        var index = -1,\n            length = object == null ? 0 : sources.length,\n            customizer = length > 2 ? sources[length - 2] : undefined,\n            guard = length > 2 ? sources[2] : undefined,\n            thisArg = length > 1 ? sources[length - 1] : undefined;\n\n        if (typeof customizer == 'function') {\n          customizer = bindCallback(customizer, thisArg, 5);\n          length -= 2;\n        } else {\n          customizer = typeof thisArg == 'function' ? thisArg : undefined;\n          length -= (customizer ? 1 : 0);\n        }\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        var length = collection ? getLength(collection) : 0;\n        if (!isLength(length)) {\n          return eachFunc(collection, iteratee);\n        }\n        var index = fromRight ? length : -1,\n            iterable = toObject(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var iterable = toObject(object),\n            props = keysFunc(object),\n            length = props.length,\n            index = fromRight ? length : -1;\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var key = props[index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createBindWrapper(func, thisArg) {\n      var Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(thisArg, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `Set` cache object to optimize linear searches of large arrays.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n     */\n    function createCache(values) {\n      return (nativeCreate && Set) ? new SetCache(values) : null;\n    }\n\n    /**\n     * Creates a function that produces compound words out of the words in a\n     * given string.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        var index = -1,\n            array = words(deburr(string)),\n            length = array.length,\n            result = '';\n\n        while (++index < length) {\n          result = callback(result, array[index], index);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtorWrapper(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors.\n        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a `_.curry` or `_.curryRight` function.\n     *\n     * @private\n     * @param {boolean} flag The curry bit flag.\n     * @returns {Function} Returns the new curry function.\n     */\n    function createCurry(flag) {\n      function curryFunc(func, arity, guard) {\n        if (guard && isIterateeCall(func, arity, guard)) {\n          arity = undefined;\n        }\n        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);\n        result.placeholder = curryFunc.placeholder;\n        return result;\n      }\n      return curryFunc;\n    }\n\n    /**\n     * Creates a `_.defaults` or `_.defaultsDeep` function.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Function} Returns the new defaults function.\n     */\n    function createDefaults(assigner, customizer) {\n      return restParam(function(args) {\n        var object = args[0];\n        if (object == null) {\n          return object;\n        }\n        args.push(customizer);\n        return assigner.apply(undefined, args);\n      });\n    }\n\n    /**\n     * Creates a `_.max` or `_.min` function.\n     *\n     * @private\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {Function} Returns the new extremum function.\n     */\n    function createExtremum(comparator, exValue) {\n      return function(collection, iteratee, thisArg) {\n        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n          iteratee = undefined;\n        }\n        iteratee = getCallback(iteratee, thisArg, 3);\n        if (iteratee.length == 1) {\n          collection = isArray(collection) ? collection : toIterable(collection);\n          var result = arrayExtremum(collection, iteratee, comparator, exValue);\n          if (!(collection.length && result === exValue)) {\n            return result;\n          }\n        }\n        return baseExtremum(collection, iteratee, comparator, exValue);\n      };\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(eachFunc, fromRight) {\n      return function(collection, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        if (isArray(collection)) {\n          var index = baseFindIndex(collection, predicate, fromRight);\n          return index > -1 ? collection[index] : undefined;\n        }\n        return baseFind(collection, predicate, eachFunc);\n      };\n    }\n\n    /**\n     * Creates a `_.findIndex` or `_.findLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindIndex(fromRight) {\n      return function(array, predicate, thisArg) {\n        if (!(array && array.length)) {\n          return -1;\n        }\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFindIndex(array, predicate, fromRight);\n      };\n    }\n\n    /**\n     * Creates a `_.findKey` or `_.findLastKey` function.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindKey(objectFunc) {\n      return function(object, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFind(object, predicate, objectFunc, true);\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return function() {\n        var wrapper,\n            length = arguments.length,\n            index = fromRight ? length : -1,\n            leftIndex = 0,\n            funcs = Array(length);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var func = funcs[leftIndex++] = arguments[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {\n            wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? -1 : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      };\n    }\n\n    /**\n     * Creates a function for `_.forEach` or `_.forEachRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForEach(arrayFunc, eachFunc) {\n      return function(collection, iteratee, thisArg) {\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee)\n          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n      };\n    }\n\n    /**\n     * Creates a function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForIn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee, keysIn);\n      };\n    }\n\n    /**\n     * Creates a function for `_.forOwn` or `_.forOwnRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForOwn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee);\n      };\n    }\n\n    /**\n     * Creates a function for `_.mapKeys` or `_.mapValues`.\n     *\n     * @private\n     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.\n     * @returns {Function} Returns the new map function.\n     */\n    function createObjectMapper(isMapKeys) {\n      return function(object, iteratee, thisArg) {\n        var result = {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        baseForOwn(object, function(value, key, object) {\n          var mapped = iteratee(value, key, object);\n          key = isMapKeys ? mapped : key;\n          value = isMapKeys ? value : mapped;\n          result[key] = value;\n        });\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function for `_.padLeft` or `_.padRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify padding from the right.\n     * @returns {Function} Returns the new pad function.\n     */\n    function createPadDir(fromRight) {\n      return function(string, length, chars) {\n        string = baseToString(string);\n        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);\n      };\n    }\n\n    /**\n     * Creates a `_.partial` or `_.partialRight` function.\n     *\n     * @private\n     * @param {boolean} flag The partial bit flag.\n     * @returns {Function} Returns the new partial function.\n     */\n    function createPartial(flag) {\n      var partialFunc = restParam(function(func, partials) {\n        var holders = replaceHolders(partials, partialFunc.placeholder);\n        return createWrapper(func, flag, undefined, partials, holders);\n      });\n      return partialFunc;\n    }\n\n    /**\n     * Creates a function for `_.reduce` or `_.reduceRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createReduce(arrayFunc, eachFunc) {\n      return function(collection, iteratee, accumulator, thisArg) {\n        var initFromArray = arguments.length < 3;\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with optional `this`\n     * binding of, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n          Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it to other functions.\n        var length = arguments.length,\n            index = length,\n            args = Array(length);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight);\n        }\n        if (isCurry || isCurryRight) {\n          var placeholder = wrapper.placeholder,\n              argsHolders = replaceHolders(args, placeholder);\n\n          length -= argsHolders.length;\n          if (length < arity) {\n            var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n                newArity = nativeMax(arity - length, 0),\n                newsHolders = isCurry ? argsHolders : undefined,\n                newHoldersRight = isCurry ? undefined : argsHolders,\n                newPartials = isCurry ? args : undefined,\n                newPartialsRight = isCurry ? undefined : args;\n\n            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n            if (!isCurryBound) {\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n            }\n            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n                result = createHybridWrapper.apply(undefined, newData);\n\n            if (isLaziable(func)) {\n              setData(result, newData);\n            }\n            result.placeholder = placeholder;\n            return result;\n          }\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        if (argPos) {\n          args = reorder(args, argPos);\n        }\n        if (isAry && ary < args.length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtorWrapper(func);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates the padding required for `string` based on the given `length`.\n     * The `chars` string is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the pad for `string`.\n     */\n    function createPadding(string, length, chars) {\n      var strLength = string.length;\n      length = +length;\n\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars == null ? ' ' : (chars + '');\n      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the optional `this`\n     * binding of `thisArg` and the `partials` prepended to those provided to\n     * the wrapper.\n     *\n     * @private\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it `func`.\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength);\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.ceil`, `_.floor`, or `_.round` function.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        precision = precision === undefined ? 0 : (+precision || 0);\n        if (precision) {\n          precision = pow(10, precision);\n          return func(number * precision) / precision;\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {Function} Returns the new index function.\n     */\n    function createSortedIndex(retHighest) {\n      return function(array, value, iteratee, thisArg) {\n        var callback = getCallback(iteratee);\n        return (iteratee == null && callback === baseCallback)\n          ? binaryIndex(array, value, retHighest)\n          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      length -= (holders ? holders.length : 0);\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func),\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n      if (data) {\n        mergeData(newData, data);\n        bitmask = newData[1];\n        arity = newData[9];\n      }\n      newData[9] = arity == null\n        ? (isBindKey ? 0 : func.length)\n        : (nativeMax(arity - length, 0) || 0);\n\n      if (bitmask == BIND_FLAG) {\n        var result = createBindWrapper(newData[0], newData[2]);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n        result = createPartialWrapper.apply(undefined, newData);\n      } else {\n        result = createHybridWrapper.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setter(result, newData);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing arrays.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var index = -1,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n        return false;\n      }\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index],\n            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n        if (result !== undefined) {\n          if (result) {\n            continue;\n          }\n          return false;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (isLoose) {\n          if (!arraySome(other, function(othValue) {\n                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n              })) {\n            return false;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag) {\n      switch (tag) {\n        case boolTag:\n        case dateTag:\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n          return +object == +other;\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case numberTag:\n          // Treat `NaN` vs. `NaN` as equal.\n          return (object != +object)\n            ? other != +other\n            : object == +other;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings primitives and string\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n          return object == (other + '');\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isLoose) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      var skipCtor = isLoose;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key],\n            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n          return false;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (!skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseCallback` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getCallback(func, thisArg, argCount) {\n      var result = lodash.callback || callback;\n      result = result === callback ? baseCallback : result;\n      return argCount ? result(func, thisArg, argCount) : result;\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = func.name,\n          array = realNames[result],\n          length = array ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseIndexOf` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function|number} Returns the chosen function or its result.\n     */\n    function getIndexOf(collection, target, fromIndex) {\n      var result = lodash.indexOf || indexOf;\n      result = result === indexOf ? baseIndexOf : result;\n      return collection ? result(collection, target, fromIndex) : result;\n    }\n\n    /**\n     * Gets the \"length\" property value of `object`.\n     *\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {*} Returns the \"length\" value.\n     */\n    var getLength = baseProperty('length');\n\n    /**\n     * Gets the propery names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = pairs(object),\n          length = result.length;\n\n      while (length--) {\n        result[length][2] = isStrictComparable(result[length][1]);\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = object == null ? undefined : object[key];\n      return isNative(value) ? value : undefined;\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add array properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      var Ctor = object.constructor;\n      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n        Ctor = Object;\n      }\n      return new Ctor;\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return bufferClone(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          var buffer = object.buffer;\n          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          var result = new Ctor(object.source, reFlags.exec(object));\n          result.lastIndex = object.lastIndex;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the method at `path` on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function invokePath(object, path, args) {\n      if (object != null && !isKey(path, object)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        path = last(path);\n      }\n      var func = object == null ? object : object[path];\n      return func == null ? undefined : func.apply(object, args);\n    }\n\n    /**\n     * Checks if `value` is array-like.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(getLength(value));\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return value > -1 && value % 1 == 0 && value < length;\n    }\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n          ? (isArrayLike(object) && isIndex(index, object.length))\n          : (type == 'string' && index in object)) {\n        var other = object[index];\n        return value === value ? (value === other) : (other !== other);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      var type = typeof value;\n      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n        return true;\n      }\n      if (isArray(value)) {\n        return false;\n      }\n      var result = !reIsDeepProp.test(value);\n      return result || (object != null && value in toObject(object));\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func);\n      if (!(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      var other = lodash[funcName];\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     */\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers required to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n     * augment function arguments, making the order in which they are executed important,\n     * preventing the merging of metadata. However, we make an exception for a safe\n     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < ARY_FLAG;\n\n      var isCombo =\n        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = arrayCopy(value);\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function mergeDefaults(objectValue, sourceValue) {\n      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);\n    }\n\n    /**\n     * A specialized version of `_.pick` which picks `object` properties specified\n     * by `props`.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property names to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByArray(object, props) {\n      object = toObject(object);\n\n      var index = -1,\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        if (key in object) {\n          result[key] = object[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.pick` which picks `object` properties `predicate`\n     * returns truthy for.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByCallback(object, predicate) {\n      var result = {};\n      baseForIn(object, function(value, key, object) {\n        if (predicate(value, key, object)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = arrayCopy(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity function\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = (function() {\n      var count = 0,\n          lastCalled = 0;\n\n      return function(key, value) {\n        var stamp = now(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return key;\n          }\n        } else {\n          count = 0;\n        }\n        return baseSetData(key, value);\n      };\n    }());\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n      var props = keysIn(object),\n          propsLength = props.length,\n          length = propsLength && object.length;\n\n      var allowIndexes = !!length && isLength(length) &&\n        (isArray(object) || isArguments(object));\n\n      var index = -1,\n          result = [];\n\n      while (++index < propsLength) {\n        var key = props[index];\n        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to an array-like object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array|Object} Returns the array-like object.\n     */\n    function toIterable(value) {\n      if (value == null) {\n        return [];\n      }\n      if (!isArrayLike(value)) {\n        return values(value);\n      }\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to an object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Object} Returns the object.\n     */\n    function toObject(value) {\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to property path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array} Returns the property path array.\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return value;\n      }\n      var result = [];\n      baseToString(value).replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      return wrapper instanceof LazyWrapper\n        ? wrapper.clone()\n        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `collection` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new array containing chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n        size = 1;\n      } else {\n        size = nativeMax(nativeFloor(size) || 1, 1);\n      }\n      var index = 0,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[++resIndex] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of unique `array` values not included in the other\n     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3], [4, 2]);\n     * // => [1, 3]\n     */\n    var difference = restParam(function(array, values) {\n      return (isObjectLike(array) && isArrayLike(array))\n        ? baseDifference(array, baseFlatten(values, false, true))\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that match the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [1]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8], '*', 1, 2);\n     * // => [4, '*', 8]\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(chr) {\n     *   return chr.user == 'barney';\n     * });\n     * // => 0\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findIndex(users, 'active', false);\n     * // => 0\n     *\n     * // using the `_.property` callback shorthand\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    var findIndex = createFindIndex();\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(chr) {\n     *   return chr.user == 'pebbles';\n     * });\n     * // => 2\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastIndex(users, 'active', false);\n     * // => 2\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    var findLastIndex = createFindIndex(true);\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([]);\n     * // => undefined\n     */\n    function first(array) {\n      return array ? array[0] : undefined;\n    }\n\n    /**\n     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n     * flattened, otherwise it is only flattened a single level.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, [4]]\n     *\n     * // using `isDeep`\n     * _.flatten([1, [2, 3, [4]]], true);\n     * // => [1, 2, 3, 4]\n     */\n    function flatten(array, isDeep, guard) {\n      var length = array ? array.length : 0;\n      if (guard && isIterateeCall(array, isDeep, guard)) {\n        isDeep = false;\n      }\n      return length ? baseFlatten(array, isDeep) : [];\n    }\n\n    /**\n     * Recursively flattens a nested array.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to recursively flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, 4]\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, true) : [];\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n     * performs a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     *\n     * // performing a binary search\n     * _.indexOf([1, 1, 2, 2], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\n      } else if (fromIndex) {\n        var index = binaryIndex(array, value);\n        if (index < length &&\n            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {\n          return index;\n        }\n        return -1;\n      }\n      return baseIndexOf(array, value, fromIndex || 0);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      return dropRight(array, 1);\n    }\n\n    /**\n     * Creates an array of unique values that are included in all of the provided\n     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     * _.intersection([1, 2], [4, 2], [2, 1]);\n     * // => [2]\n     */\n    var intersection = restParam(function(arrays) {\n      var othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(length),\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          result = [];\n\n      while (othIndex--) {\n        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];\n        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;\n      }\n      var array = arrays[0],\n          index = -1,\n          length = array ? array.length : 0,\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        value = array[index];\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\n          var othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(value);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    });\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n     *  or `true` to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     *\n     * // performing a binary search\n     * _.lastIndexOf([1, 1, 2, 2], 2, true);\n     * // => 3\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n      } else if (fromIndex) {\n        index = binaryIndex(array, value, true) - 1;\n        var other = array[index];\n        if (value === value ? (value === other) : (other !== other)) {\n          return index;\n        }\n        return -1;\n      }\n      if (value !== value) {\n        return indexOfNaN(array, index, true);\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     *\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull() {\n      var args = arguments,\n          array = args[0];\n\n      if (!(array && array.length)) {\n        return array;\n      }\n      var index = 0,\n          indexOf = getIndexOf(),\n          length = args.length;\n\n      while (++index < length) {\n        var fromIndex = 0,\n            value = args[index];\n\n        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to the given indexes and returns\n     * an array of the removed elements. Indexes may be specified as an array of\n     * indexes or as individual arguments.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [5, 10, 15, 20];\n     * var evens = _.pullAt(array, 1, 3);\n     *\n     * console.log(array);\n     * // => [5, 15]\n     *\n     * console.log(evens);\n     * // => [10, 20]\n     */\n    var pullAt = restParam(function(array, indexes) {\n      indexes = baseFlatten(indexes);\n\n      var result = baseAt(array, indexes);\n      basePullAt(array, indexes.sort(baseCompareAscending));\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate, thisArg) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias tail\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function rest(array) {\n      return drop(array, 1);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of `Array#slice` to support node\n     * lists in IE < 9 and to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value` should\n     * be inserted into `array` in order to maintain its sort order. If an iteratee\n     * function is provided it is invoked for `value` and each element of `array`\n     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n     * invoked with one argument; (value).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     *\n     * _.sortedIndex([4, 4, 5, 5], 5);\n     * // => 2\n     *\n     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n     *\n     * // using an iteratee function\n     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n     *   return this.data[word];\n     * }, dict);\n     * // => 1\n     *\n     * // using the `_.property` callback shorthand\n     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 1\n     */\n    var sortedIndex = createSortedIndex();\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 4, 5, 5], 5);\n     * // => 4\n     */\n    var sortedLastIndex = createSortedIndex(true);\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n     * and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all of the provided arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([1, 2], [4, 2], [2, 1]);\n     * // => [1, 2, 4]\n     */\n    var union = restParam(function(arrays) {\n      return baseUniq(baseFlatten(arrays, false, true));\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurence of each element\n     * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n     * for sorted arrays. If an iteratee function is provided it is invoked for\n     * each element in the array to generate the criterion by which uniqueness\n     * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, array).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {boolean} [isSorted] Specify the array is sorted.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     *\n     * // using `isSorted`\n     * _.uniq([1, 1, 2], true);\n     * // => [1, 2]\n     *\n     * // using an iteratee function\n     * _.uniq([1, 2.5, 1.5, 2], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => [1, 2.5]\n     *\n     * // using the `_.property` callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (isSorted != null && typeof isSorted != 'boolean') {\n        thisArg = iteratee;\n        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n        isSorted = false;\n      }\n      var callback = getCallback();\n      if (!(iteratee == null && callback === baseCallback)) {\n        iteratee = callback(iteratee, thisArg, 3);\n      }\n      return (isSorted && getIndexOf() == baseIndexOf)\n        ? sortedUniq(array, iteratee)\n        : baseUniq(array, iteratee);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var index = -1,\n          length = 0;\n\n      array = arrayFilter(array, function(group) {\n        if (isArrayLike(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = arrayMap(array, baseProperty(index));\n      }\n      return result;\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts an iteratee to specify\n     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`\n     * and invoked with four arguments: (accumulator, value, index, group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee] The function to combine regrouped values.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      iteratee = bindCallback(iteratee, thisArg, 4);\n      return arrayMap(result, function(group) {\n        return arrayReduce(group, iteratee, undefined, true);\n      });\n    }\n\n    /**\n     * Creates an array excluding all provided values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 3], 1, 2);\n     * // => [3]\n     */\n    var without = restParam(function(array, values) {\n      return isArrayLike(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the provided arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([1, 2], [4, 2]);\n     * // => [1, 4]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArrayLike(array)) {\n          var result = result\n            ? arrayPush(baseDifference(result, array), baseDifference(array, result))\n            : array;\n        }\n      }\n      return result ? baseUniq(result) : [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    var zip = restParam(unzip);\n\n    /**\n     * The inverse of `_.pairs`; this method returns an object composed from arrays\n     * of property names and values. Provide either a single two dimensional array,\n     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names\n     * and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Array\n     * @param {Array} props The property names.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject([['fred', 30], ['barney', 40]]);\n     * // => { 'fred': 30, 'barney': 40 }\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(props, values) {\n      var index = -1,\n          length = props ? props.length : 0,\n          result = {};\n\n      if (length && !values && !isArray(props[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = props[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an iteratee to specify\n     * how grouped values should be combined. The `iteratee` is bound to `thisArg`\n     * and invoked with four arguments: (accumulator, value, index, group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee] The function to combine grouped values.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);\n     * // => [111, 222]\n     */\n    var zipWith = restParam(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 2 ? arrays[length - 2] : undefined,\n          thisArg = length > 1 ? arrays[length - 1] : undefined;\n\n      if (length > 2 && typeof iteratee == 'function') {\n        length -= 2;\n      } else {\n        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;\n        thisArg = undefined;\n      }\n      arrays.length = length;\n      return unzipWith(arrays, iteratee, thisArg);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method\n     * chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(users)\n     *   .sortBy('age')\n     *   .map(function(chr) {\n     *     return chr.user + ' is ' + chr.age;\n     *   })\n     *   .first()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n     * this method is to \"tap into\" a method chain in order to perform operations\n     * on intermediate results within the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor, thisArg) {\n      interceptor.call(thisArg, value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor, thisArg) {\n      return interceptor.call(thisArg, value);\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(users).first();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(users).chain()\n     *   .first()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chained sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Creates a new array joining a wrapped array with any additional arrays\n     * and/or values.\n     *\n     * @name concat\n     * @memberOf _\n     * @category Chain\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var wrapped = _(array).concat(2, [3], [[4]]);\n     *\n     * console.log(wrapped.value());\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    var wrapperConcat = restParam(function(values) {\n      values = baseFlatten(values);\n      return this.thru(function(array) {\n        return arrayConcat(isArray(array) ? array : [toObject(array)], values);\n      });\n    });\n\n    /**\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).map(function(value) {\n     *   return Math.pow(value, 2);\n     * });\n     *\n     * var other = [3, 4];\n     * var otherWrapped = wrapped.plant(other);\n     *\n     * otherWrapped.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * Reverses the wrapped array so the first element becomes the last, the\n     * second element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n\n      var interceptor = function(value) {\n        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();\n      };\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(interceptor);\n    }\n\n    /**\n     * Produces the result of coercing the unwrapped value to a string.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chain\n     * @returns {string} Returns the coerced string value.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return (this.value() + '');\n    }\n\n    /**\n     * Executes the chained sequence to extract the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @alias run, toJSON, valueOf\n     * @category Chain\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements corresponding to the given keys, or indexes,\n     * of `collection`. Keys may be specified as individual arguments or as arrays\n     * of keys.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [props] The property names\n     *  or indexes of elements to pick, specified individually or in arrays.\n     * @returns {Array} Returns the new array of picked elements.\n     * @example\n     *\n     * _.at(['a', 'b', 'c'], [0, 2]);\n     * // => ['a', 'c']\n     *\n     * _.at(['barney', 'fred', 'pebbles'], 0, 2);\n     * // => ['barney', 'pebbles']\n     */\n    var at = restParam(function(collection, props) {\n      return baseAt(collection, baseFlatten(props));\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the number of times the key was returned by `iteratee`.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * The predicate is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': false },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.every(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = undefined;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.filter([4, 5, 6], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 6]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.filter(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.filter(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function filter(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.result(_.find(users, function(chr) {\n     *   return chr.age < 40;\n     * }), 'user');\n     * // => 'barney'\n     *\n     * // using the `_.matches` callback shorthand\n     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.result(_.find(users, 'active', false), 'user');\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.result(_.find(users, 'active'), 'user');\n     * // => 'barney'\n     */\n    var find = createFind(baseEach);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(baseEachRight, true);\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning the first element that has equivalent property\n     * values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n     * // => 'barney'\n     *\n     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n     * // => 'fred'\n     */\n    function findWhere(collection, source) {\n      return find(collection, baseMatches(source));\n    }\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection). Iteratee functions may exit iteration early\n     * by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEach(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from left to right and returns the array\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n     *   console.log(n, key);\n     * });\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n     */\n    var forEach = createForEach(arrayEach, baseEach);\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEachRight(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from right to left and returns the array\n     */\n    var forEachRight = createForEach(arrayEachRight, baseEachRight);\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using the `_.property` callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n     * from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @alias contains, include\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} target The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.includes('pebbles', 'eb');\n     * // => true\n     */\n    function includes(collection, target, fromIndex, guard) {\n      var length = collection ? getLength(collection) : 0;\n      if (!isLength(length)) {\n        collection = values(collection);\n        length = collection.length;\n      }\n      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\n        fromIndex = 0;\n      } else {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      }\n      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\n        : (!!length && getIndexOf(collection, target, fromIndex) > -1);\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the last element responsible for generating the key. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return String.fromCharCode(object.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return this.fromCharCode(object.code);\n     * }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `methodName` is a function it is\n     * invoked for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invoke = restParam(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          isProp = isKey(path),\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` through\n     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n     * `sum`, `uniq`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function timesThree(n) {\n     *   return n * 3;\n     * }\n     *\n     * _.map([1, 2], timesThree);\n     * // => [3, 6]\n     *\n     * _.map({ 'a': 1, 'b': 2 }, timesThree);\n     * // => [3, 6] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee, thisArg) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return func(collection, iteratee);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, while the second of which\n     * contains elements `predicate` returns falsey for. The predicate is bound\n     * to `thisArg` and invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.partition([1, 2, 3], function(n) {\n     *   return n % 2;\n     * });\n     * // => [[1, 3], [2]]\n     *\n     * _.partition([1.2, 2.3, 3.4], function(n) {\n     *   return this.floor(n) % 2;\n     * }, Math);\n     * // => [[1.2, 3.4], [2.3]]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * var mapper = function(array) {\n     *   return _.pluck(array, 'user');\n     * };\n     *\n     * // using the `_.matches` callback shorthand\n     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n     * // => [['pebbles'], ['barney', 'fred']]\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.map(_.partition(users, 'active', false), mapper);\n     * // => [['barney', 'pebbles'], ['fred']]\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(_.partition(users, 'active'), mapper);\n     * // => [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Gets the property value of `path` from all elements in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|string} path The path of the property to pluck.\n     * @returns {Array} Returns the property values.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(users, 'user');\n     * // => ['barney', 'fred']\n     *\n     * var userIndex = _.indexBy(users, 'user');\n     * _.pluck(userIndex, 'age');\n     * // => [36, 40] (iteration order is not guaranteed)\n     */\n    function pluck(collection, path) {\n      return map(collection, property(path));\n    }\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` through `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not provided the first element of `collection` is used as the initial\n     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n     * and `sortByOrder`\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.reduce([1, 2], function(total, n) {\n     *   return total + n;\n     * });\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n     */\n    var reduce = createReduce(arrayReduce, baseEach);\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    var reduceRight = createReduce(arrayReduceRight, baseEachRight);\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.reject([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [1, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.reject(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.reject(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function reject(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, function(value, index, collection) {\n        return !predicate(value, index, collection);\n      });\n    }\n\n    /**\n     * Gets a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {*} Returns the random sample(s).\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n        collection = toIterable(collection);\n        var length = collection.length;\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n      }\n      var index = -1,\n          result = toArray(collection),\n          length = result.length,\n          lastIndex = length - 1;\n\n      n = nativeMin(n < 0 ? 0 : (+n || 0), length);\n      while (++index < n) {\n        var rand = baseRandom(index, lastIndex),\n            value = result[rand];\n\n        result[rand] = result[index];\n        result[index] = value;\n      }\n      result.length = n;\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      return sample(collection, POSITIVE_INFINITY);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the size of `collection`.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? getLength(collection) : 0;\n      return isLength(length) ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * The function returns as soon as it finds a passing value and does not iterate\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.some(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = undefined;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through `iteratee`. This method performs\n     * a stable sort, that is, it preserves the original sort order of equal elements.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return Math.sin(n);\n     * });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return this.sin(n);\n     * }, Math);\n     * // => [3, 1, 2]\n     *\n     * var users = [\n     *   { 'user': 'fred' },\n     *   { 'user': 'pebbles' },\n     *   { 'user': 'barney' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.sortBy(users, 'user'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function sortBy(collection, iteratee, thisArg) {\n      if (collection == null) {\n        return [];\n      }\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = undefined;\n      }\n      var index = -1;\n      iteratee = getCallback(iteratee, thisArg, 3);\n\n      var result = baseMap(collection, function(value, key, collection) {\n        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n      });\n      return baseSortBy(result, compareAscending);\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it can sort by multiple iteratees\n     * or property names.\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees\n     *  The iteratees to sort by, specified as individual values or arrays of values.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n     *\n     * _.map(_.sortByAll(users, 'user', function(chr) {\n     *   return Math.floor(chr.age / 10);\n     * }), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    var sortByAll = restParam(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var guard = iteratees[2];\n      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {\n        iteratees.length = 1;\n      }\n      return baseSortByOrder(collection, baseFlatten(iteratees), []);\n    });\n\n    /**\n     * This method is like `_.sortByAll` except that it allows specifying the\n     * sort orders of the iteratees to sort by. If `orders` is unspecified, all\n     * values are sorted in ascending order. Otherwise, a value is sorted in\n     * ascending order if its corresponding order is \"asc\", and descending if \"desc\".\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // sort by `user` in ascending order and by `age` in descending order\n     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    function sortByOrder(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (guard && isIterateeCall(iteratees, orders, guard)) {\n        orders = undefined;\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseSortByOrder(collection, iteratees, orders);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n     * // => ['fred']\n     */\n    function where(collection, source) {\n      return filter(collection, baseMatches(source));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Date\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\n     */\n    var now = nativeNow || function() {\n      return new Date().getTime();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it is called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'done saving!' after the two async saves have completed\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      n = nativeIsFinite(n = +n) ? n : 0;\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that accepts up to `n` arguments ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      if (guard && isIterateeCall(func, n, guard)) {\n        n = undefined;\n      }\n      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it is called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery('#add').on('click', _.before(5, addContactToList));\n     * // => allows adding up to 4 contacts to the list\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `_.bind` arguments to those provided to the\n     * bound function.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var greet = function(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * };\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // using placeholders\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = restParam(function(func, thisArg, partials) {\n      var bitmask = BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bind.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all enumerable function\n     * properties, own and inherited, of `object` are bound.\n     *\n     * **Note:** This method does not set the \"length\" property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} [methodNames] The object method names to bind,\n     *  specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs' when the element is clicked\n     */\n    var bindAll = restParam(function(object, methodNames) {\n      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\n\n      var index = -1,\n          length = methodNames.length;\n\n      while (++index < length) {\n        var key = methodNames[index];\n        object[key] = createWrapper(object[key], BIND_FLAG, object);\n      }\n      return object;\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `_.bindKey` arguments to those provided to the bound function.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // using placeholders\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = restParam(function(object, key, partials) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bindKey.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts one or more arguments of `func` that when\n     * called either invokes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` may be specified\n     * if `func.length` is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    var curry = createCurry(CURRY_FLAG);\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    var curryRight = createCurry(CURRY_RIGHT_FLAG);\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed invocations. Provide an options object to indicate that `func`\n     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n     * Subsequent calls to the debounced function return the result of the last\n     * `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n     *  delayed before it is invoked.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }));\n     *\n     * // cancel a debounced call\n     * var todoChanges = _.debounce(batchLog, 1000);\n     * Object.observe(models.todo, todoChanges);\n     *\n     * Object.observe(models, function(changes) {\n     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n     *     todoChanges.cancel();\n     *   }\n     * }, ['delete']);\n     *\n     * // ...at some point `models.todo` is changed\n     * models.todo.completed = true;\n     *\n     * // ...before 1 second has passed `models.todo` is deleted\n     * // which cancels the debounced `todoChanges` call\n     * delete models.todo;\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = wait < 0 ? 0 : (+wait || 0);\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = !!options.leading;\n        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (maxTimeoutId) {\n          clearTimeout(maxTimeoutId);\n        }\n        lastCalled = 0;\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n      }\n\n      function complete(isCalled, id) {\n        if (id) {\n          clearTimeout(id);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (isCalled) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = undefined;\n          }\n        }\n      }\n\n      function delayed() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          complete(trailingCall, maxTimeoutId);\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      }\n\n      function maxDelayed() {\n        complete(trailing, timeoutId);\n      }\n\n      function debounced() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = undefined;\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    var defer = restParam(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    var delay = restParam(function(func, wait, args) {\n      return baseDelay(func, wait, args);\n    });\n\n    /**\n     * Creates a function that returns the result of invoking the provided\n     * functions with the `this` binding of the created function, where each\n     * successive invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow(_.add, square);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the provided functions from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias backflow, compose\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight(square, _.add);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is coerced to a string and used as the\n     * cache key. The `func` is invoked with the `this` binding of the memoized\n     * function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var upperCase = _.memoize(function(string) {\n     *   return string.toUpperCase();\n     * });\n     *\n     * upperCase('fred');\n     * // => 'FRED'\n     *\n     * // modifying the result cache\n     * upperCase.cache.set('fred', 'BARNEY');\n     * upperCase('fred');\n     * // => 'BARNEY'\n     *\n     * // replacing `_.memoize.Cache`\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'barney' };\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'fred' }\n     *\n     * _.memoize.Cache = WeakMap;\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'barney' }\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      memoized.cache = new memoize.Cache;\n      return memoized;\n    }\n\n    /**\n     * Creates a function that runs each argument through a corresponding\n     * transform function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms] The functions to transform\n     * arguments, specified as individual functions or arrays of functions.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var modded = _.modArgs(function(x, y) {\n     *   return [x, y];\n     * }, square, doubled);\n     *\n     * modded(1, 2);\n     * // => [1, 4]\n     *\n     * modded(5, 10);\n     * // => [25, 20]\n     */\n    var modArgs = restParam(function(func, transforms) {\n      transforms = baseFlatten(transforms);\n      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = transforms.length;\n      return restParam(function(args) {\n        var index = nativeMin(args.length, length);\n        while (index--) {\n          args[index] = transforms[index](args[index]);\n        }\n        return func.apply(this, args);\n      });\n    });\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first call. The `func` is invoked\n     * with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` invokes `createApplication` once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with `partial` arguments prepended\n     * to those provided to the new function. This method is like `_.bind` except\n     * it does **not** alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // using placeholders\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = createPartial(PARTIAL_FLAG);\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // using placeholders\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified indexes where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, 2, 0, 1);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     *\n     * var map = _.rearg(_.map, [1, 0]);\n     * map(function(n) {\n     *   return n * 3;\n     * }, [1, 2, 3]);\n     * // => [3, 6, 9]\n     */\n    var rearg = restParam(function(func, indexes) {\n      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as an array.\n     *\n     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.restParam(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function restParam(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            rest = Array(length);\n\n        while (++index < length) {\n          rest[index] = args[start + index];\n        }\n        switch (start) {\n          case 0: return func.call(this, rest);\n          case 1: return func.call(this, args[0], rest);\n          case 2: return func.call(this, args[0], args[1], rest);\n        }\n        var otherArgs = Array(start + 1);\n        index = -1;\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = rest;\n        return func.apply(this, otherArgs);\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the created\n     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n     *\n     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * // with a Promise\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function(array) {\n        return func.apply(this, array);\n      };\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed invocations. Provide an options object to indicate\n     * that `func` should be invoked on the leading and/or trailing edge of the\n     * `wait` timeout. Subsequent calls to the throttled function return the\n     * result of the last `func` call.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     *\n     * // cancel a trailing throttled call\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Any additional arguments provided to the function are\n     * appended to those provided to the wrapper function. The wrapper is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n     * otherwise they are assigned by reference. If `customizer` is provided it is\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is bound to\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var shallow = _.clone(users);\n     * shallow[0] === users[0];\n     * // => true\n     *\n     * var deep = _.clone(users, true);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.clone(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, customizer, thisArg) {\n      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n        isDeep = false;\n      }\n      else if (typeof isDeep == 'function') {\n        thisArg = customizer;\n        customizer = isDeep;\n        isDeep = false;\n      }\n      return typeof customizer == 'function'\n        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))\n        : baseClone(value, isDeep);\n    }\n\n    /**\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\n     * and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var deep = _.cloneDeep(users);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.cloneDeep(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 20\n     */\n    function cloneDeep(value, customizer, thisArg) {\n      return typeof customizer == 'function'\n        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))\n        : baseClone(value, true);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    function gt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    function gte(value, other) {\n      return value >= other;\n    }\n\n    /**\n     * Checks if `value` is classified as an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return isObjectLike(value) && isArrayLike(value) &&\n        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n    }\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(function() { return arguments; }());\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n    };\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return isObjectLike(value) && objToString.call(value) == dateTag;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is empty. A value is considered empty unless it is an\n     * `arguments` object, array, string, or jQuery-like collection with a length\n     * greater than `0` or an object with own enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n          (isObjectLike(value) && isFunction(value.splice)))) {\n        return !value.length;\n      }\n      return !keys(value).length;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent. If `customizer` is provided it is invoked to compare values.\n     * If `customizer` returns `undefined` comparisons are handled by the method\n     * instead. The `customizer` is bound to `thisArg` and invoked with three\n     * arguments: (value, other [, index|key]).\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. Functions and DOM nodes\n     * are **not** supported. Provide a customizer function to extend support\n     * for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @alias eq\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * object == other;\n     * // => false\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * // using a customizer callback\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqual(array, other, function(value, other) {\n     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {\n     *     return true;\n     *   }\n     * });\n     * // => true\n     */\n    function isEqual(value, other, customizer, thisArg) {\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(10);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => false\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite(Object(10));\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in older versions of Chrome and Safari which return 'function' for regexes\n      // and Safari 8 equivalents which return 'object' for typed array constructors.\n      return isObject(value) && objToString.call(value) == funcTag;\n    }\n\n    /**\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // Avoid a V8 JIT bug in Chrome 19-20.\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n      var type = typeof value;\n      return !!value && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Performs a deep comparison between `object` and `source` to determine if\n     * `object` contains equivalent property values. If `customizer` is provided\n     * it is invoked to compare values. If `customizer` returns `undefined`\n     * comparisons are handled by the method instead. The `customizer` is bound\n     * to `thisArg` and invoked with three arguments: (value, other, index|key).\n     *\n     * **Note:** This method supports comparing properties of arrays, booleans,\n     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n     * and DOM nodes are **not** supported. Provide a customizer function to extend\n     * support for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.isMatch(object, { 'age': 40 });\n     * // => true\n     *\n     * _.isMatch(object, { 'age': 36 });\n     * // => false\n     *\n     * // using a customizer callback\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatch(object, source, function(value, other) {\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n     * });\n     * // => true\n     */\n    function isMatch(object, source, customizer, thisArg) {\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n      return baseIsMatch(object, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n     * which returns `true` for `undefined` and other non-numeric values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (value == null) {\n        return false;\n      }\n      if (isFunction(value)) {\n        return reIsNative.test(fnToString.call(value));\n      }\n      return isObjectLike(value) && reIsHostCtor.test(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n     * as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4);\n     * // => true\n     *\n     * _.isNumber(NaN);\n     * // => true\n     *\n     * _.isNumber('8.4');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * **Note:** This method assumes objects created by the `Object` constructor\n     * have no inherited enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      var Ctor;\n\n      // Exit early for non `Object` objects.\n      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      var result;\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      baseForIn(value, function(subValue, key) {\n        result = key;\n      });\n      return result === undefined || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      return isObject(value) && objToString.call(value) == regexpTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    function lt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    function lte(value, other) {\n      return value <= other;\n    }\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * (function() {\n     *   return _.toArray(arguments).slice(1);\n     * }(1, 2, 3));\n     * // => [2, 3]\n     */\n    function toArray(value) {\n      var length = value ? getLength(value) : 0;\n      if (!isLength(length)) {\n        return values(value);\n      }\n      if (!length) {\n        return [];\n      }\n      return arrayCopy(value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return baseCopy(value, keysIn(value));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * overwrite property assignments of previous sources. If `customizer` is\n     * provided it is invoked to produce the merged values of the destination and\n     * source properties. If `customizer` returns `undefined` merging is handled\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n     * with five arguments: (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n     * };\n     *\n     * var ages = {\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n     * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     *\n     * // using a customizer callback\n     * var object = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var other = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(object, other, function(a, b) {\n     *   if (_.isArray(a)) {\n     *     return a.concat(b);\n     *   }\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var merge = createAssigner(baseMerge);\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources overwrite property assignments of previous sources.\n     * If `customizer` is provided it is invoked to produce the assigned values.\n     * The `customizer` is bound to `thisArg` and invoked with five arguments:\n     * (objectValue, sourceValue, key, object, source).\n     *\n     * **Note:** This method mutates `object` and is based on\n     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using a customizer callback\n     * var defaults = _.partialRight(_.assign, function(value, other) {\n     *   return _.isUndefined(value) ? other : value;\n     * });\n     *\n     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var assign = createAssigner(function(object, source, customizer) {\n      return customizer\n        ? assignWith(object, source, customizer)\n        : baseAssign(object, source);\n    });\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties, guard) {\n      var result = baseCreate(prototype);\n      if (guard && isIterateeCall(prototype, properties, guard)) {\n        properties = undefined;\n      }\n      return properties ? baseAssign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var defaults = createDefaults(assign, assignDefaults);\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n     * // => { 'user': { 'name': 'barney', 'age': 36 } }\n     *\n     */\n    var defaultsDeep = createDefaults(merge, mergeDefaults);\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    var findKey = createFindKey(baseForOwn);\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    var findLastKey = createFindKey(baseForOwnRight);\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object invoking\n     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n     */\n    var forIn = createForIn(baseFor);\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n     */\n    var forInRight = createForIn(baseForRight);\n\n    /**\n     * Iterates over own enumerable properties of an object invoking `iteratee`\n     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n     * three arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a' and 'b' (iteration order is not guaranteed)\n     */\n    var forOwn = createForOwn(baseForOwn);\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'\n     */\n    var forOwnRight = createForOwn(baseForOwnRight);\n\n    /**\n     * Creates an array of function property names from all enumerable properties,\n     * own and inherited, of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['after', 'ary', 'assign', ...]\n     */\n    function functions(object) {\n      return baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the property value at `path` of `object`. If the resolved value is\n     * `undefined` the `defaultValue` is used in its place.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': { 'c': 3 } } };\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b.c');\n     * // => true\n     *\n     * _.has(object, ['a', 'b', 'c']);\n     * // => true\n     */\n    function has(object, path) {\n      if (object == null) {\n        return false;\n      }\n      var result = hasOwnProperty.call(object, path);\n      if (!result && !isKey(path)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        if (object == null) {\n          return false;\n        }\n        path = last(path);\n        result = hasOwnProperty.call(object, path);\n      }\n      return result || (isLength(object.length) && isIndex(path, object.length) &&\n        (isArray(object) || isArguments(object)));\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite property\n     * assignments of previous values unless `multiValue` is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiValue] Allow multiple values per key.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     *\n     * // with `multiValue`\n     * _.invert(object, true);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function invert(object, multiValue, guard) {\n      if (guard && isIterateeCall(object, multiValue, guard)) {\n        multiValue = undefined;\n      }\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (multiValue) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      var Ctor = object == null ? undefined : object.constructor;\n      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n          (typeof object != 'function' && isArrayLike(object))) {\n        return shimKeys(object);\n      }\n      return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      if (object == null) {\n        return [];\n      }\n      if (!isObject(object)) {\n        object = Object(object);\n      }\n      var length = object.length;\n      length = (length && isLength(length) &&\n        (isArray(object) || isArguments(object)) && length) || 0;\n\n      var Ctor = object.constructor,\n          index = -1,\n          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n          result = Array(length),\n          skipIndexes = length > 0;\n\n      while (++index < length) {\n        result[index] = (index + '');\n      }\n      for (var key in object) {\n        if (!(skipIndexes && isIndex(key, length)) &&\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * property of `object` through `iteratee`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    var mapKeys = createObjectMapper(true);\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through `iteratee`. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, key, object).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {\n     *   return n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using the `_.property` callback shorthand\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    var mapValues = createObjectMapper();\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that are not omitted.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to omit, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.omit(object, 'age');\n     * // => { 'user': 'fred' }\n     *\n     * _.omit(object, _.isNumber);\n     * // => { 'user': 'fred' }\n     */\n    var omit = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      if (typeof props[0] != 'function') {\n        var props = arrayMap(baseFlatten(props), String);\n        return pickByArray(object, baseDifference(keysIn(object), props));\n      }\n      var predicate = bindCallback(props[0], props[1], 3);\n      return pickByCallback(object, function(value, key, object) {\n        return !predicate(value, key, object);\n      });\n    });\n\n    /**\n     * Creates a two dimensional array of the key-value pairs for `object`,\n     * e.g. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n     */\n    function pairs(object) {\n      object = toObject(object);\n\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties. Property\n     * names may be specified as individual arguments or as arrays of property\n     * names. If `predicate` is provided it is invoked for each property of `object`\n     * picking the properties `predicate` returns truthy for. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.pick(object, 'user');\n     * // => { 'user': 'fred' }\n     *\n     * _.pick(object, _.isString);\n     * // => { 'user': 'fred' }\n     */\n    var pick = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      return typeof props[0] == 'function'\n        ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n        : pickByArray(object, baseFlatten(props));\n    });\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a function\n     * it is invoked with the `this` binding of its parent object and its result\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a.b.c', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a.b.c', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      var result = object == null ? undefined : object[path];\n      if (result === undefined) {\n        if (object != null && !isKey(path, object)) {\n          path = toPath(path);\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          result = object == null ? undefined : object[last(path)];\n        }\n        result = result === undefined ? defaultValue : result;\n      }\n      return isFunction(result) ? result.call(object) : result;\n    }\n\n    /**\n     * Sets the property value of `path` on `object`. If a portion of `path`\n     * does not exist it is created.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to augment.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, 'x[0].y.z', 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      if (object == null) {\n        return object;\n      }\n      var pathKey = (path + '');\n      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = path[index];\n        if (isObject(nested)) {\n          if (index == lastIndex) {\n            nested[key] = value;\n          } else if (nested[key] == null) {\n            nested[key] = isIndex(path[index + 1]) ? [] : {};\n          }\n        }\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own enumerable\n     * properties through `iteratee`, with each invocation potentially mutating\n     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n     * with four arguments: (accumulator, value, key, object). Iteratee functions\n     * may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     */\n    function transform(object, iteratee, accumulator, thisArg) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = getCallback(iteratee, thisArg, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor : [];\n          } else {\n            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values\n     * of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `n` is between `start` and up to but not including, `end`. If\n     * `end` is not specified it is set to `start` with `start` then set to `0`.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} n The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     */\n    function inRange(value, start, end) {\n      start = +start || 0;\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      return value >= nativeMin(start, end) && value < nativeMax(start, end);\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number is returned.\n     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n     * number is returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      if (floating && isIterateeCall(min, max, floating)) {\n        max = floating = undefined;\n      }\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (noMax && typeof min == 'boolean') {\n          floating = min;\n          min = 1;\n        }\n        else if (typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n        noMax = false;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__foo_bar__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n    });\n\n    /**\n     * Capitalizes the first character of `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('fred');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      string = baseToString(string);\n      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n    }\n\n    /**\n     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = baseToString(string);\n      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = baseToString(string);\n      target = (target + '');\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : nativeMin(position < 0 ? 0 : (+position || 0), length);\n\n      position -= target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n     * their corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional characters\n     * use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value.\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * Backticks are escaped because in Internet Explorer < 9, they can break out\n     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n     * for more details.\n     *\n     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n     * to reduce XSS vectors.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n      string = baseToString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n     * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n     */\n    function escapeRegExp(string) {\n      string = baseToString(string);\n      return (string && reHasRegExpChars.test(string))\n        ? string.replace(reRegExpChars, escapeRegExpChar)\n        : (string || '(?:)');\n    }\n\n    /**\n     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__foo_bar__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = baseToString(string);\n      length = +length;\n\n      var strLength = string.length;\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = nativeFloor(mid),\n          rightLength = nativeCeil(mid);\n\n      chars = createPadding('', rightLength, chars);\n      return chars.slice(0, leftLength) + string + chars;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padLeft('abc', 6);\n     * // => '   abc'\n     *\n     * _.padLeft('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padLeft('abc', 3);\n     * // => 'abc'\n     */\n    var padLeft = createPadDir();\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padRight('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padRight('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padRight('abc', 3);\n     * // => 'abc'\n     */\n    var padRight = createPadDir(true);\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n     * of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n      // Chrome fails to trim leading <BOM> whitespace characters.\n      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      string = trim(string);\n      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      var result = '';\n      string = baseToString(string);\n      n = +n;\n      if (n < 1 || !string || !nativeIsFinite(n)) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        string += string;\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--foo-bar');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__foo_bar__');\n     * // => 'Foo Bar'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = baseToString(string);\n      position = position == null\n        ? 0\n        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is provided it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // using custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using backslashes to treat delimiters as plain text\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // using the `imports` option to import `jQuery` as `jq`\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, otherOptions) {\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n        options = otherOptions = undefined;\n      }\n      string = baseToString(string);\n      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\n      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n      }\n      chars = (chars + '');\n      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimLeft('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimLeft('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimLeft(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string));\n      }\n      return string.slice(charsLeftIndex(string, (chars + '')));\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimRight('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimRight('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimRight(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(0, trimmedRightIndex(string) + 1);\n      }\n      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object|number} [options] The options object or maximum string length.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.trunc('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', 24);\n     * // => 'hi-diddly-ho there, n...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function trunc(string, options, guard) {\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (options != null) {\n        if (isObject(options)) {\n          var separator = 'separator' in options ? options.separator : separator;\n          length = 'length' in options ? (+options.length || 0) : length;\n          omission = 'omission' in options ? baseToString(options.omission) : omission;\n        } else {\n          length = +options || 0;\n        }\n      }\n      string = baseToString(string);\n      if (length >= string.length) {\n        return string;\n      }\n      var end = length - omission.length;\n      if (end < 1) {\n        return omission;\n      }\n      var result = string.slice(0, end);\n      if (separator == null) {\n        return result + omission;\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              newEnd,\n              substring = string.slice(0, end);\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            newEnd = match.index;\n          }\n          result = result.slice(0, newEnd == null ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n     * corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = baseToString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      if (guard && isIterateeCall(string, pattern, guard)) {\n        pattern = undefined;\n      }\n      string = baseToString(string);\n      return string.match(pattern || reWords) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function} func The function to attempt.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // avoid throwing errors for invalid selectors\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = restParam(function(func, args) {\n      try {\n        return func.apply(undefined, args);\n      } catch(e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and arguments of the created function. If `func` is a property name the\n     * created callback returns the property value for a given element. If `func`\n     * is an object the created callback returns `true` for elements that contain\n     * the equivalent object properties, otherwise it returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias iteratee\n     * @category Utility\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n     *   if (!match) {\n     *     return callback(func, thisArg);\n     *   }\n     *   return function(object) {\n     *     return match[2] == 'gt'\n     *       ? object[match[1]] > match[3]\n     *       : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(users, 'age__gt36');\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function callback(func, thisArg, guard) {\n      if (guard && isIterateeCall(func, thisArg, guard)) {\n        thisArg = undefined;\n      }\n      return isObjectLike(func)\n        ? matches(func)\n        : baseCallback(func, thisArg);\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var getter = _.constant(object);\n     *\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that performs a deep comparison between a given object\n     * and `source`, returning `true` if the given object has equivalent property\n     * values, else `false`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that compares the property value of `path` on a given\n     * object to `value`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * _.find(users, _.matchesProperty('user', 'fred'));\n     * // => { 'user': 'fred' }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, true));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` on a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    var method = restParam(function(path, args) {\n      return function(object) {\n        return invokePath(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path on `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = restParam(function(object, args) {\n      return function(path) {\n        return invokePath(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable function properties of a source object to the\n     * destination object. If `object` is a function then methods are added to\n     * its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      if (options == null) {\n        var isObj = isObject(source),\n            props = isObj ? keys(source) : undefined,\n            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;\n\n        if (!(methodNames ? methodNames.length : isObj)) {\n          methodNames = false;\n          options = source;\n          source = object;\n          object = this;\n        }\n      }\n      if (!methodNames) {\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = true,\n          index = -1,\n          isFunc = isFunction(object),\n          length = methodNames.length;\n\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      while (++index < length) {\n        var methodName = methodNames[index],\n            func = source[methodName];\n\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = (function(func) {\n            return function() {\n              var chainAll = this.__chain__;\n              if (chain || chainAll) {\n                var result = object(this.__wrapped__),\n                    actions = result.__actions__ = arrayCopy(this.__actions__);\n\n                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n                result.__chain__ = chainAll;\n                return result;\n              }\n              return func.apply(object, arrayPush([this.value()], arguments));\n            };\n          }(func));\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      root._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function that returns `undefined` regardless of the\n     * arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that returns the property value at `path` on a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': 2 } } },\n     *   { 'a': { 'b': { 'c': 1 } } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the property value at a given path on `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return baseGet(object, toPath(path), path + '');\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. If `end` is not specified it is\n     * set to `start` with `start` then set to `0`. If `end` is less than `start`\n     * a zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      if (step && isIterateeCall(start, end, step)) {\n        end = step = undefined;\n      }\n      start = +start || 0;\n      step = step == null ? 1 : (+step || 0);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the iteratee function `n` times, returning an array of the results\n     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n     * one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) {\n     *   mage.castSpell(n);\n     * });\n     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\n     *\n     * _.times(3, function(n) {\n     *   this.cast(n);\n     * }, mage);\n     * // => also invokes `mage.castSpell(n)` three times\n     */\n    function times(n, iteratee, thisArg) {\n      n = nativeFloor(n);\n\n      // Exit early to avoid a JSC JIT bug in Safari 8\n      // where `Array(0)` is treated as `Array(1)`.\n      if (n < 1 || !nativeIsFinite(n)) {\n        return [];\n      }\n      var index = -1,\n          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\n      iteratee = bindCallback(iteratee, thisArg, 1);\n      while (++index < n) {\n        if (index < MAX_ARRAY_LENGTH) {\n          result[index] = iteratee(index);\n        } else {\n          iteratee(index);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return baseToString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} augend The first number to add.\n     * @param {number} addend The second number to add.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    function add(augend, addend) {\n      return (+augend || 0) + (+addend || 0);\n    }\n\n    /**\n     * Calculates `n` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Calculates `n` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => -Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.max(users, 'age');\n     * // => { 'user': 'fred', 'age': 40 }\n     */\n    var max = createExtremum(gt, NEGATIVE_INFINITY);\n\n    /**\n     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n     * `Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.min(users, 'age');\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var min = createExtremum(lt, POSITIVE_INFINITY);\n\n    /**\n     * Calculates `n` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Gets the sum of the values in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 6]);\n     * // => 10\n     *\n     * _.sum({ 'a': 4, 'b': 6 });\n     * // => 10\n     *\n     * var objects = [\n     *   { 'n': 4 },\n     *   { 'n': 6 }\n     * ];\n     *\n     * _.sum(objects, function(object) {\n     *   return object.n;\n     * });\n     * // => 10\n     *\n     * // using the `_.property` callback shorthand\n     * _.sum(objects, 'n');\n     * // => 10\n     */\n    function sum(collection, iteratee, thisArg) {\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = undefined;\n      }\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return iteratee.length == 1\n        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)\n        : baseSum(collection, iteratee);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    // Add functions to the `Map` cache.\n    MapCache.prototype['delete'] = mapDelete;\n    MapCache.prototype.get = mapGet;\n    MapCache.prototype.has = mapHas;\n    MapCache.prototype.set = mapSet;\n\n    // Add functions to the `Set` cache.\n    SetCache.prototype.push = cachePush;\n\n    // Assign cache to `_.memoize`.\n    memoize.Cache = MapCache;\n\n    // Add functions that return wrapped values when chaining.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.callback = callback;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.modArgs = modArgs;\n    lodash.negate = negate;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.restParam = restParam;\n    lodash.set = set;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortByAll = sortByAll;\n    lodash.sortByOrder = sortByOrder;\n    lodash.spread = spread;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.backflow = flowRight;\n    lodash.collect = map;\n    lodash.compose = flowRight;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.iteratee = callback;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n\n    // Add functions to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions that return unwrapped values when chaining.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.deburr = deburr;\n    lodash.endsWith = endsWith;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.findWhere = findWhere;\n    lodash.first = first;\n    lodash.floor = floor;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isMatch = isMatch;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.min = min;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padLeft = padLeft;\n    lodash.padRight = padRight;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.sum = sum;\n    lodash.template = template;\n    lodash.trim = trim;\n    lodash.trimLeft = trimLeft;\n    lodash.trimRight = trimRight;\n    lodash.trunc = trunc;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.words = words;\n\n    // Add aliases.\n    lodash.all = every;\n    lodash.any = some;\n    lodash.contains = includes;\n    lodash.eq = isEqual;\n    lodash.detect = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.head = first;\n    lodash.include = includes;\n    lodash.inject = reduce;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), false);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions capable of returning wrapped and unwrapped values when chaining.\n    lodash.sample = sample;\n\n    lodash.prototype.sample = function(n) {\n      if (!this.__chain__ && n == null) {\n        return sample(this.value());\n      }\n      return this.thru(function(value) {\n        return sample(value, n);\n      });\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__;\n        if (filtered && !index) {\n          return new LazyWrapper(this);\n        }\n        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);\n\n        var result = this.clone();\n        if (filtered) {\n          result.__takeCount__ = nativeMin(result.__takeCount__, n);\n        } else {\n          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type != LAZY_MAP_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n        var result = this.clone();\n        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n    arrayEach(['first', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n    arrayEach(['initial', 'rest'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n    arrayEach(['pluck', 'where'], function(methodName, index) {\n      var operationName = index ? 'filter' : 'map',\n          createCallback = index ? baseMatches : property;\n\n      LazyWrapper.prototype[methodName] = function(value) {\n        return this[operationName](createCallback(value));\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.reject = function(predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 1);\n      return this.filter(function(value) {\n        return !predicate(value);\n      });\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = start == null ? 0 : (+start || 0);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = (+end || 0);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {\n      return this.reverse().takeWhile(predicate, thisArg).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(POSITIVE_INFINITY);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),\n          retUnwrapped = /^(?:first|last)$/.test(methodName),\n          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var args = retUnwrapped ? [1] : arguments,\n            chainAll = this.__chain__,\n            value = this.__wrapped__,\n            isHybrid = !!this.__actions__.length,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var interceptor = function(value) {\n          return (retUnwrapped && chainAll)\n            ? lodashFunc(value, 1)[0]\n            : lodashFunc.apply(undefined, arrayPush([value], args));\n        };\n\n        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },\n            onlyLazy = isLazy && !isHybrid;\n\n        if (retUnwrapped && !chainAll) {\n          if (onlyLazy) {\n            value = value.clone();\n            value.__actions__.push(action);\n            return func.call(value);\n          }\n          return lodashFunc.call(undefined, this.value())[0];\n        }\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push(action);\n          return new LodashWrapper(result, chainAll);\n        }\n        return this.thru(interceptor);\n      };\n    });\n\n    // Add `Array` and `String` methods to `lodash.prototype`.\n    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {\n      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          return func.apply(this.value(), args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(value, args);\n        });\n      };\n    });\n\n    // Map minified function names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name,\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\n\n    // Add functions to the lazy wrapper.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chaining functions to the `lodash` wrapper.\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.concat = wrapperConcat;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add function aliases to the `lodash` wrapper.\n    lodash.prototype.collect = lodash.prototype.map;\n    lodash.prototype.head = lodash.prototype.first;\n    lodash.prototype.select = lodash.prototype.filter;\n    lodash.prototype.tail = lodash.prototype.rest;\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\n  if (true) {\n    // Expose lodash to the global object when an AMD loader is present to avoid\n    // errors in cases where lodash is loaded by a script tag and not intended\n    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n    // more details.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for Node.js or RingoJS.\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // Export for Rhino with CommonJS support.\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // Export for a browser or Rhino.\n    root._ = _;\n  }\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(102)(module), (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/index.js\n ** module id = 134\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/lodash/index.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nmodule.exports = __webpack_require__(74);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-dom/index.js\n ** module id = 135\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-dom/index.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AutoFocusUtils\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactMount = __webpack_require__(6);\n\nvar findDOMNode = __webpack_require__(49);\nvar focusNode = __webpack_require__(63);\n\nvar Mixin = {\n  componentDidMount: function () {\n    if (this.props.autoFocus) {\n      focusNode(findDOMNode(this));\n    }\n  }\n};\n\nvar AutoFocusUtils = {\n  Mixin: Mixin,\n\n  focusDOMComponent: function () {\n    focusNode(ReactMount.getNode(this._rootNodeID));\n  }\n};\n\nmodule.exports = AutoFocusUtils;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/AutoFocusUtils.js\n ** module id = 136\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/AutoFocusUtils.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BeforeInputEventPlugin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPropagators = __webpack_require__(22);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar FallbackCompositionState = __webpack_require__(145);\nvar SyntheticCompositionEvent = __webpack_require__(177);\nvar SyntheticInputEvent = __webpack_require__(180);\n\nvar keyOf = __webpack_require__(13);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onBeforeInput: null }),\n      captured: keyOf({ onBeforeInputCapture: null })\n    },\n    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCompositionEnd: null }),\n      captured: keyOf({ onCompositionEndCapture: null })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCompositionStart: null }),\n      captured: keyOf({ onCompositionStartCapture: null })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCompositionUpdate: null }),\n      captured: keyOf({ onCompositionUpdateCapture: null })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionStart:\n      return eventTypes.compositionStart;\n    case topLevelTypes.topCompositionEnd:\n      return eventTypes.compositionEnd;\n    case topLevelTypes.topCompositionUpdate:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topKeyUp:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case topLevelTypes.topKeyDown:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case topLevelTypes.topKeyPress:\n    case topLevelTypes.topMouseDown:\n    case topLevelTypes.topBlur:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition fallback object, if any.\nvar currentComposition = null;\n\n/**\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {DOMEventTarget} topLevelTarget The listening component root node.\n * @param {string} topLevelTargetID ID of `topLevelTarget`.\n * @param {object} nativeEvent Native browser event.\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!currentComposition) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!currentComposition && eventType === eventTypes.compositionStart) {\n      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (currentComposition) {\n        fallbackData = currentComposition.getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionEnd:\n      return getDataFromCustomEvent(nativeEvent);\n    case topLevelTypes.topKeyPress:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case topLevelTypes.topTextInput:\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  if (currentComposition) {\n    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = currentComposition.getData();\n      FallbackCompositionState.release(currentComposition);\n      currentComposition = null;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case topLevelTypes.topPaste:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case topLevelTypes.topKeyPress:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {\n        return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case topLevelTypes.topCompositionEnd:\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {DOMEventTarget} topLevelTarget The listening component root node.\n * @param {string} topLevelTargetID ID of `topLevelTarget`.\n * @param {object} nativeEvent Native browser event.\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];\n  }\n};\n\nmodule.exports = BeforeInputEventPlugin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/BeforeInputEventPlugin.js\n ** module id = 137\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/BeforeInputEventPlugin.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSPropertyOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CSSProperty = __webpack_require__(68);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar ReactPerf = __webpack_require__(8);\n\nvar camelizeStyleName = __webpack_require__(118);\nvar dangerousStyleValue = __webpack_require__(185);\nvar hyphenateStyleName = __webpack_require__(123);\nvar memoizeStringOnly = __webpack_require__(127);\nvar warning = __webpack_require__(4);\n\nvar processStyleName = memoizeStringOnly(function (styleName) {\n  return hyphenateStyleName(styleName);\n});\n\nvar hasShorthandPropertyBug = false;\nvar styleFloatAccessor = 'cssFloat';\nif (ExecutionEnvironment.canUseDOM) {\n  var tempStyle = document.createElement('div').style;\n  try {\n    // IE8 throws \"Invalid argument.\" if resetting shorthand style properties.\n    tempStyle.font = '';\n  } catch (e) {\n    hasShorthandPropertyBug = true;\n  }\n  // IE8 only supports accessing cssFloat (standard) as styleFloat\n  if (document.documentElement.style.cssFloat === undefined) {\n    styleFloatAccessor = 'styleFloat';\n  }\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n\n  var warnHyphenatedStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;\n  };\n\n  var warnBadVendoredStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\\'t contain a semicolon. ' + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;\n  };\n\n  /**\n   * @param {string} name\n   * @param {*} value\n   */\n  var warnValidStyle = function (name, value) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value);\n    }\n  };\n}\n\n/**\n * Operations for dealing with CSS properties.\n */\nvar CSSPropertyOperations = {\n\n  /**\n   * Serializes a mapping of style properties for use as inline styles:\n   *\n   *   > createMarkupForStyles({width: '200px', height: 0})\n   *   \"width:200px;height:0;\"\n   *\n   * Undefined values are ignored so that declarative programming is easier.\n   * The result should be HTML-escaped before insertion into the DOM.\n   *\n   * @param {object} styles\n   * @return {?string}\n   */\n  createMarkupForStyles: function (styles) {\n    var serialized = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (process.env.NODE_ENV !== 'production') {\n        warnValidStyle(styleName, styleValue);\n      }\n      if (styleValue != null) {\n        serialized += processStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue) + ';';\n      }\n    }\n    return serialized || null;\n  },\n\n  /**\n   * Sets the value for multiple styles on a node.  If a value is specified as\n   * '' (empty string), the corresponding style property will be unset.\n   *\n   * @param {DOMElement} node\n   * @param {object} styles\n   */\n  setValueForStyles: function (node, styles) {\n    var style = node.style;\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        warnValidStyle(styleName, styles[styleName]);\n      }\n      var styleValue = dangerousStyleValue(styleName, styles[styleName]);\n      if (styleName === 'float') {\n        styleName = styleFloatAccessor;\n      }\n      if (styleValue) {\n        style[styleName] = styleValue;\n      } else {\n        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];\n        if (expansion) {\n          // Shorthand property that IE8 won't like unsetting, so unset each\n          // component to placate it\n          for (var individualStyleName in expansion) {\n            style[individualStyleName] = '';\n          }\n        } else {\n          style[styleName] = '';\n        }\n      }\n    }\n  }\n\n};\n\nReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {\n  setValueForStyles: 'setValueForStyles'\n});\n\nmodule.exports = CSSPropertyOperations;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSPropertyOperations.js\n ** module id = 138\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSPropertyOperations.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ChangeEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPluginHub = __webpack_require__(21);\nvar EventPropagators = __webpack_require__(22);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar ReactUpdates = __webpack_require__(9);\nvar SyntheticEvent = __webpack_require__(17);\n\nvar getEventTarget = __webpack_require__(52);\nvar isEventSupported = __webpack_require__(55);\nvar isTextInputElement = __webpack_require__(95);\nvar keyOf = __webpack_require__(13);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onChange: null }),\n      captured: keyOf({ onChangeCapture: null })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]\n  }\n};\n\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementID = null;\nvar activeElementValue = null;\nvar activeElementValueProp = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementID = null;\n}\n\nfunction getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topChange) {\n    return topLevelTargetID;\n  }\n}\nfunction handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events\n  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);\n}\n\n/**\n * (For old IE.) Replacement getter/setter for the `value` property that gets\n * set on the active element.\n */\nvar newValueProp = {\n  get: function () {\n    return activeElementValueProp.get.call(this);\n  },\n  set: function (val) {\n    // Cast to a string so we can do equality checks.\n    activeElementValue = '' + val;\n    activeElementValueProp.set.call(this, val);\n  }\n};\n\n/**\n * (For old IE.) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElementValue = target.value;\n  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');\n\n  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only\n  // on DOM elements\n  Object.defineProperty(activeElement, 'value', newValueProp);\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For old IE.) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  // delete restores the original property definition\n  delete activeElement.value;\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n\n  activeElement = null;\n  activeElementID = null;\n  activeElementValue = null;\n  activeElementValueProp = null;\n}\n\n/**\n * (For old IE.) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  var value = nativeEvent.srcElement.value;\n  if (value === activeElementValue) {\n    return;\n  }\n  activeElementValue = value;\n\n  manualDispatchChangeEvent(nativeEvent);\n}\n\n/**\n * If a `change` event should be fired, returns the target's ID.\n */\nfunction getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topInput) {\n    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly\n    // what we want so fall through here and trigger an abstract event\n    return topLevelTargetID;\n  }\n}\n\n// For IE8 and IE9.\nfunction handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    if (activeElement && activeElement.value !== activeElementValue) {\n      activeElementValue = activeElement.value;\n      return activeElementID;\n    }\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topClick) {\n    return topLevelTargetID;\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n\n    var getTargetIDFunc, handleEventFunc;\n    if (shouldUseChangeEvent(topLevelTarget)) {\n      if (doesChangeEventBubble) {\n        getTargetIDFunc = getTargetIDForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(topLevelTarget)) {\n      if (isInputEventSupported) {\n        getTargetIDFunc = getTargetIDForInputEvent;\n      } else {\n        getTargetIDFunc = getTargetIDForInputEventIE;\n        handleEventFunc = handleEventsForInputEventIE;\n      }\n    } else if (shouldUseClickEvent(topLevelTarget)) {\n      getTargetIDFunc = getTargetIDForClickEvent;\n    }\n\n    if (getTargetIDFunc) {\n      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);\n      if (targetID) {\n        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);\n        event.type = 'change';\n        EventPropagators.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);\n    }\n  }\n\n};\n\nmodule.exports = ChangeEventPlugin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ChangeEventPlugin.js\n ** module id = 139\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ChangeEventPlugin.js?");
},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ClientReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\nvar nextReactRootIndex = 0;\n\nvar ClientReactRootIndex = {\n  createReactRootIndex: function () {\n    return nextReactRootIndex++;\n  }\n};\n\nmodule.exports = ClientReactRootIndex;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ClientReactRootIndex.js\n ** module id = 140\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ClientReactRootIndex.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Danger\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar createNodesFromMarkup = __webpack_require__(120);\nvar emptyFunction = __webpack_require__(10);\nvar getMarkupWrap = __webpack_require__(65);\nvar invariant = __webpack_require__(2);\n\nvar OPEN_TAG_NAME_EXP = /^(<[^ \\/>]+)/;\nvar RESULT_INDEX_ATTR = 'data-danger-index';\n\n/**\n * Extracts the `nodeName` from a string of markup.\n *\n * NOTE: Extracting the `nodeName` does not require a regular expression match\n * because we make assumptions about React-generated markup (i.e. there are no\n * spaces surrounding the opening tag and there is at least one attribute).\n *\n * @param {string} markup String of markup.\n * @return {string} Node name of the supplied markup.\n * @see http://jsperf.com/extract-nodename\n */\nfunction getNodeName(markup) {\n  return markup.substring(1, markup.indexOf(' '));\n}\n\nvar Danger = {\n\n  /**\n   * Renders markup into an array of nodes. The markup is expected to render\n   * into a list of root nodes. Also, the length of `resultList` and\n   * `markupList` should be the same.\n   *\n   * @param {array<string>} markupList List of markup strings to render.\n   * @return {array<DOMElement>} List of rendered nodes.\n   * @internal\n   */\n  dangerouslyRenderMarkup: function (markupList) {\n    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;\n    var nodeName;\n    var markupByNodeName = {};\n    // Group markup by `nodeName` if a wrap is necessary, else by '*'.\n    for (var i = 0; i < markupList.length; i++) {\n      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;\n      nodeName = getNodeName(markupList[i]);\n      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';\n      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];\n      markupByNodeName[nodeName][i] = markupList[i];\n    }\n    var resultList = [];\n    var resultListAssignmentCount = 0;\n    for (nodeName in markupByNodeName) {\n      if (!markupByNodeName.hasOwnProperty(nodeName)) {\n        continue;\n      }\n      var markupListByNodeName = markupByNodeName[nodeName];\n\n      // This for-in loop skips the holes of the sparse array. The order of\n      // iteration should follow the order of assignment, which happens to match\n      // numerical index order, but we don't rely on that.\n      var resultIndex;\n      for (resultIndex in markupListByNodeName) {\n        if (markupListByNodeName.hasOwnProperty(resultIndex)) {\n          var markup = markupListByNodeName[resultIndex];\n\n          // Push the requested markup with an additional RESULT_INDEX_ATTR\n          // attribute.  If the markup does not start with a < character, it\n          // will be discarded below (with an appropriate console.error).\n          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,\n          // This index will be parsed back out below.\n          '$1 ' + RESULT_INDEX_ATTR + '=\"' + resultIndex + '\" ');\n        }\n      }\n\n      // Render each group of markup with similar wrapping `nodeName`.\n      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.\n      );\n\n      for (var j = 0; j < renderNodes.length; ++j) {\n        var renderNode = renderNodes[j];\n        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {\n\n          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);\n          renderNode.removeAttribute(RESULT_INDEX_ATTR);\n\n          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;\n\n          resultList[resultIndex] = renderNode;\n\n          // This should match resultList.length and markupList.length when\n          // we're done.\n          resultListAssignmentCount += 1;\n        } else if (process.env.NODE_ENV !== 'production') {\n          console.error('Danger: Discarding unexpected node:', renderNode);\n        }\n      }\n    }\n\n    // Although resultList was populated out of order, it should now be a dense\n    // array.\n    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;\n\n    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;\n\n    return resultList;\n  },\n\n  /**\n   * Replaces a node with a string of markup at its current position within its\n   * parent. The markup must render into a single root node.\n   *\n   * @param {DOMElement} oldChild Child node to replace.\n   * @param {string} markup Markup to render in place of the child node.\n   * @internal\n   */\n  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {\n    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;\n    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;\n    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;\n\n    var newChild;\n    if (typeof markup === 'string') {\n      newChild = createNodesFromMarkup(markup, emptyFunction)[0];\n    } else {\n      newChild = markup;\n    }\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n  }\n\n};\n\nmodule.exports = Danger;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Danger.js\n ** module id = 141\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Danger.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DefaultEventPluginOrder\n */\n\n'use strict';\n\nvar keyOf = __webpack_require__(13);\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];\n\nmodule.exports = DefaultEventPluginOrder;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DefaultEventPluginOrder.js\n ** module id = 142\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DefaultEventPluginOrder.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EnterLeaveEventPlugin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPropagators = __webpack_require__(22);\nvar SyntheticMouseEvent = __webpack_require__(29);\n\nvar ReactMount = __webpack_require__(6);\nvar keyOf = __webpack_require__(13);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\nvar getFirstReactDOM = ReactMount.getFirstReactDOM;\n\nvar eventTypes = {\n  mouseEnter: {\n    registrationName: keyOf({ onMouseEnter: null }),\n    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]\n  },\n  mouseLeave: {\n    registrationName: keyOf({ onMouseLeave: null }),\n    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]\n  }\n};\n\nvar extractedEvents = [null, null];\n\nvar EnterLeaveEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (topLevelTarget.window === topLevelTarget) {\n      // `topLevelTarget` is probably a window object.\n      win = topLevelTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = topLevelTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from;\n    var to;\n    var fromID = '';\n    var toID = '';\n    if (topLevelType === topLevelTypes.topMouseOut) {\n      from = topLevelTarget;\n      fromID = topLevelTargetID;\n      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);\n      if (to) {\n        toID = ReactMount.getID(to);\n      } else {\n        to = win;\n      }\n      to = to || win;\n    } else {\n      from = win;\n      to = topLevelTarget;\n      toID = topLevelTargetID;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = from;\n    leave.relatedTarget = to;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = to;\n    enter.relatedTarget = from;\n\n    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);\n\n    extractedEvents[0] = leave;\n    extractedEvents[1] = enter;\n\n    return extractedEvents;\n  }\n\n};\n\nmodule.exports = EnterLeaveEventPlugin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EnterLeaveEventPlugin.js\n ** module id = 143\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EnterLeaveEventPlugin.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginUtils\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar ReactErrorUtils = __webpack_require__(83);\n\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `Mount`: [required] Module that can convert between React dom IDs and\n *   actual node references.\n */\nvar injection = {\n  Mount: null,\n  injectMount: function (InjectedMount) {\n    injection.Mount = InjectedMount;\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;\n    }\n  }\n};\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nfunction isEndish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;\n}\n\nvar validateEventDispatches;\nif (process.env.NODE_ENV !== 'production') {\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchIDs = event._dispatchIDs;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var idsIsArr = Array.isArray(dispatchIDs);\n    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {string} domID DOM id to pass to the callback.\n */\nfunction executeDispatch(event, simulated, listener, domID) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = injection.Mount.getNode(domID);\n  if (simulated) {\n    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);\n  } else {\n    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);\n  }\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);\n  }\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchIDs[i])) {\n        return dispatchIDs[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchIDs)) {\n      return dispatchIDs;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchIDs = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  if (process.env.NODE_ENV !== 'production') {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchID = event._dispatchIDs;\n  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;\n  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n\n  getNode: function (id) {\n    return injection.Mount.getNode(id);\n  },\n  getID: function (node) {\n    return injection.Mount.getID(node);\n  },\n\n  injection: injection\n};\n\nmodule.exports = EventPluginUtils;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginUtils.js\n ** module id = 144\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginUtils.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FallbackCompositionState\n * @typechecks static-only\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(14);\n\nvar assign = __webpack_require__(3);\nvar getTextContentAccessor = __webpack_require__(94);\n\n/**\n * This helper class stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n * @param {DOMEventTarget} root\n */\nfunction FallbackCompositionState(root) {\n  this._root = root;\n  this._startText = this.getText();\n  this._fallbackText = null;\n}\n\nassign(FallbackCompositionState.prototype, {\n  destructor: function () {\n    this._root = null;\n    this._startText = null;\n    this._fallbackText = null;\n  },\n\n  /**\n   * Get current text of input.\n   *\n   * @return {string}\n   */\n  getText: function () {\n    if ('value' in this._root) {\n      return this._root.value;\n    }\n    return this._root[getTextContentAccessor()];\n  },\n\n  /**\n   * Determine the differing substring between the initially stored\n   * text content and the current content.\n   *\n   * @return {string}\n   */\n  getData: function () {\n    if (this._fallbackText) {\n      return this._fallbackText;\n    }\n\n    var start;\n    var startValue = this._startText;\n    var startLength = startValue.length;\n    var end;\n    var endValue = this.getText();\n    var endLength = endValue.length;\n\n    for (start = 0; start < startLength; start++) {\n      if (startValue[start] !== endValue[start]) {\n        break;\n      }\n    }\n\n    var minEnd = startLength - start;\n    for (end = 1; end <= minEnd; end++) {\n      if (startValue[startLength - end] !== endValue[endLength - end]) {\n        break;\n      }\n    }\n\n    var sliceTail = end > 1 ? 1 - end : undefined;\n    this._fallbackText = endValue.slice(start, sliceTail);\n    return this._fallbackText;\n  }\n});\n\nPooledClass.addPoolingTo(FallbackCompositionState);\n\nmodule.exports = FallbackCompositionState;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/FallbackCompositionState.js\n ** module id = 145\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/FallbackCompositionState.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule HTMLDOMPropertyConfig\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\nvar MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;\nvar HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;\nvar HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;\n\nvar hasSVG;\nif (ExecutionEnvironment.canUseDOM) {\n  var implementation = document.implementation;\n  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');\n}\n\nvar HTMLDOMPropertyConfig = {\n  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\\d_.\\-]*$/),\n  Properties: {\n    /**\n     * Standard Properties\n     */\n    accept: null,\n    acceptCharset: null,\n    accessKey: null,\n    action: null,\n    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    allowTransparency: MUST_USE_ATTRIBUTE,\n    alt: null,\n    async: HAS_BOOLEAN_VALUE,\n    autoComplete: null,\n    // autoFocus is polyfilled/normalized by AutoFocusUtils\n    // autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    cellPadding: null,\n    cellSpacing: null,\n    charSet: MUST_USE_ATTRIBUTE,\n    challenge: MUST_USE_ATTRIBUTE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    classID: MUST_USE_ATTRIBUTE,\n    // To set className on SVG elements, it's necessary to use .setAttribute;\n    // this works on HTML elements too in all browsers except IE8. Conveniently,\n    // IE8 doesn't support SVG and so we can simply use the attribute in\n    // browsers that support SVG and the property in browsers that don't,\n    // regardless of whether the element is HTML or SVG.\n    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,\n    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    colSpan: null,\n    content: null,\n    contentEditable: null,\n    contextMenu: MUST_USE_ATTRIBUTE,\n    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    coords: null,\n    crossOrigin: null,\n    data: null, // For `<object />` acts as `src`.\n    dateTime: MUST_USE_ATTRIBUTE,\n    'default': HAS_BOOLEAN_VALUE,\n    defer: HAS_BOOLEAN_VALUE,\n    dir: null,\n    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: null,\n    encType: null,\n    form: MUST_USE_ATTRIBUTE,\n    formAction: MUST_USE_ATTRIBUTE,\n    formEncType: MUST_USE_ATTRIBUTE,\n    formMethod: MUST_USE_ATTRIBUTE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    formTarget: MUST_USE_ATTRIBUTE,\n    frameBorder: MUST_USE_ATTRIBUTE,\n    headers: null,\n    height: MUST_USE_ATTRIBUTE,\n    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    high: null,\n    href: null,\n    hrefLang: null,\n    htmlFor: null,\n    httpEquiv: null,\n    icon: null,\n    id: MUST_USE_PROPERTY,\n    inputMode: MUST_USE_ATTRIBUTE,\n    integrity: null,\n    is: MUST_USE_ATTRIBUTE,\n    keyParams: MUST_USE_ATTRIBUTE,\n    keyType: MUST_USE_ATTRIBUTE,\n    kind: null,\n    label: null,\n    lang: null,\n    list: MUST_USE_ATTRIBUTE,\n    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    low: null,\n    manifest: MUST_USE_ATTRIBUTE,\n    marginHeight: null,\n    marginWidth: null,\n    max: null,\n    maxLength: MUST_USE_ATTRIBUTE,\n    media: MUST_USE_ATTRIBUTE,\n    mediaGroup: null,\n    method: null,\n    min: null,\n    minLength: MUST_USE_ATTRIBUTE,\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    name: null,\n    nonce: MUST_USE_ATTRIBUTE,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    optimum: null,\n    pattern: null,\n    placeholder: null,\n    poster: null,\n    preload: null,\n    radioGroup: null,\n    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    rel: null,\n    required: HAS_BOOLEAN_VALUE,\n    reversed: HAS_BOOLEAN_VALUE,\n    role: MUST_USE_ATTRIBUTE,\n    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: null,\n    sandbox: null,\n    scope: null,\n    scoped: HAS_BOOLEAN_VALUE,\n    scrolling: null,\n    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    shape: null,\n    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    sizes: MUST_USE_ATTRIBUTE,\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: null,\n    src: null,\n    srcDoc: MUST_USE_PROPERTY,\n    srcLang: null,\n    srcSet: MUST_USE_ATTRIBUTE,\n    start: HAS_NUMERIC_VALUE,\n    step: null,\n    style: null,\n    summary: null,\n    tabIndex: null,\n    target: null,\n    title: null,\n    type: null,\n    useMap: null,\n    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,\n    width: MUST_USE_ATTRIBUTE,\n    wmode: MUST_USE_ATTRIBUTE,\n    wrap: null,\n\n    /**\n     * RDFa Properties\n     */\n    about: MUST_USE_ATTRIBUTE,\n    datatype: MUST_USE_ATTRIBUTE,\n    inlist: MUST_USE_ATTRIBUTE,\n    prefix: MUST_USE_ATTRIBUTE,\n    // property is also supported for OpenGraph in meta tags.\n    property: MUST_USE_ATTRIBUTE,\n    resource: MUST_USE_ATTRIBUTE,\n    'typeof': MUST_USE_ATTRIBUTE,\n    vocab: MUST_USE_ATTRIBUTE,\n\n    /**\n     * Non-standard Properties\n     */\n    // autoCapitalize and autoCorrect are supported in Mobile Safari for\n    // keyboard hints.\n    autoCapitalize: MUST_USE_ATTRIBUTE,\n    autoCorrect: MUST_USE_ATTRIBUTE,\n    // autoSave allows WebKit/Blink to persist values of input fields on page reloads\n    autoSave: null,\n    // color is for Safari mask-icon link\n    color: null,\n    // itemProp, itemScope, itemType are for\n    // Microdata support. See http://schema.org/docs/gs.html\n    itemProp: MUST_USE_ATTRIBUTE,\n    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    itemType: MUST_USE_ATTRIBUTE,\n    // itemID and itemRef are for Microdata support as well but\n    // only specified in the the WHATWG spec document. See\n    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api\n    itemID: MUST_USE_ATTRIBUTE,\n    itemRef: MUST_USE_ATTRIBUTE,\n    // results show looking glass icon and recent searches on input\n    // search fields in WebKit/Blink\n    results: null,\n    // IE-only attribute that specifies security restrictions on an iframe\n    // as an alternative to the sandbox attribute on IE<10\n    security: MUST_USE_ATTRIBUTE,\n    // IE-only attribute that controls focus behavior\n    unselectable: MUST_USE_ATTRIBUTE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMPropertyNames: {\n    autoComplete: 'autocomplete',\n    autoFocus: 'autofocus',\n    autoPlay: 'autoplay',\n    autoSave: 'autosave',\n    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.\n    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding\n    encType: 'encoding',\n    hrefLang: 'hreflang',\n    radioGroup: 'radiogroup',\n    spellCheck: 'spellcheck',\n    srcDoc: 'srcdoc',\n    srcSet: 'srcset'\n  }\n};\n\nmodule.exports = HTMLDOMPropertyConfig;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/HTMLDOMPropertyConfig.js\n ** module id = 146\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/HTMLDOMPropertyConfig.js?");
},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule React\n */\n\n'use strict';\n\nvar ReactDOM = __webpack_require__(74);\nvar ReactDOMServer = __webpack_require__(157);\nvar ReactIsomorphic = __webpack_require__(164);\n\nvar assign = __webpack_require__(3);\nvar deprecated = __webpack_require__(186);\n\n// `version` will be added here by ReactIsomorphic.\nvar React = {};\n\nassign(React, ReactIsomorphic);\n\nassign(React, {\n  // ReactDOM\n  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),\n  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),\n  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),\n\n  // ReactDOMServer\n  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),\n  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)\n});\n\nReact.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;\nReact.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;\n\nmodule.exports = React;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/React.js\n ** module id = 147\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/React.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserComponentMixin\n */\n\n'use strict';\n\nvar ReactInstanceMap = __webpack_require__(23);\n\nvar findDOMNode = __webpack_require__(49);\nvar warning = __webpack_require__(4);\n\nvar didWarnKey = '_getDOMNodeDidWarn';\n\nvar ReactBrowserComponentMixin = {\n  /**\n   * Returns the DOM node rendered by this component.\n   *\n   * @return {DOMElement} The root node of this component.\n   * @final\n   * @protected\n   */\n  getDOMNode: function () {\n    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;\n    this.constructor[didWarnKey] = true;\n    return findDOMNode(this);\n  }\n};\n\nmodule.exports = ReactBrowserComponentMixin;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserComponentMixin.js\n ** module id = 148\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserComponentMixin.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildReconciler\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactReconciler = __webpack_require__(16);\n\nvar instantiateReactComponent = __webpack_require__(54);\nvar shouldUpdateReactComponent = __webpack_require__(57);\nvar traverseAllChildren = __webpack_require__(58);\nvar warning = __webpack_require__(4);\n\nfunction instantiateChild(childInstances, child, name) {\n  // We found a component instance.\n  var keyUnique = childInstances[name] === undefined;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;\n  }\n  if (child != null && keyUnique) {\n    childInstances[name] = instantiateReactComponent(child, null);\n  }\n}\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function (nestedChildNodes, transaction, context) {\n    if (nestedChildNodes == null) {\n      return null;\n    }\n    var childInstances = {};\n    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);\n    return childInstances;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function (prevChildren, nextChildren, transaction, context) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return null;\n    }\n    var name;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          ReactReconciler.unmountComponent(prevChild, name);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, null);\n        nextChildren[name] = nextChildInstance;\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        ReactReconciler.unmountComponent(prevChildren[name]);\n      }\n    }\n    return nextChildren;\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function (renderedChildren) {\n    for (var name in renderedChildren) {\n      if (renderedChildren.hasOwnProperty(name)) {\n        var renderedChild = renderedChildren[name];\n        ReactReconciler.unmountComponent(renderedChild);\n      }\n    }\n  }\n\n};\n\nmodule.exports = ReactChildReconciler;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactChildReconciler.js\n ** module id = 149\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactChildReconciler.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\n'use strict';\n\nvar ReactComponentEnvironment = __webpack_require__(45);\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactElement = __webpack_require__(7);\nvar ReactInstanceMap = __webpack_require__(23);\nvar ReactPerf = __webpack_require__(8);\nvar ReactPropTypeLocations = __webpack_require__(28);\nvar ReactPropTypeLocationNames = __webpack_require__(27);\nvar ReactReconciler = __webpack_require__(16);\nvar ReactUpdateQueue = __webpack_require__(47);\n\nvar assign = __webpack_require__(3);\nvar emptyObject = __webpack_require__(20);\nvar invariant = __webpack_require__(2);\nvar shouldUpdateReactComponent = __webpack_require__(57);\nvar warning = __webpack_require__(4);\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._currentElement._owner || null;\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction StatelessComponent(Component) {}\nStatelessComponent.prototype.render = function () {\n  var Component = ReactInstanceMap.get(this)._currentElement.type;\n  return Component(this.props, this.context, this.updater);\n};\n\n/**\n * ------------------ The Life-Cycle of a Composite Component ------------------\n *\n * - constructor: Initialization of state. The instance is now retained.\n *   - componentWillMount\n *   - render\n *   - [children's constructors]\n *     - [children's componentWillMount and render]\n *     - [children's componentDidMount]\n *     - componentDidMount\n *\n *       Update Phases:\n *       - componentWillReceiveProps (only called if parent updated)\n *       - shouldComponentUpdate\n *         - componentWillUpdate\n *           - render\n *           - [children's constructors or receive props phases]\n *         - componentDidUpdate\n *\n *     - componentWillUnmount\n *     - [children's componentWillUnmount]\n *   - [children destroyed]\n * - (destroyed): The instance is now blank, released by React and ready for GC.\n *\n * -----------------------------------------------------------------------------\n */\n\n/**\n * An incrementing ID assigned to each component when it is mounted. This is\n * used to enforce the order in which `ReactUpdates` updates dirty components.\n *\n * @private\n */\nvar nextMountID = 1;\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponentMixin = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function (element) {\n    this._currentElement = element;\n    this._rootNodeID = null;\n    this._instance = null;\n\n    // See ReactUpdateQueue\n    this._pendingElement = null;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    this._renderedComponent = null;\n\n    this._context = null;\n    this._mountOrder = 0;\n    this._topLevelWrapper = null;\n\n    // See ReactUpdates and ReactUpdateQueue.\n    this._pendingCallbacks = null;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._rootNodeID = rootID;\n\n    var publicProps = this._processProps(this._currentElement.props);\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type;\n\n    // Initialize the public class\n    var inst;\n    var renderedElement;\n\n    // This is a way to detect if Component is a stateless arrow function\n    // component, which is not newable. It might not be 100% reliable but is\n    // something we can do until we start detecting that Component extends\n    // React.Component. We already assume that typeof Component === 'function'.\n    var canInstantiate = ('prototype' in Component);\n\n    if (canInstantiate) {\n      if (process.env.NODE_ENV !== 'production') {\n        ReactCurrentOwner.current = this;\n        try {\n          inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n        } finally {\n          ReactCurrentOwner.current = null;\n        }\n      } else {\n        inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n      }\n    }\n\n    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {\n      renderedElement = inst;\n      inst = new StatelessComponent(Component);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw later in _renderValidatedComponent, but add an early\n      // warning now to help debugging\n      if (inst.render == null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;\n      } else {\n        // We support ES6 inheriting from React.Component, the module pattern,\n        // and stateless components, but not ES6 classes that don't extend\n        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;\n      }\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    inst.props = publicProps;\n    inst.context = publicContext;\n    inst.refs = emptyObject;\n    inst.updater = ReactUpdateQueue;\n\n    this._instance = inst;\n\n    // Store a reference from the instance back to the internal representation\n    ReactInstanceMap.set(inst, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Since plain JS classes are defined without any special initialization\n      // logic, we can not catch common errors early. Therefore, we have to\n      // catch them here, at initialization time, instead.\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;\n    }\n\n    var initialState = inst.state;\n    if (initialState === undefined) {\n      inst.state = initialState = null;\n    }\n    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    if (inst.componentWillMount) {\n      inst.componentWillMount();\n      // When mounting, calls to `setState` by `componentWillMount` will set\n      // `this._pendingStateQueue` without triggering a re-render.\n      if (this._pendingStateQueue) {\n        inst.state = this._processPendingState(inst.props, inst.context);\n      }\n    }\n\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    this._renderedComponent = this._instantiateReactComponent(renderedElement);\n\n    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));\n    if (inst.componentDidMount) {\n      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n    }\n\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function () {\n    var inst = this._instance;\n\n    if (inst.componentWillUnmount) {\n      inst.componentWillUnmount();\n    }\n\n    ReactReconciler.unmountComponent(this._renderedComponent);\n    this._renderedComponent = null;\n    this._instance = null;\n\n    // Reset pending fields\n    // Even if this component is scheduled for another update in ReactUpdates,\n    // it would still be ignored because these fields are reset.\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._pendingCallbacks = null;\n    this._pendingElement = null;\n\n    // These fields do not really need to be reset since this object is no\n    // longer accessible.\n    this._context = null;\n    this._rootNodeID = null;\n    this._topLevelWrapper = null;\n\n    // Delete the reference from the instance to this internal representation\n    // which allow the internals to be properly cleaned up even if the user\n    // leaks a reference to the public instance.\n    ReactInstanceMap.remove(inst);\n\n    // Some existing components rely on inst.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: inst.props = null;\n    // TODO: inst.state = null;\n    // TODO: inst.context = null;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _maskContext: function (context) {\n    var maskedContext = null;\n    var Component = this._currentElement.type;\n    var contextTypes = Component.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n    maskedContext = {};\n    for (var contextName in contextTypes) {\n      maskedContext[contextName] = context[contextName];\n    }\n    return maskedContext;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function (context) {\n    var maskedContext = this._maskContext(context);\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n      if (Component.contextTypes) {\n        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function (currentContext) {\n    var Component = this._currentElement.type;\n    var inst = this._instance;\n    var childContext = inst.getChildContext && inst.getChildContext();\n    if (childContext) {\n      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n      if (process.env.NODE_ENV !== 'production') {\n        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);\n      }\n      for (var name in childContext) {\n        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;\n      }\n      return assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function (newProps) {\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n      if (Component.propTypes) {\n        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function (propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.getName();\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error;\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;\n          error = propTypes[propName](props, propName, componentName, location);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // top-level render calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n\n          if (location === ReactPropTypeLocations.prop) {\n            // Preface gives us something to blacklist in warning module\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;\n          }\n        }\n      }\n    }\n  },\n\n  receiveComponent: function (nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (transaction) {\n    if (this._pendingElement != null) {\n      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);\n    }\n\n    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);\n    }\n  },\n\n  /**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {\n    var inst = this._instance;\n\n    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);\n    var nextProps;\n\n    // Distinguish between a props update versus a simple state update\n    if (prevParentElement === nextParentElement) {\n      // Skip checking prop types again -- we don't read inst.props to avoid\n      // warning for DOM component props in this upgrade\n      nextProps = nextParentElement.props;\n    } else {\n      nextProps = this._processProps(nextParentElement.props);\n      // An update here will schedule an update but immediately set\n      // _pendingStateQueue which will ensure that any state updates gets\n      // immediately reconciled instead of waiting for the next batch.\n\n      if (inst.componentWillReceiveProps) {\n        inst.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    var nextState = this._processPendingState(nextProps, nextContext);\n\n    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this._currentElement = nextParentElement;\n      this._context = nextUnmaskedContext;\n      inst.props = nextProps;\n      inst.state = nextState;\n      inst.context = nextContext;\n    }\n  },\n\n  _processPendingState: function (props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = assign({}, replace ? queue[0] : inst.state);\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);\n    }\n\n    return nextState;\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {\n    var inst = this._instance;\n\n    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);\n    var prevProps;\n    var prevState;\n    var prevContext;\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n      prevContext = inst.context;\n    }\n\n    if (inst.componentWillUpdate) {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    this._updateRenderedComponent(transaction, unmaskedContext);\n\n    if (hasComponentDidUpdate) {\n      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);\n    }\n  },\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function (transaction, context) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n    var nextRenderedElement = this._renderValidatedComponent();\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));\n    } else {\n      // These two IDs are actually the same! But nothing should rely on that.\n      var thisID = this._rootNodeID;\n      var prevComponentID = prevComponentInstance._rootNodeID;\n      ReactReconciler.unmountComponent(prevComponentInstance);\n\n      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);\n      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));\n      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {\n    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n  },\n\n  /**\n   * @protected\n   */\n  _renderValidatedComponentWithoutOwnerOrContext: function () {\n    var inst = this._instance;\n    var renderedComponent = inst.render();\n    if (process.env.NODE_ENV !== 'production') {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedComponent = null;\n      }\n    }\n\n    return renderedComponent;\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: function () {\n    var renderedComponent;\n    ReactCurrentOwner.current = this;\n    try {\n      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();\n    } finally {\n      ReactCurrentOwner.current = null;\n    }\n    !(\n    // TODO: An `isValidNode` function would probably be more appropriate\n    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n    return renderedComponent;\n  },\n\n  /**\n   * Lazily allocates the refs object and stores `component` as `ref`.\n   *\n   * @param {string} ref Reference name.\n   * @param {component} component Component to store as `ref`.\n   * @final\n   * @private\n   */\n  attachRef: function (ref, component) {\n    var inst = this.getPublicInstance();\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;\n    var publicComponentInstance = component.getPublicInstance();\n    if (process.env.NODE_ENV !== 'production') {\n      var componentName = component && component.getName ? component.getName() : 'a component';\n      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref \"%s\" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;\n    }\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n    refs[ref] = publicComponentInstance;\n  },\n\n  /**\n   * Detaches a reference name.\n   *\n   * @param {string} ref Name to dereference.\n   * @final\n   * @private\n   */\n  detachRef: function (ref) {\n    var refs = this.getPublicInstance().refs;\n    delete refs[ref];\n  },\n\n  /**\n   * Get a text description of the component that can be used to identify it\n   * in error messages.\n   * @return {string} The name or null.\n   * @internal\n   */\n  getName: function () {\n    var type = this._currentElement.type;\n    var constructor = this._instance && this._instance.constructor;\n    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;\n  },\n\n  /**\n   * Get the publicly accessible representation of this component - i.e. what\n   * is exposed by refs and returned by render. Can be null for stateless\n   * components.\n   *\n   * @return {ReactComponent} the public component instance.\n   * @internal\n   */\n  getPublicInstance: function () {\n    var inst = this._instance;\n    if (inst instanceof StatelessComponent) {\n      return null;\n    }\n    return inst;\n  },\n\n  // Stub\n  _instantiateReactComponent: null\n\n};\n\nReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {\n  mountComponent: 'mountComponent',\n  updateComponent: 'updateComponent',\n  _renderValidatedComponent: '_renderValidatedComponent'\n});\n\nvar ReactCompositeComponent = {\n\n  Mixin: ReactCompositeComponentMixin\n\n};\n\nmodule.exports = ReactCompositeComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCompositeComponent.js\n ** module id = 150\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCompositeComponent.js?");
},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMButton\n */\n\n'use strict';\n\nvar mouseListenerNames = {\n  onClick: true,\n  onDoubleClick: true,\n  onMouseDown: true,\n  onMouseMove: true,\n  onMouseUp: true,\n\n  onClickCapture: true,\n  onDoubleClickCapture: true,\n  onMouseDownCapture: true,\n  onMouseMoveCapture: true,\n  onMouseUpCapture: true\n};\n\n/**\n * Implements a <button> native component that does not receive mouse events\n * when `disabled` is set.\n */\nvar ReactDOMButton = {\n  getNativeProps: function (inst, props, context) {\n    if (!props.disabled) {\n      return props;\n    }\n\n    // Copy the props, except the mouse listeners\n    var nativeProps = {};\n    for (var key in props) {\n      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {\n        nativeProps[key] = props[key];\n      }\n    }\n\n    return nativeProps;\n  }\n};\n\nmodule.exports = ReactDOMButton;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMButton.js\n ** module id = 151\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMButton.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMComponent\n * @typechecks static-only\n */\n\n/* global hasOwnProperty:true */\n\n'use strict';\n\nvar AutoFocusUtils = __webpack_require__(136);\nvar CSSPropertyOperations = __webpack_require__(138);\nvar DOMProperty = __webpack_require__(15);\nvar DOMPropertyOperations = __webpack_require__(42);\nvar EventConstants = __webpack_require__(11);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactComponentBrowserEnvironment = __webpack_require__(44);\nvar ReactDOMButton = __webpack_require__(151);\nvar ReactDOMInput = __webpack_require__(154);\nvar ReactDOMOption = __webpack_require__(155);\nvar ReactDOMSelect = __webpack_require__(76);\nvar ReactDOMTextarea = __webpack_require__(158);\nvar ReactMount = __webpack_require__(6);\nvar ReactMultiChild = __webpack_require__(165);\nvar ReactPerf = __webpack_require__(8);\nvar ReactUpdateQueue = __webpack_require__(47);\n\nvar assign = __webpack_require__(3);\nvar canDefineProperty = __webpack_require__(31);\nvar escapeTextContentForBrowser = __webpack_require__(32);\nvar invariant = __webpack_require__(2);\nvar isEventSupported = __webpack_require__(55);\nvar keyOf = __webpack_require__(13);\nvar setInnerHTML = __webpack_require__(33);\nvar setTextContent = __webpack_require__(56);\nvar shallowEqual = __webpack_require__(66);\nvar validateDOMNesting = __webpack_require__(59);\nvar warning = __webpack_require__(4);\n\nvar deleteListener = ReactBrowserEventEmitter.deleteListener;\nvar listenTo = ReactBrowserEventEmitter.listenTo;\nvar registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;\n\n// For quickly matching children type, to test if can be treated as content.\nvar CONTENT_TYPES = { 'string': true, 'number': true };\n\nvar CHILDREN = keyOf({ children: null });\nvar STYLE = keyOf({ style: null });\nvar HTML = keyOf({ __html: null });\n\nvar ELEMENT_NODE_TYPE = 1;\n\nfunction getDeclarationErrorAddendum(internalInstance) {\n  if (internalInstance) {\n    var owner = internalInstance._currentElement._owner || null;\n    if (owner) {\n      var name = owner.getName();\n      if (name) {\n        return ' This DOM node was rendered by `' + name + '`.';\n      }\n    }\n  }\n  return '';\n}\n\nvar legacyPropsDescriptor;\nif (process.env.NODE_ENV !== 'production') {\n  legacyPropsDescriptor = {\n    props: {\n      enumerable: false,\n      get: function () {\n        var component = this._reactInternalComponent;\n        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;\n        return component._currentElement.props;\n      }\n    }\n  };\n}\n\nfunction legacyGetDOMNode() {\n  if (process.env.NODE_ENV !== 'production') {\n    var component = this._reactInternalComponent;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;\n  }\n  return this;\n}\n\nfunction legacyIsMounted() {\n  var component = this._reactInternalComponent;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;\n  }\n  return !!component;\n}\n\nfunction legacySetStateEtc() {\n  if (process.env.NODE_ENV !== 'production') {\n    var component = this._reactInternalComponent;\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;\n  }\n}\n\nfunction legacySetProps(partialProps, callback) {\n  var component = this._reactInternalComponent;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;\n  }\n  if (!component) {\n    return;\n  }\n  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);\n  if (callback) {\n    ReactUpdateQueue.enqueueCallbackInternal(component, callback);\n  }\n}\n\nfunction legacyReplaceProps(partialProps, callback) {\n  var component = this._reactInternalComponent;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;\n  }\n  if (!component) {\n    return;\n  }\n  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);\n  if (callback) {\n    ReactUpdateQueue.enqueueCallbackInternal(component, callback);\n  }\n}\n\nfunction friendlyStringify(obj) {\n  if (typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return '[' + obj.map(friendlyStringify).join(', ') + ']';\n    } else {\n      var pairs = [];\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var keyEscaped = /^[a-z$_][\\w$_]*$/i.test(key) ? key : JSON.stringify(key);\n          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));\n        }\n      }\n      return '{' + pairs.join(', ') + '}';\n    }\n  } else if (typeof obj === 'string') {\n    return JSON.stringify(obj);\n  } else if (typeof obj === 'function') {\n    return '[function object]';\n  }\n  // Differs from JSON.stringify in that undefined becauses undefined and that\n  // inf and nan don't become null\n  return String(obj);\n}\n\nvar styleMutationWarning = {};\n\nfunction checkAndWarnForMutatedStyle(style1, style2, component) {\n  if (style1 == null || style2 == null) {\n    return;\n  }\n  if (shallowEqual(style1, style2)) {\n    return;\n  }\n\n  var componentName = component._tag;\n  var owner = component._currentElement._owner;\n  var ownerName;\n  if (owner) {\n    ownerName = owner.getName();\n  }\n\n  var hash = ownerName + '|' + componentName;\n\n  if (styleMutationWarning.hasOwnProperty(hash)) {\n    return;\n  }\n\n  styleMutationWarning[hash] = true;\n\n  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;\n}\n\n/**\n * @param {object} component\n * @param {?object} props\n */\nfunction assertValidProps(component, props) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (process.env.NODE_ENV !== 'production') {\n    if (voidElementTags[component._tag]) {\n      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;\n    }\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;\n    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;\n  }\n  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \\'em\\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;\n}\n\nfunction enqueuePutListener(id, registrationName, listener, transaction) {\n  if (process.env.NODE_ENV !== 'production') {\n    // IE8 has no API for event capturing and the `onScroll` event doesn't\n    // bubble.\n    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\\'t support the `onScroll` event') : undefined;\n  }\n  var container = ReactMount.findReactContainerForID(id);\n  if (container) {\n    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;\n    listenTo(registrationName, doc);\n  }\n  transaction.getReactMountReady().enqueue(putListener, {\n    id: id,\n    registrationName: registrationName,\n    listener: listener\n  });\n}\n\nfunction putListener() {\n  var listenerToPut = this;\n  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);\n}\n\n// There are so many media events, it makes sense to just\n// maintain a list rather than create a `trapBubbledEvent` for each\nvar mediaEvents = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\nfunction trapBubbledEventsLocal() {\n  var inst = this;\n  // If a component renders to null or if another component fatals and causes\n  // the state of the tree to be corrupted, `node` here can be null.\n  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;\n  var node = ReactMount.getNode(inst._rootNodeID);\n  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;\n\n  switch (inst._tag) {\n    case 'iframe':\n      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];\n      break;\n    case 'video':\n    case 'audio':\n\n      inst._wrapperState.listeners = [];\n      // create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));\n        }\n      }\n\n      break;\n    case 'img':\n      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];\n      break;\n    case 'form':\n      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];\n      break;\n  }\n}\n\nfunction mountReadyInputWrapper() {\n  ReactDOMInput.mountReadyWrapper(this);\n}\n\nfunction postUpdateSelectWrapper() {\n  ReactDOMSelect.postUpdateWrapper(this);\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special cased tags.\n\nvar omittedCloseTags = {\n  'area': true,\n  'base': true,\n  'br': true,\n  'col': true,\n  'embed': true,\n  'hr': true,\n  'img': true,\n  'input': true,\n  'keygen': true,\n  'link': true,\n  'meta': true,\n  'param': true,\n  'source': true,\n  'track': true,\n  'wbr': true\n};\n\n// NOTE: menuitem's close tag should be omitted, but that causes problems.\nvar newlineEatingTags = {\n  'listing': true,\n  'pre': true,\n  'textarea': true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = assign({\n  'menuitem': true\n}, omittedCloseTags);\n\n// We accept any tag to be rendered but since this gets injected into arbitrary\n// HTML, we want to make sure that it's a safe tag.\n// http://www.w3.org/TR/REC-xml/#NT-Name\n\nvar VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\nvar validatedTagCache = {};\nvar hasOwnProperty = ({}).hasOwnProperty;\n\nfunction validateDangerousTag(tag) {\n  if (!hasOwnProperty.call(validatedTagCache, tag)) {\n    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;\n    validatedTagCache[tag] = true;\n  }\n}\n\nfunction processChildContextDev(context, inst) {\n  // Pass down our tag name to child components for validation purposes\n  context = assign({}, context);\n  var info = context[validateDOMNesting.ancestorInfoContextKey];\n  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);\n  return context;\n}\n\nfunction isCustomComponent(tagName, props) {\n  return tagName.indexOf('-') >= 0 || props.is != null;\n}\n\n/**\n * Creates a new React class that is idempotent and capable of containing other\n * React components. It accepts event listeners and DOM properties that are\n * valid according to `DOMProperty`.\n *\n *  - Event listeners: `onClick`, `onMouseDown`, etc.\n *  - DOM properties: `className`, `name`, `title`, etc.\n *\n * The `style` property functions differently from the DOM API. It accepts an\n * object mapping of style properties to values.\n *\n * @constructor ReactDOMComponent\n * @extends ReactMultiChild\n */\nfunction ReactDOMComponent(tag) {\n  validateDangerousTag(tag);\n  this._tag = tag.toLowerCase();\n  this._renderedChildren = null;\n  this._previousStyle = null;\n  this._previousStyleCopy = null;\n  this._rootNodeID = null;\n  this._wrapperState = null;\n  this._topLevelWrapper = null;\n  this._nodeWithLegacyProperties = null;\n  if (process.env.NODE_ENV !== 'production') {\n    this._unprocessedContextDev = null;\n    this._processedContextDev = null;\n  }\n}\n\nReactDOMComponent.displayName = 'ReactDOMComponent';\n\nReactDOMComponent.Mixin = {\n\n  construct: function (element) {\n    this._currentElement = element;\n  },\n\n  /**\n   * Generates root tag markup then recurses. This method has side effects and\n   * is not idempotent.\n   *\n   * @internal\n   * @param {string} rootID The root DOM ID for this node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} context\n   * @return {string} The computed markup.\n   */\n  mountComponent: function (rootID, transaction, context) {\n    this._rootNodeID = rootID;\n\n    var props = this._currentElement.props;\n\n    switch (this._tag) {\n      case 'iframe':\n      case 'img':\n      case 'form':\n      case 'video':\n      case 'audio':\n        this._wrapperState = {\n          listeners: null\n        };\n        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);\n        break;\n      case 'button':\n        props = ReactDOMButton.getNativeProps(this, props, context);\n        break;\n      case 'input':\n        ReactDOMInput.mountWrapper(this, props, context);\n        props = ReactDOMInput.getNativeProps(this, props, context);\n        break;\n      case 'option':\n        ReactDOMOption.mountWrapper(this, props, context);\n        props = ReactDOMOption.getNativeProps(this, props, context);\n        break;\n      case 'select':\n        ReactDOMSelect.mountWrapper(this, props, context);\n        props = ReactDOMSelect.getNativeProps(this, props, context);\n        context = ReactDOMSelect.processChildContext(this, props, context);\n        break;\n      case 'textarea':\n        ReactDOMTextarea.mountWrapper(this, props, context);\n        props = ReactDOMTextarea.getNativeProps(this, props, context);\n        break;\n    }\n\n    assertValidProps(this, props);\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._unprocessedContextDev = context;\n      this._processedContextDev = processChildContextDev(context, this);\n      context = this._processedContextDev;\n    }\n\n    var mountImage;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement(this._currentElement.type);\n      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);\n      // Populate node cache\n      ReactMount.getID(el);\n      this._updateDOMProperties({}, props, transaction, el);\n      this._createInitialChildren(transaction, props, context, el);\n      mountImage = el;\n    } else {\n      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);\n      var tagContent = this._createContentMarkup(transaction, props, context);\n      if (!tagContent && omittedCloseTags[this._tag]) {\n        mountImage = tagOpen + '/>';\n      } else {\n        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';\n      }\n    }\n\n    switch (this._tag) {\n      case 'input':\n        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);\n      // falls through\n      case 'button':\n      case 'select':\n      case 'textarea':\n        if (props.autoFocus) {\n          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);\n        }\n        break;\n    }\n\n    return mountImage;\n  },\n\n  /**\n   * Creates markup for the open tag and all attributes.\n   *\n   * This method has side effects because events get registered.\n   *\n   * Iterating over object properties is faster than iterating over arrays.\n   * @see http://jsperf.com/obj-vs-arr-iteration\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} props\n   * @return {string} Markup of opening tag.\n   */\n  _createOpenTagMarkupAndPutListeners: function (transaction, props) {\n    var ret = '<' + this._currentElement.type;\n\n    for (var propKey in props) {\n      if (!props.hasOwnProperty(propKey)) {\n        continue;\n      }\n      var propValue = props[propKey];\n      if (propValue == null) {\n        continue;\n      }\n      if (registrationNameModules.hasOwnProperty(propKey)) {\n        if (propValue) {\n          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);\n        }\n      } else {\n        if (propKey === STYLE) {\n          if (propValue) {\n            if (process.env.NODE_ENV !== 'production') {\n              // See `_updateDOMProperties`. style block\n              this._previousStyle = propValue;\n            }\n            propValue = this._previousStyleCopy = assign({}, props.style);\n          }\n          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);\n        }\n        var markup = null;\n        if (this._tag != null && isCustomComponent(this._tag, props)) {\n          if (propKey !== CHILDREN) {\n            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);\n          }\n        } else {\n          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);\n        }\n        if (markup) {\n          ret += ' ' + markup;\n        }\n      }\n    }\n\n    // For static pages, no need to put React ID and checksum. Saves lots of\n    // bytes.\n    if (transaction.renderToStaticMarkup) {\n      return ret;\n    }\n\n    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);\n    return ret + ' ' + markupForID;\n  },\n\n  /**\n   * Creates markup for the content between the tags.\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} props\n   * @param {object} context\n   * @return {string} Content markup.\n   */\n  _createContentMarkup: function (transaction, props, context) {\n    var ret = '';\n\n    // Intentional use of != to avoid catching zero/false.\n    var innerHTML = props.dangerouslySetInnerHTML;\n    if (innerHTML != null) {\n      if (innerHTML.__html != null) {\n        ret = innerHTML.__html;\n      }\n    } else {\n      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;\n      var childrenToUse = contentToUse != null ? null : props.children;\n      if (contentToUse != null) {\n        // TODO: Validate that text is allowed as a child of this node\n        ret = escapeTextContentForBrowser(contentToUse);\n      } else if (childrenToUse != null) {\n        var mountImages = this.mountChildren(childrenToUse, transaction, context);\n        ret = mountImages.join('');\n      }\n    }\n    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\\n') {\n      // text/html ignores the first character in these tags if it's a newline\n      // Prefer to break application/xml over text/html (for now) by adding\n      // a newline specifically to get eaten by the parser. (Alternately for\n      // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n      // \\r is normalized out by HTMLTextAreaElement#value.)\n      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n      // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n      return '\\n' + ret;\n    } else {\n      return ret;\n    }\n  },\n\n  _createInitialChildren: function (transaction, props, context, el) {\n    // Intentional use of != to avoid catching zero/false.\n    var innerHTML = props.dangerouslySetInnerHTML;\n    if (innerHTML != null) {\n      if (innerHTML.__html != null) {\n        setInnerHTML(el, innerHTML.__html);\n      }\n    } else {\n      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;\n      var childrenToUse = contentToUse != null ? null : props.children;\n      if (contentToUse != null) {\n        // TODO: Validate that text is allowed as a child of this node\n        setTextContent(el, contentToUse);\n      } else if (childrenToUse != null) {\n        var mountImages = this.mountChildren(childrenToUse, transaction, context);\n        for (var i = 0; i < mountImages.length; i++) {\n          el.appendChild(mountImages[i]);\n        }\n      }\n    }\n  },\n\n  /**\n   * Receives a next element and updates the component.\n   *\n   * @internal\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} context\n   */\n  receiveComponent: function (nextElement, transaction, context) {\n    var prevElement = this._currentElement;\n    this._currentElement = nextElement;\n    this.updateComponent(transaction, prevElement, nextElement, context);\n  },\n\n  /**\n   * Updates a native DOM component after it has already been allocated and\n   * attached to the DOM. Reconciles the root DOM node, then recurses.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @param {ReactElement} nextElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function (transaction, prevElement, nextElement, context) {\n    var lastProps = prevElement.props;\n    var nextProps = this._currentElement.props;\n\n    switch (this._tag) {\n      case 'button':\n        lastProps = ReactDOMButton.getNativeProps(this, lastProps);\n        nextProps = ReactDOMButton.getNativeProps(this, nextProps);\n        break;\n      case 'input':\n        ReactDOMInput.updateWrapper(this);\n        lastProps = ReactDOMInput.getNativeProps(this, lastProps);\n        nextProps = ReactDOMInput.getNativeProps(this, nextProps);\n        break;\n      case 'option':\n        lastProps = ReactDOMOption.getNativeProps(this, lastProps);\n        nextProps = ReactDOMOption.getNativeProps(this, nextProps);\n        break;\n      case 'select':\n        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);\n        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);\n        break;\n      case 'textarea':\n        ReactDOMTextarea.updateWrapper(this);\n        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);\n        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);\n        break;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // If the context is reference-equal to the old one, pass down the same\n      // processed object so the update bailout in ReactReconciler behaves\n      // correctly (and identically in dev and prod). See #5005.\n      if (this._unprocessedContextDev !== context) {\n        this._unprocessedContextDev = context;\n        this._processedContextDev = processChildContextDev(context, this);\n      }\n      context = this._processedContextDev;\n    }\n\n    assertValidProps(this, nextProps);\n    this._updateDOMProperties(lastProps, nextProps, transaction, null);\n    this._updateDOMChildren(lastProps, nextProps, transaction, context);\n\n    if (!canDefineProperty && this._nodeWithLegacyProperties) {\n      this._nodeWithLegacyProperties.props = nextProps;\n    }\n\n    if (this._tag === 'select') {\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);\n    }\n  },\n\n  /**\n   * Reconciles the properties by detecting differences in property values and\n   * updating the DOM as necessary. This function is probably the single most\n   * critical path for performance optimization.\n   *\n   * TODO: Benchmark whether checking for changed values in memory actually\n   *       improves performance (especially statically positioned elements).\n   * TODO: Benchmark the effects of putting this at the top since 99% of props\n   *       do not change for a given reconciliation.\n   * TODO: Benchmark areas that can be improved with caching.\n   *\n   * @private\n   * @param {object} lastProps\n   * @param {object} nextProps\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?DOMElement} node\n   */\n  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {\n    var propKey;\n    var styleName;\n    var styleUpdates;\n    for (propKey in lastProps) {\n      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        var lastStyle = this._previousStyleCopy;\n        for (styleName in lastStyle) {\n          if (lastStyle.hasOwnProperty(styleName)) {\n            styleUpdates = styleUpdates || {};\n            styleUpdates[styleName] = '';\n          }\n        }\n        this._previousStyleCopy = null;\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        if (lastProps[propKey]) {\n          // Only call deleteListener if there was a listener previously or\n          // else willDeleteListener gets called when there wasn't actually a\n          // listener (e.g., onClick={null})\n          deleteListener(this._rootNodeID, propKey);\n        }\n      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {\n        if (!node) {\n          node = ReactMount.getNode(this._rootNodeID);\n        }\n        DOMPropertyOperations.deleteValueForProperty(node, propKey);\n      }\n    }\n    for (propKey in nextProps) {\n      var nextProp = nextProps[propKey];\n      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];\n      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        if (nextProp) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);\n            this._previousStyle = nextProp;\n          }\n          nextProp = this._previousStyleCopy = assign({}, nextProp);\n        } else {\n          this._previousStyleCopy = null;\n        }\n        if (lastProp) {\n          // Unset styles on `lastProp` but not on `nextProp`.\n          for (styleName in lastProp) {\n            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `lastProp`.\n          for (styleName in nextProp) {\n            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Relies on `updateStylesByID` not mutating `styleUpdates`.\n          styleUpdates = nextProp;\n        }\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        if (nextProp) {\n          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);\n        } else if (lastProp) {\n          deleteListener(this._rootNodeID, propKey);\n        }\n      } else if (isCustomComponent(this._tag, nextProps)) {\n        if (!node) {\n          node = ReactMount.getNode(this._rootNodeID);\n        }\n        if (propKey === CHILDREN) {\n          nextProp = null;\n        }\n        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);\n      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {\n        if (!node) {\n          node = ReactMount.getNode(this._rootNodeID);\n        }\n        // If we're updating to null or undefined, we should remove the property\n        // from the DOM node instead of inadvertantly setting to a string. This\n        // brings us in line with the same behavior we have on initial render.\n        if (nextProp != null) {\n          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);\n        } else {\n          DOMPropertyOperations.deleteValueForProperty(node, propKey);\n        }\n      }\n    }\n    if (styleUpdates) {\n      if (!node) {\n        node = ReactMount.getNode(this._rootNodeID);\n      }\n      CSSPropertyOperations.setValueForStyles(node, styleUpdates);\n    }\n  },\n\n  /**\n   * Reconciles the children with the various properties that affect the\n   * children content.\n   *\n   * @param {object} lastProps\n   * @param {object} nextProps\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   */\n  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {\n    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;\n    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;\n\n    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;\n    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;\n\n    // Note the use of `!=` which checks for null or undefined.\n    var lastChildren = lastContent != null ? null : lastProps.children;\n    var nextChildren = nextContent != null ? null : nextProps.children;\n\n    // If we're switching from children to content/html or vice versa, remove\n    // the old content\n    var lastHasContentOrHtml = lastContent != null || lastHtml != null;\n    var nextHasContentOrHtml = nextContent != null || nextHtml != null;\n    if (lastChildren != null && nextChildren == null) {\n      this.updateChildren(null, transaction, context);\n    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {\n      this.updateTextContent('');\n    }\n\n    if (nextContent != null) {\n      if (lastContent !== nextContent) {\n        this.updateTextContent('' + nextContent);\n      }\n    } else if (nextHtml != null) {\n      if (lastHtml !== nextHtml) {\n        this.updateMarkup('' + nextHtml);\n      }\n    } else if (nextChildren != null) {\n      this.updateChildren(nextChildren, transaction, context);\n    }\n  },\n\n  /**\n   * Destroys all event registrations for this instance. Does not remove from\n   * the DOM. That must be done by the parent.\n   *\n   * @internal\n   */\n  unmountComponent: function () {\n    switch (this._tag) {\n      case 'iframe':\n      case 'img':\n      case 'form':\n      case 'video':\n      case 'audio':\n        var listeners = this._wrapperState.listeners;\n        if (listeners) {\n          for (var i = 0; i < listeners.length; i++) {\n            listeners[i].remove();\n          }\n        }\n        break;\n      case 'input':\n        ReactDOMInput.unmountWrapper(this);\n        break;\n      case 'html':\n      case 'head':\n      case 'body':\n        /**\n         * Components like <html> <head> and <body> can't be removed or added\n         * easily in a cross-browser way, however it's valuable to be able to\n         * take advantage of React's reconciliation for styling and <title>\n         * management. So we just document it and throw in dangerous cases.\n         */\n         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;\n        break;\n    }\n\n    this.unmountChildren();\n    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n    this._rootNodeID = null;\n    this._wrapperState = null;\n    if (this._nodeWithLegacyProperties) {\n      var node = this._nodeWithLegacyProperties;\n      node._reactInternalComponent = null;\n      this._nodeWithLegacyProperties = null;\n    }\n  },\n\n  getPublicInstance: function () {\n    if (!this._nodeWithLegacyProperties) {\n      var node = ReactMount.getNode(this._rootNodeID);\n\n      node._reactInternalComponent = this;\n      node.getDOMNode = legacyGetDOMNode;\n      node.isMounted = legacyIsMounted;\n      node.setState = legacySetStateEtc;\n      node.replaceState = legacySetStateEtc;\n      node.forceUpdate = legacySetStateEtc;\n      node.setProps = legacySetProps;\n      node.replaceProps = legacyReplaceProps;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (canDefineProperty) {\n          Object.defineProperties(node, legacyPropsDescriptor);\n        } else {\n          // updateComponent will update this property on subsequent renders\n          node.props = this._currentElement.props;\n        }\n      } else {\n        // updateComponent will update this property on subsequent renders\n        node.props = this._currentElement.props;\n      }\n\n      this._nodeWithLegacyProperties = node;\n    }\n    return this._nodeWithLegacyProperties;\n  }\n\n};\n\nReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {\n  mountComponent: 'mountComponent',\n  updateComponent: 'updateComponent'\n});\n\nassign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);\n\nmodule.exports = ReactDOMComponent;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMComponent.js\n ** module id = 152\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMComponent.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMFactories\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(7);\nvar ReactElementValidator = __webpack_require__(80);\n\nvar mapObject = __webpack_require__(126);\n\n/**\n * Create a factory that creates HTML tag elements.\n *\n * @param {string} tag Tag name (e.g. `div`).\n * @private\n */\nfunction createDOMFactory(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    return ReactElementValidator.createFactory(tag);\n  }\n  return ReactElement.createFactory(tag);\n}\n\n/**\n * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.\n * This is also accessible via `React.DOM`.\n *\n * @public\n */\nvar ReactDOMFactories = mapObject({\n  a: 'a',\n  abbr: 'abbr',\n  address: 'address',\n  area: 'area',\n  article: 'article',\n  aside: 'aside',\n  audio: 'audio',\n  b: 'b',\n  base: 'base',\n  bdi: 'bdi',\n  bdo: 'bdo',\n  big: 'big',\n  blockquote: 'blockquote',\n  body: 'body',\n  br: 'br',\n  button: 'button',\n  canvas: 'canvas',\n  caption: 'caption',\n  cite: 'cite',\n  code: 'code',\n  col: 'col',\n  colgroup: 'colgroup',\n  data: 'data',\n  datalist: 'datalist',\n  dd: 'dd',\n  del: 'del',\n  details: 'details',\n  dfn: 'dfn',\n  dialog: 'dialog',\n  div: 'div',\n  dl: 'dl',\n  dt: 'dt',\n  em: 'em',\n  embed: 'embed',\n  fieldset: 'fieldset',\n  figcaption: 'figcaption',\n  figure: 'figure',\n  footer: 'footer',\n  form: 'form',\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  head: 'head',\n  header: 'header',\n  hgroup: 'hgroup',\n  hr: 'hr',\n  html: 'html',\n  i: 'i',\n  iframe: 'iframe',\n  img: 'img',\n  input: 'input',\n  ins: 'ins',\n  kbd: 'kbd',\n  keygen: 'keygen',\n  label: 'label',\n  legend: 'legend',\n  li: 'li',\n  link: 'link',\n  main: 'main',\n  map: 'map',\n  mark: 'mark',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  meta: 'meta',\n  meter: 'meter',\n  nav: 'nav',\n  noscript: 'noscript',\n  object: 'object',\n  ol: 'ol',\n  optgroup: 'optgroup',\n  option: 'option',\n  output: 'output',\n  p: 'p',\n  param: 'param',\n  picture: 'picture',\n  pre: 'pre',\n  progress: 'progress',\n  q: 'q',\n  rp: 'rp',\n  rt: 'rt',\n  ruby: 'ruby',\n  s: 's',\n  samp: 'samp',\n  script: 'script',\n  section: 'section',\n  select: 'select',\n  small: 'small',\n  source: 'source',\n  span: 'span',\n  strong: 'strong',\n  style: 'style',\n  sub: 'sub',\n  summary: 'summary',\n  sup: 'sup',\n  table: 'table',\n  tbody: 'tbody',\n  td: 'td',\n  textarea: 'textarea',\n  tfoot: 'tfoot',\n  th: 'th',\n  thead: 'thead',\n  time: 'time',\n  title: 'title',\n  tr: 'tr',\n  track: 'track',\n  u: 'u',\n  ul: 'ul',\n  'var': 'var',\n  video: 'video',\n  wbr: 'wbr',\n\n  // SVG\n  circle: 'circle',\n  clipPath: 'clipPath',\n  defs: 'defs',\n  ellipse: 'ellipse',\n  g: 'g',\n  image: 'image',\n  line: 'line',\n  linearGradient: 'linearGradient',\n  mask: 'mask',\n  path: 'path',\n  pattern: 'pattern',\n  polygon: 'polygon',\n  polyline: 'polyline',\n  radialGradient: 'radialGradient',\n  rect: 'rect',\n  stop: 'stop',\n  svg: 'svg',\n  text: 'text',\n  tspan: 'tspan'\n\n}, createDOMFactory);\n\nmodule.exports = ReactDOMFactories;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMFactories.js\n ** module id = 153\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMFactories.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMInput\n */\n\n'use strict';\n\nvar ReactDOMIDOperations = __webpack_require__(46);\nvar LinkedValueUtils = __webpack_require__(43);\nvar ReactMount = __webpack_require__(6);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\n\nvar instancesByReactID = {};\n\nfunction forceUpdateIfMounted() {\n  if (this._rootNodeID) {\n    // DOM component is still mounted; update\n    ReactDOMInput.updateWrapper(this);\n  }\n}\n\n/**\n * Implements an <input> native component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\nvar ReactDOMInput = {\n  getNativeProps: function (inst, props, context) {\n    var value = LinkedValueUtils.getValue(props);\n    var checked = LinkedValueUtils.getChecked(props);\n\n    var nativeProps = assign({}, props, {\n      defaultChecked: undefined,\n      defaultValue: undefined,\n      value: value != null ? value : inst._wrapperState.initialValue,\n      checked: checked != null ? checked : inst._wrapperState.initialChecked,\n      onChange: inst._wrapperState.onChange\n    });\n\n    return nativeProps;\n  },\n\n  mountWrapper: function (inst, props) {\n    if (process.env.NODE_ENV !== 'production') {\n      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);\n    }\n\n    var defaultValue = props.defaultValue;\n    inst._wrapperState = {\n      initialChecked: props.defaultChecked || false,\n      initialValue: defaultValue != null ? defaultValue : null,\n      onChange: _handleChange.bind(inst)\n    };\n  },\n\n  mountReadyWrapper: function (inst) {\n    // Can't be in mountWrapper or else server rendering leaks.\n    instancesByReactID[inst._rootNodeID] = inst;\n  },\n\n  unmountWrapper: function (inst) {\n    delete instancesByReactID[inst._rootNodeID];\n  },\n\n  updateWrapper: function (inst) {\n    var props = inst._currentElement.props;\n\n    // TODO: Shouldn't this be getChecked(props)?\n    var checked = props.checked;\n    if (checked != null) {\n      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);\n    }\n\n    var value = LinkedValueUtils.getValue(props);\n    if (value != null) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);\n    }\n  }\n};\n\nfunction _handleChange(event) {\n  var props = this._currentElement.props;\n\n  var returnValue = LinkedValueUtils.executeOnChange(props, event);\n\n  // Here we use asap to wait until all updates have propagated, which\n  // is important when using controlled components within layers:\n  // https://github.com/facebook/react/issues/1698\n  ReactUpdates.asap(forceUpdateIfMounted, this);\n\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var rootNode = ReactMount.getNode(this._rootNodeID);\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form, let's just use the global\n    // `querySelectorAll` to ensure we don't miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React with non-React.\n      var otherID = ReactMount.getID(otherNode);\n      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;\n      var otherInstance = instancesByReactID[otherID];\n      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);\n    }\n  }\n\n  return returnValue;\n}\n\nmodule.exports = ReactDOMInput;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMInput.js\n ** module id = 154\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMInput.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMOption\n */\n\n'use strict';\n\nvar ReactChildren = __webpack_require__(71);\nvar ReactDOMSelect = __webpack_require__(76);\n\nvar assign = __webpack_require__(3);\nvar warning = __webpack_require__(4);\n\nvar valueContextKey = ReactDOMSelect.valueContextKey;\n\n/**\n * Implements an <option> native component that warns when `selected` is set.\n */\nvar ReactDOMOption = {\n  mountWrapper: function (inst, props, context) {\n    // TODO (yungsters): Remove support for `selected` in <option>.\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;\n    }\n\n    // Look up whether this option is 'selected' via context\n    var selectValue = context[valueContextKey];\n\n    // If context key is null (e.g., no specified value or after initial mount)\n    // or missing (e.g., for <datalist>), we don't change props.selected\n    var selected = null;\n    if (selectValue != null) {\n      selected = false;\n      if (Array.isArray(selectValue)) {\n        // multiple\n        for (var i = 0; i < selectValue.length; i++) {\n          if ('' + selectValue[i] === '' + props.value) {\n            selected = true;\n            break;\n          }\n        }\n      } else {\n        selected = '' + selectValue === '' + props.value;\n      }\n    }\n\n    inst._wrapperState = { selected: selected };\n  },\n\n  getNativeProps: function (inst, props, context) {\n    var nativeProps = assign({ selected: undefined, children: undefined }, props);\n\n    // Read state only from initial mount because <select> updates value\n    // manually; we need the initial state only for server rendering\n    if (inst._wrapperState.selected != null) {\n      nativeProps.selected = inst._wrapperState.selected;\n    }\n\n    var content = '';\n\n    // Flatten children and warn if they aren't strings or numbers;\n    // invalid types are ignored.\n    ReactChildren.forEach(props.children, function (child) {\n      if (child == null) {\n        return;\n      }\n      if (typeof child === 'string' || typeof child === 'number') {\n        content += child;\n      } else {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;\n      }\n    });\n\n    if (content) {\n      nativeProps.children = content;\n    }\n\n    return nativeProps;\n  }\n\n};\n\nmodule.exports = ReactDOMOption;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMOption.js\n ** module id = 155\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMOption.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelection\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(5);\n\nvar getNodeForCharacterOffset = __webpack_require__(189);\nvar getTextContentAccessor = __webpack_require__(94);\n\n/**\n * While `isCollapsed` is available on the Selection object and `collapsed`\n * is available on the Range object, IE11 sometimes gets them wrong.\n * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n */\nfunction isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {\n  return anchorNode === focusNode && anchorOffset === focusOffset;\n}\n\n/**\n * Get the appropriate anchor and focus node/offset pairs for IE.\n *\n * The catch here is that IE's selection API doesn't provide information\n * about whether the selection is forward or backward, so we have to\n * behave as though it's always forward.\n *\n * IE text differs from modern selection in that it behaves as though\n * block elements end with a new line. This means character offsets will\n * differ between the two APIs.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getIEOffsets(node) {\n  var selection = document.selection;\n  var selectedRange = selection.createRange();\n  var selectedLength = selectedRange.text.length;\n\n  // Duplicate selection so we can move range without breaking user selection.\n  var fromStart = selectedRange.duplicate();\n  fromStart.moveToElementText(node);\n  fromStart.setEndPoint('EndToStart', selectedRange);\n\n  var startOffset = fromStart.text.length;\n  var endOffset = startOffset + selectedLength;\n\n  return {\n    start: startOffset,\n    end: endOffset\n  };\n}\n\n/**\n * @param {DOMElement} node\n * @return {?object}\n */\nfunction getModernOffsets(node) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  var currentRange = selection.getRangeAt(0);\n\n  // In Firefox, range.startContainer and range.endContainer can be \"anonymous\n  // divs\", e.g. the up/down buttons on an <input type=\"number\">. Anonymous\n  // divs do not seem to expose properties, triggering a \"Permission denied\n  // error\" if any of its properties are accessed. The only seemingly possible\n  // way to avoid erroring is to access a property that typically works for\n  // non-anonymous divs and catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    currentRange.startContainer.nodeType;\n    currentRange.endContainer.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  // If the node and offset values are the same, the selection is collapsed.\n  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n  // this value wrong.\n  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n\n  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\n  var tempRange = currentRange.cloneRange();\n  tempRange.selectNodeContents(node);\n  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);\n\n  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n  var end = start + rangeLength;\n\n  // Detect whether the selection is backward.\n  var detectionRange = document.createRange();\n  detectionRange.setStart(anchorNode, anchorOffset);\n  detectionRange.setEnd(focusNode, focusOffset);\n  var isBackward = detectionRange.collapsed;\n\n  return {\n    start: isBackward ? end : start,\n    end: isBackward ? start : end\n  };\n}\n\n/**\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setIEOffsets(node, offsets) {\n  var range = document.selection.createRange().duplicate();\n  var start, end;\n\n  if (typeof offsets.end === 'undefined') {\n    start = offsets.start;\n    end = start;\n  } else if (offsets.start > offsets.end) {\n    start = offsets.end;\n    end = offsets.start;\n  } else {\n    start = offsets.start;\n    end = offsets.end;\n  }\n\n  range.moveToElementText(node);\n  range.moveStart('character', start);\n  range.setEndPoint('EndToStart', range);\n  range.moveEnd('character', end - start);\n  range.select();\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setModernOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nvar useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);\n\nvar ReactDOMSelection = {\n  /**\n   * @param {DOMElement} node\n   */\n  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,\n\n  /**\n   * @param {DOMElement|DOMTextNode} node\n   * @param {object} offsets\n   */\n  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets\n};\n\nmodule.exports = ReactDOMSelection;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelection.js\n ** module id = 156\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelection.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMServer\n */\n\n'use strict';\n\nvar ReactDefaultInjection = __webpack_require__(79);\nvar ReactServerRendering = __webpack_require__(170);\nvar ReactVersion = __webpack_require__(48);\n\nReactDefaultInjection.inject();\n\nvar ReactDOMServer = {\n  renderToString: ReactServerRendering.renderToString,\n  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,\n  version: ReactVersion\n};\n\nmodule.exports = ReactDOMServer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMServer.js\n ** module id = 157\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMServer.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextarea\n */\n\n'use strict';\n\nvar LinkedValueUtils = __webpack_require__(43);\nvar ReactDOMIDOperations = __webpack_require__(46);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar invariant = __webpack_require__(2);\nvar warning = __webpack_require__(4);\n\nfunction forceUpdateIfMounted() {\n  if (this._rootNodeID) {\n    // DOM component is still mounted; update\n    ReactDOMTextarea.updateWrapper(this);\n  }\n}\n\n/**\n * Implements a <textarea> native component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\nvar ReactDOMTextarea = {\n  getNativeProps: function (inst, props, context) {\n    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;\n\n    // Always set children to the same thing. In IE9, the selection range will\n    // get reset if `textContent` is mutated.\n    var nativeProps = assign({}, props, {\n      defaultValue: undefined,\n      value: undefined,\n      children: inst._wrapperState.initialValue,\n      onChange: inst._wrapperState.onChange\n    });\n\n    return nativeProps;\n  },\n\n  mountWrapper: function (inst, props) {\n    if (process.env.NODE_ENV !== 'production') {\n      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);\n    }\n\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      if (process.env.NODE_ENV !== 'production') {\n        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;\n      }\n      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    var value = LinkedValueUtils.getValue(props);\n\n    inst._wrapperState = {\n      // We save the initial value so that `ReactDOMComponent` doesn't update\n      // `textContent` (unnecessary since we update value).\n      // The initial value can be a boolean or object so that's why it's\n      // forced to be a string.\n      initialValue: '' + (value != null ? value : defaultValue),\n      onChange: _handleChange.bind(inst)\n    };\n  },\n\n  updateWrapper: function (inst) {\n    var props = inst._currentElement.props;\n    var value = LinkedValueUtils.getValue(props);\n    if (value != null) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);\n    }\n  }\n};\n\nfunction _handleChange(event) {\n  var props = this._currentElement.props;\n  var returnValue = LinkedValueUtils.executeOnChange(props, event);\n  ReactUpdates.asap(forceUpdateIfMounted, this);\n  return returnValue;\n}\n\nmodule.exports = ReactDOMTextarea;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMTextarea.js\n ** module id = 158\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMTextarea.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerf\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\nvar ReactDefaultPerfAnalysis = __webpack_require__(160);\nvar ReactMount = __webpack_require__(6);\nvar ReactPerf = __webpack_require__(8);\n\nvar performanceNow = __webpack_require__(129);\n\nfunction roundFloat(val) {\n  return Math.floor(val * 100) / 100;\n}\n\nfunction addValue(obj, key, val) {\n  obj[key] = (obj[key] || 0) + val;\n}\n\nvar ReactDefaultPerf = {\n  _allMeasurements: [], // last item in the list is the current one\n  _mountStack: [0],\n  _injected: false,\n\n  start: function () {\n    if (!ReactDefaultPerf._injected) {\n      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);\n    }\n\n    ReactDefaultPerf._allMeasurements.length = 0;\n    ReactPerf.enableMeasure = true;\n  },\n\n  stop: function () {\n    ReactPerf.enableMeasure = false;\n  },\n\n  getLastMeasurements: function () {\n    return ReactDefaultPerf._allMeasurements;\n  },\n\n  printExclusive: function (measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);\n    console.table(summary.map(function (item) {\n      return {\n        'Component class name': item.componentName,\n        'Total inclusive time (ms)': roundFloat(item.inclusive),\n        'Exclusive mount time (ms)': roundFloat(item.exclusive),\n        'Exclusive render time (ms)': roundFloat(item.render),\n        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),\n        'Render time per instance (ms)': roundFloat(item.render / item.count),\n        'Instances': item.count\n      };\n    }));\n    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct\n    // number.\n  },\n\n  printInclusive: function (measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);\n    console.table(summary.map(function (item) {\n      return {\n        'Owner > component': item.componentName,\n        'Inclusive time (ms)': roundFloat(item.time),\n        'Instances': item.count\n      };\n    }));\n    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');\n  },\n\n  getMeasurementsSummaryMap: function (measurements) {\n    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);\n    return summary.map(function (item) {\n      return {\n        'Owner > component': item.componentName,\n        'Wasted time (ms)': item.time,\n        'Instances': item.count\n      };\n    });\n  },\n\n  printWasted: function (measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));\n    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');\n  },\n\n  printDOM: function (measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);\n    console.table(summary.map(function (item) {\n      var result = {};\n      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;\n      result.type = item.type;\n      result.args = JSON.stringify(item.args);\n      return result;\n    }));\n    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');\n  },\n\n  _recordWrite: function (id, fnName, totalTime, args) {\n    // TODO: totalTime isn't that useful since it doesn't count paints/reflows\n    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;\n    writes[id] = writes[id] || [];\n    writes[id].push({\n      type: fnName,\n      time: totalTime,\n      args: args\n    });\n  },\n\n  measure: function (moduleName, fnName, func) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var totalTime;\n      var rv;\n      var start;\n\n      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {\n        // A \"measurement\" is a set of metrics recorded for each flush. We want\n        // to group the metrics for a given flush together so we can look at the\n        // components that rendered and the DOM operations that actually\n        // happened to determine the amount of \"wasted work\" performed.\n        ReactDefaultPerf._allMeasurements.push({\n          exclusive: {},\n          inclusive: {},\n          render: {},\n          counts: {},\n          writes: {},\n          displayNames: {},\n          totalTime: 0,\n          created: {}\n        });\n        start = performanceNow();\n        rv = func.apply(this, args);\n        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;\n        return rv;\n      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {\n        start = performanceNow();\n        rv = func.apply(this, args);\n        totalTime = performanceNow() - start;\n\n        if (fnName === '_mountImageIntoNode') {\n          var mountID = ReactMount.getID(args[1]);\n          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);\n        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {\n          // special format\n          args[0].forEach(function (update) {\n            var writeArgs = {};\n            if (update.fromIndex !== null) {\n              writeArgs.fromIndex = update.fromIndex;\n            }\n            if (update.toIndex !== null) {\n              writeArgs.toIndex = update.toIndex;\n            }\n            if (update.textContent !== null) {\n              writeArgs.textContent = update.textContent;\n            }\n            if (update.markupIndex !== null) {\n              writeArgs.markup = args[1][update.markupIndex];\n            }\n            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);\n          });\n        } else {\n          // basic format\n          var id = args[0];\n          if (typeof id === 'object') {\n            id = ReactMount.getID(args[0]);\n          }\n          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));\n        }\n        return rv;\n      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?\n      fnName === '_renderValidatedComponent')) {\n\n        if (this._currentElement.type === ReactMount.TopLevelWrapper) {\n          return func.apply(this, args);\n        }\n\n        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;\n        var isRender = fnName === '_renderValidatedComponent';\n        var isMount = fnName === 'mountComponent';\n\n        var mountStack = ReactDefaultPerf._mountStack;\n        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];\n\n        if (isRender) {\n          addValue(entry.counts, rootNodeID, 1);\n        } else if (isMount) {\n          entry.created[rootNodeID] = true;\n          mountStack.push(0);\n        }\n\n        start = performanceNow();\n        rv = func.apply(this, args);\n        totalTime = performanceNow() - start;\n\n        if (isRender) {\n          addValue(entry.render, rootNodeID, totalTime);\n        } else if (isMount) {\n          var subMountTime = mountStack.pop();\n          mountStack[mountStack.length - 1] += totalTime;\n          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);\n          addValue(entry.inclusive, rootNodeID, totalTime);\n        } else {\n          addValue(entry.inclusive, rootNodeID, totalTime);\n        }\n\n        entry.displayNames[rootNodeID] = {\n          current: this.getName(),\n          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'\n        };\n\n        return rv;\n      } else {\n        return func.apply(this, args);\n      }\n    };\n  }\n};\n\nmodule.exports = ReactDefaultPerf;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultPerf.js\n ** module id = 159\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultPerf.js?");
},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\n'use strict';\n\nvar assign = __webpack_require__(3);\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  '_mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  SET_MARKUP: 'set innerHTML',\n  TEXT_CONTENT: 'set textContent',\n  'setValueForProperty': 'update attribute',\n  'setValueForAttribute': 'update attribute',\n  'deleteValueForProperty': 'remove attribute',\n  'setValueForStyles': 'update styles',\n  'replaceNodeWithMarkup': 'replace',\n  'updateTextContent': 'set textContent'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n  measurements.forEach(function (measurement) {\n    Object.keys(measurement.writes).forEach(function (id) {\n      measurement.writes[id].forEach(function (write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    });\n  });\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.exclusive - a.exclusive;\n  });\n\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function (a, b) {\n    return b.time - a.time;\n  });\n\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    // check if component newly created\n    if (measurement.created[id]) {\n      isDirty = true;\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\n\nmodule.exports = ReactDefaultPerfAnalysis;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultPerfAnalysis.js\n ** module id = 160\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultPerfAnalysis.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventEmitterMixin\n */\n\n'use strict';\n\nvar EventPluginHub = __webpack_require__(21);\n\nfunction runEventQueueInBatch(events) {\n  EventPluginHub.enqueueEvents(events);\n  EventPluginHub.processEventQueue(false);\n}\n\nvar ReactEventEmitterMixin = {\n\n  /**\n   * Streams a fired top-level event to `EventPluginHub` where plugins have the\n   * opportunity to create `ReactEvent`s to be dispatched.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {object} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native environment event.\n   */\n  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);\n    runEventQueueInBatch(events);\n  }\n};\n\nmodule.exports = ReactEventEmitterMixin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventEmitterMixin.js\n ** module id = 161\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventEmitterMixin.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventListener = __webpack_require__(61);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar PooledClass = __webpack_require__(14);\nvar ReactInstanceHandles = __webpack_require__(19);\nvar ReactMount = __webpack_require__(6);\nvar ReactUpdates = __webpack_require__(9);\n\nvar assign = __webpack_require__(3);\nvar getEventTarget = __webpack_require__(52);\nvar getUnboundedScrollPosition = __webpack_require__(121);\n\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function () {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  // TODO: Re-enable event.path handling\n  //\n  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {\n  //   // New browsers have a path attribute on native events\n  //   handleTopLevelWithPath(bookKeeping);\n  // } else {\n  //   // Legacy browsers don't have a path attribute on native events\n  //   handleTopLevelWithoutPath(bookKeeping);\n  // }\n\n  void handleTopLevelWithPath; // temporarily unused\n  handleTopLevelWithoutPath(bookKeeping);\n}\n\n// Legacy browsers don't have a path attribute on native events\nfunction handleTopLevelWithoutPath(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// New browsers have a path attribute on native events\nfunction handleTopLevelWithPath(bookKeeping) {\n  var path = bookKeeping.nativeEvent.path;\n  var currentNativeTarget = path[0];\n  var eventsFired = 0;\n  for (var i = 0; i < path.length; i++) {\n    var currentPathElement = path[i];\n    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {\n      currentNativeTarget = path[i + 1];\n    }\n    // TODO: slow\n    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);\n    if (reactParent === currentPathElement) {\n      var currentPathElementID = ReactMount.getID(currentPathElement);\n      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);\n      bookKeeping.ancestors.push(currentPathElement);\n\n      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';\n      eventsFired++;\n      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);\n\n      // Jump to the root of this React render tree\n      while (currentPathElementID !== newRootID) {\n        i++;\n        currentPathElement = path[i];\n        currentPathElementID = ReactMount.getID(currentPathElement);\n      }\n    }\n  }\n  if (eventsFired === 0) {\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function (enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function () {\n    return ReactEventListener._enabled;\n  },\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  monitorScrollValue: function (refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventListener.js\n ** module id = 162\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventListener.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInjection\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\nvar EventPluginHub = __webpack_require__(21);\nvar ReactComponentEnvironment = __webpack_require__(45);\nvar ReactClass = __webpack_require__(72);\nvar ReactEmptyComponent = __webpack_require__(81);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactNativeComponent = __webpack_require__(87);\nvar ReactPerf = __webpack_require__(8);\nvar ReactRootIndex = __webpack_require__(90);\nvar ReactUpdates = __webpack_require__(9);\n\nvar ReactInjection = {\n  Component: ReactComponentEnvironment.injection,\n  Class: ReactClass.injection,\n  DOMProperty: DOMProperty.injection,\n  EmptyComponent: ReactEmptyComponent.injection,\n  EventPluginHub: EventPluginHub.injection,\n  EventEmitter: ReactBrowserEventEmitter.injection,\n  NativeComponent: ReactNativeComponent.injection,\n  Perf: ReactPerf.injection,\n  RootIndex: ReactRootIndex.injection,\n  Updates: ReactUpdates.injection\n};\n\nmodule.exports = ReactInjection;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInjection.js\n ** module id = 163\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInjection.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactIsomorphic\n */\n\n'use strict';\n\nvar ReactChildren = __webpack_require__(71);\nvar ReactComponent = __webpack_require__(73);\nvar ReactClass = __webpack_require__(72);\nvar ReactDOMFactories = __webpack_require__(153);\nvar ReactElement = __webpack_require__(7);\nvar ReactElementValidator = __webpack_require__(80);\nvar ReactPropTypes = __webpack_require__(89);\nvar ReactVersion = __webpack_require__(48);\n\nvar assign = __webpack_require__(3);\nvar onlyChild = __webpack_require__(190);\n\nvar createElement = ReactElement.createElement;\nvar createFactory = ReactElement.createFactory;\nvar cloneElement = ReactElement.cloneElement;\n\nif (process.env.NODE_ENV !== 'production') {\n  createElement = ReactElementValidator.createElement;\n  createFactory = ReactElementValidator.createFactory;\n  cloneElement = ReactElementValidator.cloneElement;\n}\n\nvar React = {\n\n  // Modern\n\n  Children: {\n    map: ReactChildren.map,\n    forEach: ReactChildren.forEach,\n    count: ReactChildren.count,\n    toArray: ReactChildren.toArray,\n    only: onlyChild\n  },\n\n  Component: ReactComponent,\n\n  createElement: createElement,\n  cloneElement: cloneElement,\n  isValidElement: ReactElement.isValidElement,\n\n  // Classic\n\n  PropTypes: ReactPropTypes,\n  createClass: ReactClass.createClass,\n  createFactory: createFactory,\n  createMixin: function (mixin) {\n    // Currently a noop. Will be used to validate and trace mixins.\n    return mixin;\n  },\n\n  // This looks DOM specific but these are actually isomorphic helpers\n  // since they are just generating DOM strings.\n  DOM: ReactDOMFactories,\n\n  version: ReactVersion,\n\n  // Hook for JSX spread, don't use this for anything else.\n  __spread: assign\n};\n\nmodule.exports = React;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactIsomorphic.js\n ** module id = 164\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactIsomorphic.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChild\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactComponentEnvironment = __webpack_require__(45);\nvar ReactMultiChildUpdateTypes = __webpack_require__(86);\n\nvar ReactCurrentOwner = __webpack_require__(12);\nvar ReactReconciler = __webpack_require__(16);\nvar ReactChildReconciler = __webpack_require__(149);\n\nvar flattenChildren = __webpack_require__(187);\n\n/**\n * Updating children of a component may trigger recursive updates. The depth is\n * used to batch recursive updates to render markup more efficiently.\n *\n * @type {number}\n * @private\n */\nvar updateDepth = 0;\n\n/**\n * Queue of update configuration objects.\n *\n * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.\n *\n * @type {array<object>}\n * @private\n */\nvar updateQueue = [];\n\n/**\n * Queue of markup to be rendered.\n *\n * @type {array<string>}\n * @private\n */\nvar markupQueue = [];\n\n/**\n * Enqueues markup to be rendered and inserted at a supplied index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} markup Markup that renders into an element.\n * @param {number} toIndex Destination index.\n * @private\n */\nfunction enqueueInsertMarkup(parentID, markup, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    markupIndex: markupQueue.push(markup) - 1,\n    content: null,\n    fromIndex: null,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues moving an existing element to another index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Source index of the existing element.\n * @param {number} toIndex Destination index of the element.\n * @private\n */\nfunction enqueueMove(parentID, fromIndex, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\n    markupIndex: null,\n    content: null,\n    fromIndex: fromIndex,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues removing an element at an index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Index of the element to remove.\n * @private\n */\nfunction enqueueRemove(parentID, fromIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.REMOVE_NODE,\n    markupIndex: null,\n    content: null,\n    fromIndex: fromIndex,\n    toIndex: null\n  });\n}\n\n/**\n * Enqueues setting the markup of a node.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} markup Markup that renders into an element.\n * @private\n */\nfunction enqueueSetMarkup(parentID, markup) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.SET_MARKUP,\n    markupIndex: null,\n    content: markup,\n    fromIndex: null,\n    toIndex: null\n  });\n}\n\n/**\n * Enqueues setting the text content.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} textContent Text content to set.\n * @private\n */\nfunction enqueueTextContent(parentID, textContent) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,\n    markupIndex: null,\n    content: textContent,\n    fromIndex: null,\n    toIndex: null\n  });\n}\n\n/**\n * Processes any enqueued updates.\n *\n * @private\n */\nfunction processQueue() {\n  if (updateQueue.length) {\n    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);\n    clearQueue();\n  }\n}\n\n/**\n * Clears any enqueued updates.\n *\n * @private\n */\nfunction clearQueue() {\n  updateQueue.length = 0;\n  markupQueue.length = 0;\n}\n\n/**\n * ReactMultiChild are capable of reconciling multiple children.\n *\n * @class ReactMultiChild\n * @internal\n */\nvar ReactMultiChild = {\n\n  /**\n   * Provides common functionality for components that must reconcile multiple\n   * children. This is used by `ReactDOMComponent` to mount, update, and\n   * unmount child components.\n   *\n   * @lends {ReactMultiChild.prototype}\n   */\n  Mixin: {\n\n    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n        }\n      }\n      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);\n    },\n\n    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {\n      var nextChildren;\n      if (process.env.NODE_ENV !== 'production') {\n        if (this._currentElement) {\n          try {\n            ReactCurrentOwner.current = this._currentElement._owner;\n            nextChildren = flattenChildren(nextNestedChildrenElements);\n          } finally {\n            ReactCurrentOwner.current = null;\n          }\n          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);\n        }\n      }\n      nextChildren = flattenChildren(nextNestedChildrenElements);\n      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);\n    },\n\n    /**\n     * Generates a \"mount image\" for each of the supplied children. In the case\n     * of `ReactDOMComponent`, a mount image is a string of markup.\n     *\n     * @param {?object} nestedChildren Nested child maps.\n     * @return {array} An array of mounted representations.\n     * @internal\n     */\n    mountChildren: function (nestedChildren, transaction, context) {\n      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);\n      this._renderedChildren = children;\n      var mountImages = [];\n      var index = 0;\n      for (var name in children) {\n        if (children.hasOwnProperty(name)) {\n          var child = children[name];\n          // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n          var rootID = this._rootNodeID + name;\n          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);\n          child._mountIndex = index++;\n          mountImages.push(mountImage);\n        }\n      }\n      return mountImages;\n    },\n\n    /**\n     * Replaces any rendered children with a text content string.\n     *\n     * @param {string} nextContent String of content.\n     * @internal\n     */\n    updateTextContent: function (nextContent) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        var prevChildren = this._renderedChildren;\n        // Remove any rendered children.\n        ReactChildReconciler.unmountChildren(prevChildren);\n        // TODO: The setTextContent operation should be enough\n        for (var name in prevChildren) {\n          if (prevChildren.hasOwnProperty(name)) {\n            this._unmountChild(prevChildren[name]);\n          }\n        }\n        // Set new text content.\n        this.setTextContent(nextContent);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          if (errorThrown) {\n            clearQueue();\n          } else {\n            processQueue();\n          }\n        }\n      }\n    },\n\n    /**\n     * Replaces any rendered children with a markup string.\n     *\n     * @param {string} nextMarkup String of markup.\n     * @internal\n     */\n    updateMarkup: function (nextMarkup) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        var prevChildren = this._renderedChildren;\n        // Remove any rendered children.\n        ReactChildReconciler.unmountChildren(prevChildren);\n        for (var name in prevChildren) {\n          if (prevChildren.hasOwnProperty(name)) {\n            this._unmountChildByName(prevChildren[name], name);\n          }\n        }\n        this.setMarkup(nextMarkup);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          if (errorThrown) {\n            clearQueue();\n          } else {\n            processQueue();\n          }\n        }\n      }\n    },\n\n    /**\n     * Updates the rendered children with new children.\n     *\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        this._updateChildren(nextNestedChildrenElements, transaction, context);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          if (errorThrown) {\n            clearQueue();\n          } else {\n            processQueue();\n          }\n        }\n      }\n    },\n\n    /**\n     * Improve performance by isolating this hot code path from the try/catch\n     * block in `updateChildren`.\n     *\n     * @param {?object} nextNestedChildrenElements Nested child element maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @final\n     * @protected\n     */\n    _updateChildren: function (nextNestedChildrenElements, transaction, context) {\n      var prevChildren = this._renderedChildren;\n      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);\n      this._renderedChildren = nextChildren;\n      if (!nextChildren && !prevChildren) {\n        return;\n      }\n      var name;\n      // `nextIndex` will increment for each child in `nextChildren`, but\n      // `lastIndex` will be the last index visited in `prevChildren`.\n      var lastIndex = 0;\n      var nextIndex = 0;\n      for (name in nextChildren) {\n        if (!nextChildren.hasOwnProperty(name)) {\n          continue;\n        }\n        var prevChild = prevChildren && prevChildren[name];\n        var nextChild = nextChildren[name];\n        if (prevChild === nextChild) {\n          this.moveChild(prevChild, nextIndex, lastIndex);\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          if (prevChild) {\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n            this._unmountChild(prevChild);\n          }\n          // The child must be instantiated before it's mounted.\n          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);\n        }\n        nextIndex++;\n      }\n      // Remove children that are no longer present.\n      for (name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {\n          this._unmountChild(prevChildren[name]);\n        }\n      }\n    },\n\n    /**\n     * Unmounts all rendered children. This should be used to clean up children\n     * when this component is unmounted.\n     *\n     * @internal\n     */\n    unmountChildren: function () {\n      var renderedChildren = this._renderedChildren;\n      ReactChildReconciler.unmountChildren(renderedChildren);\n      this._renderedChildren = null;\n    },\n\n    /**\n     * Moves a child component to the supplied index.\n     *\n     * @param {ReactComponent} child Component to move.\n     * @param {number} toIndex Destination index of the element.\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\n     * @protected\n     */\n    moveChild: function (child, toIndex, lastIndex) {\n      // If the index of `child` is less than `lastIndex`, then it needs to\n      // be moved. Otherwise, we do not need to move it because a child will be\n      // inserted or moved before `child`.\n      if (child._mountIndex < lastIndex) {\n        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);\n      }\n    },\n\n    /**\n     * Creates a child component.\n     *\n     * @param {ReactComponent} child Component to create.\n     * @param {string} mountImage Markup to insert.\n     * @protected\n     */\n    createChild: function (child, mountImage) {\n      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);\n    },\n\n    /**\n     * Removes a child component.\n     *\n     * @param {ReactComponent} child Child to remove.\n     * @protected\n     */\n    removeChild: function (child) {\n      enqueueRemove(this._rootNodeID, child._mountIndex);\n    },\n\n    /**\n     * Sets this text content string.\n     *\n     * @param {string} textContent Text content to set.\n     * @protected\n     */\n    setTextContent: function (textContent) {\n      enqueueTextContent(this._rootNodeID, textContent);\n    },\n\n    /**\n     * Sets this markup string.\n     *\n     * @param {string} markup Markup to set.\n     * @protected\n     */\n    setMarkup: function (markup) {\n      enqueueSetMarkup(this._rootNodeID, markup);\n    },\n\n    /**\n     * Mounts a child with the supplied name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to mount.\n     * @param {string} name Name of the child.\n     * @param {number} index Index at which to insert the child.\n     * @param {ReactReconcileTransaction} transaction\n     * @private\n     */\n    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {\n      // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n      var rootID = this._rootNodeID + name;\n      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);\n      child._mountIndex = index;\n      this.createChild(child, mountImage);\n    },\n\n    /**\n     * Unmounts a rendered child.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to unmount.\n     * @private\n     */\n    _unmountChild: function (child) {\n      this.removeChild(child);\n      child._mountIndex = null;\n    }\n\n  }\n\n};\n\nmodule.exports = ReactMultiChild;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChild.js\n ** module id = 165\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChild.js?");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactOwner\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(2);\n\n/**\n * ReactOwners are capable of storing references to owned components.\n *\n * All components are capable of //being// referenced by owner components, but\n * only ReactOwner components are capable of //referencing// owned components.\n * The named reference is known as a \"ref\".\n *\n * Refs are available when mounted and updated during reconciliation.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return (\n *         <div onClick={this.handleClick}>\n *           <CustomComponent ref=\"custom\" />\n *         </div>\n *       );\n *     },\n *     handleClick: function() {\n *       this.refs.custom.handleClick();\n *     },\n *     componentDidMount: function() {\n *       this.refs.custom.initialize();\n *     }\n *   });\n *\n * Refs should rarely be used. When refs are used, they should only be done to\n * control data that is not handled by React's data flow.\n *\n * @class ReactOwner\n */\nvar ReactOwner = {\n\n  /**\n   * @param {?object} object\n   * @return {boolean} True if `object` is a valid owner.\n   * @final\n   */\n  isValidOwner: function (object) {\n    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');\n  },\n\n  /**\n   * Adds a component by ref to an owner component.\n   *\n   * @param {ReactComponent} component Component to reference.\n   * @param {string} ref Name by which to refer to the component.\n   * @param {ReactOwner} owner Component on which to record the ref.\n   * @final\n   * @internal\n   */\n  addComponentAsRefTo: function (component, ref, owner) {\n    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;\n    owner.attachRef(ref, component);\n  },\n\n  /**\n   * Removes a component by ref from an owner component.\n   *\n   * @param {ReactComponent} component Component to dereference.\n   * @param {string} ref Name of the ref to remove.\n   * @param {ReactOwner} owner Component on which the ref is recorded.\n   * @final\n   * @internal\n   */\n  removeComponentAsRefFrom: function (component, ref, owner) {\n    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;\n    // Check that `component` is still the current ref because we do not want to\n    // detach the ref if another component stole it.\n    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {\n      owner.detachRef(ref);\n    }\n  }\n\n};\n\nmodule.exports = ReactOwner;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactOwner.js\n ** module id = 166\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactOwner.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconcileTransaction\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CallbackQueue = __webpack_require__(41);\nvar PooledClass = __webpack_require__(14);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactDOMFeatureFlags = __webpack_require__(75);\nvar ReactInputSelection = __webpack_require__(84);\nvar Transaction = __webpack_require__(30);\n\nvar assign = __webpack_require__(3);\n\n/**\n * Ensures that, when possible, the selection range (currently selected text\n * input) is not disturbed by performing the transaction.\n */\nvar SELECTION_RESTORATION = {\n  /**\n   * @return {Selection} Selection information.\n   */\n  initialize: ReactInputSelection.getSelectionInformation,\n  /**\n   * @param {Selection} sel Selection information returned from `initialize`.\n   */\n  close: ReactInputSelection.restoreSelection\n};\n\n/**\n * Suppresses events (blur/focus) that could be inadvertently dispatched due to\n * high level DOM manipulations (like temporarily removing a text input from the\n * DOM).\n */\nvar EVENT_SUPPRESSION = {\n  /**\n   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before\n   * the reconciliation.\n   */\n  initialize: function () {\n    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();\n    ReactBrowserEventEmitter.setEnabled(false);\n    return currentlyEnabled;\n  },\n\n  /**\n   * @param {boolean} previouslyEnabled Enabled status of\n   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`\n   *   restores the previous value.\n   */\n  close: function (previouslyEnabled) {\n    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);\n  }\n};\n\n/**\n * Provides a queue for collecting `componentDidMount` and\n * `componentDidUpdate` callbacks during the the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function () {\n    this.reactMountReady.reset();\n  },\n\n  /**\n   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.\n   */\n  close: function () {\n    this.reactMountReady.notifyAll();\n  }\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];\n\n/**\n * Currently:\n * - The order that these are listed in the transaction is critical:\n * - Suppresses events.\n * - Restores selection range.\n *\n * Future:\n * - Restore document/overflow scroll positions that were unintentionally\n *   modified via DOM insertions above the top viewport boundary.\n * - Implement/integrate with customized constraint based layout system and keep\n *   track of which dimensions must be remeasured.\n *\n * @class ReactReconcileTransaction\n */\nfunction ReactReconcileTransaction(forceHTML) {\n  this.reinitializeTransaction();\n  // Only server-side rendering really needs this option (see\n  // `ReactServerRendering`), but server-side uses\n  // `ReactServerRenderingTransaction` instead. This option is here so that it's\n  // accessible and defaults to false when `ReactDOMComponent` and\n  // `ReactTextComponent` checks it in `mountComponent`.`\n  this.renderToStaticMarkup = false;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array<object>} List of operation wrap procedures.\n   *   TODO: convert to array<TransactionWrapper>\n   */\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function () {\n    return this.reactMountReady;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be reused.\n   */\n  destructor: function () {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n  }\n};\n\nassign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);\n\nPooledClass.addPoolingTo(ReactReconcileTransaction);\n\nmodule.exports = ReactReconcileTransaction;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactReconcileTransaction.js\n ** module id = 167\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactReconcileTransaction.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactRef\n */\n\n'use strict';\n\nvar ReactOwner = __webpack_require__(166);\n\nvar ReactRef = {};\n\nfunction attachRef(ref, component, owner) {\n  if (typeof ref === 'function') {\n    ref(component.getPublicInstance());\n  } else {\n    // Legacy ref\n    ReactOwner.addComponentAsRefTo(component, ref, owner);\n  }\n}\n\nfunction detachRef(ref, component, owner) {\n  if (typeof ref === 'function') {\n    ref(null);\n  } else {\n    // Legacy ref\n    ReactOwner.removeComponentAsRefFrom(component, ref, owner);\n  }\n}\n\nReactRef.attachRefs = function (instance, element) {\n  if (element === null || element === false) {\n    return;\n  }\n  var ref = element.ref;\n  if (ref != null) {\n    attachRef(ref, instance, element._owner);\n  }\n};\n\nReactRef.shouldUpdateRefs = function (prevElement, nextElement) {\n  // If either the owner or a `ref` has changed, make sure the newest owner\n  // has stored a reference to `this`, and the previous owner (if different)\n  // has forgotten the reference to `this`. We use the element instead\n  // of the public this.props because the post processing cannot determine\n  // a ref. The ref conceptually lives on the element.\n\n  // TODO: Should this even be possible? The owner cannot change because\n  // it's forbidden by shouldUpdateReactComponent. The ref can change\n  // if you swap the keys of but not the refs. Reconsider where this check\n  // is made. It probably belongs where the key checking and\n  // instantiateReactComponent is done.\n\n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n\n  return(\n    // This has a few false positives w/r/t empty components.\n    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref\n  );\n};\n\nReactRef.detachRefs = function (instance, element) {\n  if (element === null || element === false) {\n    return;\n  }\n  var ref = element.ref;\n  if (ref != null) {\n    detachRef(ref, instance, element._owner);\n  }\n};\n\nmodule.exports = ReactRef;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactRef.js\n ** module id = 168\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactRef.js?")},function(module,exports){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerBatchingStrategy\n * @typechecks\n */\n\n'use strict';\n\nvar ReactServerBatchingStrategy = {\n  isBatchingUpdates: false,\n  batchedUpdates: function (callback) {\n    // Don't do anything here. During the server rendering we don't want to\n    // schedule any updates. We will simply ignore them.\n  }\n};\n\nmodule.exports = ReactServerBatchingStrategy;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerBatchingStrategy.js\n ** module id = 169\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerBatchingStrategy.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactServerRendering\n */\n'use strict';\n\nvar ReactDefaultBatchingStrategy = __webpack_require__(78);\nvar ReactElement = __webpack_require__(7);\nvar ReactInstanceHandles = __webpack_require__(19);\nvar ReactMarkupChecksum = __webpack_require__(85);\nvar ReactServerBatchingStrategy = __webpack_require__(169);\nvar ReactServerRenderingTransaction = __webpack_require__(171);\nvar ReactUpdates = __webpack_require__(9);\n\nvar emptyObject = __webpack_require__(20);\nvar instantiateReactComponent = __webpack_require__(54);\nvar invariant = __webpack_require__(2);\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup\n */\nfunction renderToString(element) {\n  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;\n\n  var transaction;\n  try {\n    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);\n\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(false);\n\n    return transaction.perform(function () {\n      var componentInstance = instantiateReactComponent(element, null);\n      var markup = componentInstance.mountComponent(id, transaction, emptyObject);\n      return ReactMarkupChecksum.addChecksumToMarkup(markup);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n    // Revert to the DOM batching strategy since these two renderers\n    // currently share these stateful modules.\n    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n  }\n}\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup, without the extra React ID and checksum\n * (for generating static pages)\n */\nfunction renderToStaticMarkup(element) {\n  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;\n\n  var transaction;\n  try {\n    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);\n\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(true);\n\n    return transaction.perform(function () {\n      var componentInstance = instantiateReactComponent(element, null);\n      return componentInstance.mountComponent(id, transaction, emptyObject);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n    // Revert to the DOM batching strategy since these two renderers\n    // currently share these stateful modules.\n    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n  }\n}\n\nmodule.exports = {\n  renderToString: renderToString,\n  renderToStaticMarkup: renderToStaticMarkup\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRendering.js\n ** module id = 170\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRendering.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerRenderingTransaction\n * @typechecks\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(14);\nvar CallbackQueue = __webpack_require__(41);\nvar Transaction = __webpack_require__(30);\n\nvar assign = __webpack_require__(3);\nvar emptyFunction = __webpack_require__(10);\n\n/**\n * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks\n * during the performing of the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function () {\n    this.reactMountReady.reset();\n  },\n\n  close: emptyFunction\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];\n\n/**\n * @class ReactServerRenderingTransaction\n * @param {boolean} renderToStaticMarkup\n */\nfunction ReactServerRenderingTransaction(renderToStaticMarkup) {\n  this.reinitializeTransaction();\n  this.renderToStaticMarkup = renderToStaticMarkup;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.useCreateElement = false;\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array} Empty list of operation wrap procedures.\n   */\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function () {\n    return this.reactMountReady;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be reused.\n   */\n  destructor: function () {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n  }\n};\n\nassign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);\n\nPooledClass.addPoolingTo(ReactServerRenderingTransaction);\n\nmodule.exports = ReactServerRenderingTransaction;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRenderingTransaction.js\n ** module id = 171\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRenderingTransaction.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SVGDOMPropertyConfig\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(15);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\n\nvar NS = {\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    clipPath: MUST_USE_ATTRIBUTE,\n    cx: MUST_USE_ATTRIBUTE,\n    cy: MUST_USE_ATTRIBUTE,\n    d: MUST_USE_ATTRIBUTE,\n    dx: MUST_USE_ATTRIBUTE,\n    dy: MUST_USE_ATTRIBUTE,\n    fill: MUST_USE_ATTRIBUTE,\n    fillOpacity: MUST_USE_ATTRIBUTE,\n    fontFamily: MUST_USE_ATTRIBUTE,\n    fontSize: MUST_USE_ATTRIBUTE,\n    fx: MUST_USE_ATTRIBUTE,\n    fy: MUST_USE_ATTRIBUTE,\n    gradientTransform: MUST_USE_ATTRIBUTE,\n    gradientUnits: MUST_USE_ATTRIBUTE,\n    markerEnd: MUST_USE_ATTRIBUTE,\n    markerMid: MUST_USE_ATTRIBUTE,\n    markerStart: MUST_USE_ATTRIBUTE,\n    offset: MUST_USE_ATTRIBUTE,\n    opacity: MUST_USE_ATTRIBUTE,\n    patternContentUnits: MUST_USE_ATTRIBUTE,\n    patternUnits: MUST_USE_ATTRIBUTE,\n    points: MUST_USE_ATTRIBUTE,\n    preserveAspectRatio: MUST_USE_ATTRIBUTE,\n    r: MUST_USE_ATTRIBUTE,\n    rx: MUST_USE_ATTRIBUTE,\n    ry: MUST_USE_ATTRIBUTE,\n    spreadMethod: MUST_USE_ATTRIBUTE,\n    stopColor: MUST_USE_ATTRIBUTE,\n    stopOpacity: MUST_USE_ATTRIBUTE,\n    stroke: MUST_USE_ATTRIBUTE,\n    strokeDasharray: MUST_USE_ATTRIBUTE,\n    strokeLinecap: MUST_USE_ATTRIBUTE,\n    strokeOpacity: MUST_USE_ATTRIBUTE,\n    strokeWidth: MUST_USE_ATTRIBUTE,\n    textAnchor: MUST_USE_ATTRIBUTE,\n    transform: MUST_USE_ATTRIBUTE,\n    version: MUST_USE_ATTRIBUTE,\n    viewBox: MUST_USE_ATTRIBUTE,\n    x1: MUST_USE_ATTRIBUTE,\n    x2: MUST_USE_ATTRIBUTE,\n    x: MUST_USE_ATTRIBUTE,\n    xlinkActuate: MUST_USE_ATTRIBUTE,\n    xlinkArcrole: MUST_USE_ATTRIBUTE,\n    xlinkHref: MUST_USE_ATTRIBUTE,\n    xlinkRole: MUST_USE_ATTRIBUTE,\n    xlinkShow: MUST_USE_ATTRIBUTE,\n    xlinkTitle: MUST_USE_ATTRIBUTE,\n    xlinkType: MUST_USE_ATTRIBUTE,\n    xmlBase: MUST_USE_ATTRIBUTE,\n    xmlLang: MUST_USE_ATTRIBUTE,\n    xmlSpace: MUST_USE_ATTRIBUTE,\n    y1: MUST_USE_ATTRIBUTE,\n    y2: MUST_USE_ATTRIBUTE,\n    y: MUST_USE_ATTRIBUTE\n  },\n  DOMAttributeNamespaces: {\n    xlinkActuate: NS.xlink,\n    xlinkArcrole: NS.xlink,\n    xlinkHref: NS.xlink,\n    xlinkRole: NS.xlink,\n    xlinkShow: NS.xlink,\n    xlinkTitle: NS.xlink,\n    xlinkType: NS.xlink,\n    xmlBase: NS.xml,\n    xmlLang: NS.xml,\n    xmlSpace: NS.xml\n  },\n  DOMAttributeNames: {\n    clipPath: 'clip-path',\n    fillOpacity: 'fill-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    gradientTransform: 'gradientTransform',\n    gradientUnits: 'gradientUnits',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    patternContentUnits: 'patternContentUnits',\n    patternUnits: 'patternUnits',\n    preserveAspectRatio: 'preserveAspectRatio',\n    spreadMethod: 'spreadMethod',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strokeDasharray: 'stroke-dasharray',\n    strokeLinecap: 'stroke-linecap',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    textAnchor: 'text-anchor',\n    viewBox: 'viewBox',\n    xlinkActuate: 'xlink:actuate',\n    xlinkArcrole: 'xlink:arcrole',\n    xlinkHref: 'xlink:href',\n    xlinkRole: 'xlink:role',\n    xlinkShow: 'xlink:show',\n    xlinkTitle: 'xlink:title',\n    xlinkType: 'xlink:type',\n    xmlBase: 'xml:base',\n    xmlLang: 'xml:lang',\n    xmlSpace: 'xml:space'\n  }\n};\n\nmodule.exports = SVGDOMPropertyConfig;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SVGDOMPropertyConfig.js\n ** module id = 172\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SVGDOMPropertyConfig.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SelectEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventPropagators = __webpack_require__(22);\nvar ExecutionEnvironment = __webpack_require__(5);\nvar ReactInputSelection = __webpack_require__(84);\nvar SyntheticEvent = __webpack_require__(17);\n\nvar getActiveElement = __webpack_require__(64);\nvar isTextInputElement = __webpack_require__(95);\nvar keyOf = __webpack_require__(13);\nvar shallowEqual = __webpack_require__(66);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSelect: null }),\n      captured: keyOf({ onSelectCapture: null })\n    },\n    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]\n  }\n};\n\nvar activeElement = null;\nvar activeElementID = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n// Track whether a listener exists for this plugin. If none exist, we do\n// not extract events.\nvar hasListener = false;\nvar ON_SELECT_KEY = keyOf({ onSelect: null });\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  } else if (document.selection) {\n    var range = document.selection.createRange();\n    return {\n      parentElement: range.parentElement(),\n      text: range.text,\n      top: range.boundingTop,\n      left: range.boundingLeft\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement;\n\n    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    if (!hasListener) {\n      return null;\n    }\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case topLevelTypes.topFocus:\n        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {\n          activeElement = topLevelTarget;\n          activeElementID = topLevelTargetID;\n          lastSelection = null;\n        }\n        break;\n      case topLevelTypes.topBlur:\n        activeElement = null;\n        activeElementID = null;\n        lastSelection = null;\n        break;\n\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case topLevelTypes.topMouseDown:\n        mouseDown = true;\n        break;\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topMouseUp:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case topLevelTypes.topSelectionChange:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  },\n\n  didPutListener: function (id, registrationName, listener) {\n    if (registrationName === ON_SELECT_KEY) {\n      hasListener = true;\n    }\n  }\n};\n\nmodule.exports = SelectEventPlugin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SelectEventPlugin.js\n ** module id = 173\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SelectEventPlugin.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ServerReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Size of the reactRoot ID space. We generate random numbers for React root\n * IDs and if there's a collision the events and DOM update system will\n * get confused. In the future we need a way to generate GUIDs but for\n * now this will work on a smaller scale.\n */\nvar GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);\n\nvar ServerReactRootIndex = {\n  createReactRootIndex: function () {\n    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);\n  }\n};\n\nmodule.exports = ServerReactRootIndex;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ServerReactRootIndex.js\n ** module id = 174\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ServerReactRootIndex.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SimpleEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(11);\nvar EventListener = __webpack_require__(61);\nvar EventPropagators = __webpack_require__(22);\nvar ReactMount = __webpack_require__(6);\nvar SyntheticClipboardEvent = __webpack_require__(176);\nvar SyntheticEvent = __webpack_require__(17);\nvar SyntheticFocusEvent = __webpack_require__(179);\nvar SyntheticKeyboardEvent = __webpack_require__(181);\nvar SyntheticMouseEvent = __webpack_require__(29);\nvar SyntheticDragEvent = __webpack_require__(178);\nvar SyntheticTouchEvent = __webpack_require__(182);\nvar SyntheticUIEvent = __webpack_require__(24);\nvar SyntheticWheelEvent = __webpack_require__(183);\n\nvar emptyFunction = __webpack_require__(10);\nvar getEventCharCode = __webpack_require__(50);\nvar invariant = __webpack_require__(2);\nvar keyOf = __webpack_require__(13);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  abort: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onAbort: true }),\n      captured: keyOf({ onAbortCapture: true })\n    }\n  },\n  blur: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onBlur: true }),\n      captured: keyOf({ onBlurCapture: true })\n    }\n  },\n  canPlay: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCanPlay: true }),\n      captured: keyOf({ onCanPlayCapture: true })\n    }\n  },\n  canPlayThrough: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCanPlayThrough: true }),\n      captured: keyOf({ onCanPlayThroughCapture: true })\n    }\n  },\n  click: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onClick: true }),\n      captured: keyOf({ onClickCapture: true })\n    }\n  },\n  contextMenu: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onContextMenu: true }),\n      captured: keyOf({ onContextMenuCapture: true })\n    }\n  },\n  copy: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCopy: true }),\n      captured: keyOf({ onCopyCapture: true })\n    }\n  },\n  cut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onCut: true }),\n      captured: keyOf({ onCutCapture: true })\n    }\n  },\n  doubleClick: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDoubleClick: true }),\n      captured: keyOf({ onDoubleClickCapture: true })\n    }\n  },\n  drag: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDrag: true }),\n      captured: keyOf({ onDragCapture: true })\n    }\n  },\n  dragEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragEnd: true }),\n      captured: keyOf({ onDragEndCapture: true })\n    }\n  },\n  dragEnter: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragEnter: true }),\n      captured: keyOf({ onDragEnterCapture: true })\n    }\n  },\n  dragExit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragExit: true }),\n      captured: keyOf({ onDragExitCapture: true })\n    }\n  },\n  dragLeave: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragLeave: true }),\n      captured: keyOf({ onDragLeaveCapture: true })\n    }\n  },\n  dragOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragOver: true }),\n      captured: keyOf({ onDragOverCapture: true })\n    }\n  },\n  dragStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDragStart: true }),\n      captured: keyOf({ onDragStartCapture: true })\n    }\n  },\n  drop: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDrop: true }),\n      captured: keyOf({ onDropCapture: true })\n    }\n  },\n  durationChange: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onDurationChange: true }),\n      captured: keyOf({ onDurationChangeCapture: true })\n    }\n  },\n  emptied: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onEmptied: true }),\n      captured: keyOf({ onEmptiedCapture: true })\n    }\n  },\n  encrypted: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onEncrypted: true }),\n      captured: keyOf({ onEncryptedCapture: true })\n    }\n  },\n  ended: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onEnded: true }),\n      captured: keyOf({ onEndedCapture: true })\n    }\n  },\n  error: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onError: true }),\n      captured: keyOf({ onErrorCapture: true })\n    }\n  },\n  focus: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onFocus: true }),\n      captured: keyOf({ onFocusCapture: true })\n    }\n  },\n  input: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onInput: true }),\n      captured: keyOf({ onInputCapture: true })\n    }\n  },\n  keyDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onKeyDown: true }),\n      captured: keyOf({ onKeyDownCapture: true })\n    }\n  },\n  keyPress: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onKeyPress: true }),\n      captured: keyOf({ onKeyPressCapture: true })\n    }\n  },\n  keyUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onKeyUp: true }),\n      captured: keyOf({ onKeyUpCapture: true })\n    }\n  },\n  load: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onLoad: true }),\n      captured: keyOf({ onLoadCapture: true })\n    }\n  },\n  loadedData: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onLoadedData: true }),\n      captured: keyOf({ onLoadedDataCapture: true })\n    }\n  },\n  loadedMetadata: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onLoadedMetadata: true }),\n      captured: keyOf({ onLoadedMetadataCapture: true })\n    }\n  },\n  loadStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onLoadStart: true }),\n      captured: keyOf({ onLoadStartCapture: true })\n    }\n  },\n  // Note: We do not allow listening to mouseOver events. Instead, use the\n  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.\n  mouseDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMouseDown: true }),\n      captured: keyOf({ onMouseDownCapture: true })\n    }\n  },\n  mouseMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMouseMove: true }),\n      captured: keyOf({ onMouseMoveCapture: true })\n    }\n  },\n  mouseOut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMouseOut: true }),\n      captured: keyOf({ onMouseOutCapture: true })\n    }\n  },\n  mouseOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMouseOver: true }),\n      captured: keyOf({ onMouseOverCapture: true })\n    }\n  },\n  mouseUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onMouseUp: true }),\n      captured: keyOf({ onMouseUpCapture: true })\n    }\n  },\n  paste: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onPaste: true }),\n      captured: keyOf({ onPasteCapture: true })\n    }\n  },\n  pause: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onPause: true }),\n      captured: keyOf({ onPauseCapture: true })\n    }\n  },\n  play: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onPlay: true }),\n      captured: keyOf({ onPlayCapture: true })\n    }\n  },\n  playing: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onPlaying: true }),\n      captured: keyOf({ onPlayingCapture: true })\n    }\n  },\n  progress: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onProgress: true }),\n      captured: keyOf({ onProgressCapture: true })\n    }\n  },\n  rateChange: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onRateChange: true }),\n      captured: keyOf({ onRateChangeCapture: true })\n    }\n  },\n  reset: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onReset: true }),\n      captured: keyOf({ onResetCapture: true })\n    }\n  },\n  scroll: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onScroll: true }),\n      captured: keyOf({ onScrollCapture: true })\n    }\n  },\n  seeked: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSeeked: true }),\n      captured: keyOf({ onSeekedCapture: true })\n    }\n  },\n  seeking: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSeeking: true }),\n      captured: keyOf({ onSeekingCapture: true })\n    }\n  },\n  stalled: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onStalled: true }),\n      captured: keyOf({ onStalledCapture: true })\n    }\n  },\n  submit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSubmit: true }),\n      captured: keyOf({ onSubmitCapture: true })\n    }\n  },\n  suspend: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onSuspend: true }),\n      captured: keyOf({ onSuspendCapture: true })\n    }\n  },\n  timeUpdate: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onTimeUpdate: true }),\n      captured: keyOf({ onTimeUpdateCapture: true })\n    }\n  },\n  touchCancel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onTouchCancel: true }),\n      captured: keyOf({ onTouchCancelCapture: true })\n    }\n  },\n  touchEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onTouchEnd: true }),\n      captured: keyOf({ onTouchEndCapture: true })\n    }\n  },\n  touchMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onTouchMove: true }),\n      captured: keyOf({ onTouchMoveCapture: true })\n    }\n  },\n  touchStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onTouchStart: true }),\n      captured: keyOf({ onTouchStartCapture: true })\n    }\n  },\n  volumeChange: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onVolumeChange: true }),\n      captured: keyOf({ onVolumeChangeCapture: true })\n    }\n  },\n  waiting: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onWaiting: true }),\n      captured: keyOf({ onWaitingCapture: true })\n    }\n  },\n  wheel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({ onWheel: true }),\n      captured: keyOf({ onWheelCapture: true })\n    }\n  }\n};\n\nvar topLevelEventsToDispatchConfig = {\n  topAbort: eventTypes.abort,\n  topBlur: eventTypes.blur,\n  topCanPlay: eventTypes.canPlay,\n  topCanPlayThrough: eventTypes.canPlayThrough,\n  topClick: eventTypes.click,\n  topContextMenu: eventTypes.contextMenu,\n  topCopy: eventTypes.copy,\n  topCut: eventTypes.cut,\n  topDoubleClick: eventTypes.doubleClick,\n  topDrag: eventTypes.drag,\n  topDragEnd: eventTypes.dragEnd,\n  topDragEnter: eventTypes.dragEnter,\n  topDragExit: eventTypes.dragExit,\n  topDragLeave: eventTypes.dragLeave,\n  topDragOver: eventTypes.dragOver,\n  topDragStart: eventTypes.dragStart,\n  topDrop: eventTypes.drop,\n  topDurationChange: eventTypes.durationChange,\n  topEmptied: eventTypes.emptied,\n  topEncrypted: eventTypes.encrypted,\n  topEnded: eventTypes.ended,\n  topError: eventTypes.error,\n  topFocus: eventTypes.focus,\n  topInput: eventTypes.input,\n  topKeyDown: eventTypes.keyDown,\n  topKeyPress: eventTypes.keyPress,\n  topKeyUp: eventTypes.keyUp,\n  topLoad: eventTypes.load,\n  topLoadedData: eventTypes.loadedData,\n  topLoadedMetadata: eventTypes.loadedMetadata,\n  topLoadStart: eventTypes.loadStart,\n  topMouseDown: eventTypes.mouseDown,\n  topMouseMove: eventTypes.mouseMove,\n  topMouseOut: eventTypes.mouseOut,\n  topMouseOver: eventTypes.mouseOver,\n  topMouseUp: eventTypes.mouseUp,\n  topPaste: eventTypes.paste,\n  topPause: eventTypes.pause,\n  topPlay: eventTypes.play,\n  topPlaying: eventTypes.playing,\n  topProgress: eventTypes.progress,\n  topRateChange: eventTypes.rateChange,\n  topReset: eventTypes.reset,\n  topScroll: eventTypes.scroll,\n  topSeeked: eventTypes.seeked,\n  topSeeking: eventTypes.seeking,\n  topStalled: eventTypes.stalled,\n  topSubmit: eventTypes.submit,\n  topSuspend: eventTypes.suspend,\n  topTimeUpdate: eventTypes.timeUpdate,\n  topTouchCancel: eventTypes.touchCancel,\n  topTouchEnd: eventTypes.touchEnd,\n  topTouchMove: eventTypes.touchMove,\n  topTouchStart: eventTypes.touchStart,\n  topVolumeChange: eventTypes.volumeChange,\n  topWaiting: eventTypes.waiting,\n  topWheel: eventTypes.wheel\n};\n\nfor (var type in topLevelEventsToDispatchConfig) {\n  topLevelEventsToDispatchConfig[type].dependencies = [type];\n}\n\nvar ON_CLICK_KEY = keyOf({ onClick: null });\nvar onClickListeners = {};\n\nvar SimpleEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case topLevelTypes.topAbort:\n      case topLevelTypes.topCanPlay:\n      case topLevelTypes.topCanPlayThrough:\n      case topLevelTypes.topDurationChange:\n      case topLevelTypes.topEmptied:\n      case topLevelTypes.topEncrypted:\n      case topLevelTypes.topEnded:\n      case topLevelTypes.topError:\n      case topLevelTypes.topInput:\n      case topLevelTypes.topLoad:\n      case topLevelTypes.topLoadedData:\n      case topLevelTypes.topLoadedMetadata:\n      case topLevelTypes.topLoadStart:\n      case topLevelTypes.topPause:\n      case topLevelTypes.topPlay:\n      case topLevelTypes.topPlaying:\n      case topLevelTypes.topProgress:\n      case topLevelTypes.topRateChange:\n      case topLevelTypes.topReset:\n      case topLevelTypes.topSeeked:\n      case topLevelTypes.topSeeking:\n      case topLevelTypes.topStalled:\n      case topLevelTypes.topSubmit:\n      case topLevelTypes.topSuspend:\n      case topLevelTypes.topTimeUpdate:\n      case topLevelTypes.topVolumeChange:\n      case topLevelTypes.topWaiting:\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent;\n        break;\n      case topLevelTypes.topKeyPress:\n        // FireFox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case topLevelTypes.topBlur:\n      case topLevelTypes.topFocus:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case topLevelTypes.topClick:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topDoubleClick:\n      case topLevelTypes.topMouseDown:\n      case topLevelTypes.topMouseMove:\n      case topLevelTypes.topMouseOut:\n      case topLevelTypes.topMouseOver:\n      case topLevelTypes.topMouseUp:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case topLevelTypes.topDrag:\n      case topLevelTypes.topDragEnd:\n      case topLevelTypes.topDragEnter:\n      case topLevelTypes.topDragExit:\n      case topLevelTypes.topDragLeave:\n      case topLevelTypes.topDragOver:\n      case topLevelTypes.topDragStart:\n      case topLevelTypes.topDrop:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case topLevelTypes.topTouchCancel:\n      case topLevelTypes.topTouchEnd:\n      case topLevelTypes.topTouchMove:\n      case topLevelTypes.topTouchStart:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case topLevelTypes.topScroll:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case topLevelTypes.topWheel:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case topLevelTypes.topCopy:\n      case topLevelTypes.topCut:\n      case topLevelTypes.topPaste:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n    }\n    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;\n    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  },\n\n  didPutListener: function (id, registrationName, listener) {\n    // Mobile Safari does not fire properly bubble click events on\n    // non-interactive elements, which means delegated click listeners do not\n    // fire. The workaround for this bug involves attaching an empty click\n    // listener on the target node.\n    if (registrationName === ON_CLICK_KEY) {\n      var node = ReactMount.getNode(id);\n      if (!onClickListeners[id]) {\n        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);\n      }\n    }\n  },\n\n  willDeleteListener: function (id, registrationName) {\n    if (registrationName === ON_CLICK_KEY) {\n      onClickListeners[id].remove();\n      delete onClickListeners[id];\n    }\n  }\n\n};\n\nmodule.exports = SimpleEventPlugin;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SimpleEventPlugin.js\n ** module id = 175\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SimpleEventPlugin.js?");
},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticClipboardEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(17);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\nmodule.exports = SyntheticClipboardEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticClipboardEvent.js\n ** module id = 176\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticClipboardEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticCompositionEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(17);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n\nmodule.exports = SyntheticCompositionEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticCompositionEvent.js\n ** module id = 177\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticCompositionEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticDragEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticMouseEvent = __webpack_require__(29);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\nmodule.exports = SyntheticDragEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticDragEvent.js\n ** module id = 178\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticDragEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticFocusEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(24);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\nmodule.exports = SyntheticFocusEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticFocusEvent.js\n ** module id = 179\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticFocusEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticInputEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(17);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);\n\nmodule.exports = SyntheticInputEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticInputEvent.js\n ** module id = 180\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticInputEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticKeyboardEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(24);\n\nvar getEventCharCode = __webpack_require__(50);\nvar getEventKey = __webpack_require__(188);\nvar getEventModifierState = __webpack_require__(51);\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\nmodule.exports = SyntheticKeyboardEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticKeyboardEvent.js\n ** module id = 181\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticKeyboardEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticTouchEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(24);\n\nvar getEventModifierState = __webpack_require__(51);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\nmodule.exports = SyntheticTouchEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticTouchEvent.js\n ** module id = 182\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticTouchEvent.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticWheelEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticMouseEvent = __webpack_require__(29);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX :\n    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY :\n    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY :\n    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\nmodule.exports = SyntheticWheelEvent;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticWheelEvent.js\n ** module id = 183\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticWheelEvent.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule adler32\n */\n\n'use strict';\n\nvar MOD = 65521;\n\n// adler32 is not cryptographically strong, and is only used to sanity check that\n// markup generated on the server matches the markup generated on the client.\n// This implementation (a modified version of the SheetJS version) has been optimized\n// for our use case, at the expense of conforming to the adler32 specification\n// for non-ascii inputs.\nfunction adler32(data) {\n  var a = 1;\n  var b = 0;\n  var i = 0;\n  var l = data.length;\n  var m = l & ~0x3;\n  while (i < m) {\n    for (; i < Math.min(i + 4096, m); i += 4) {\n      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));\n    }\n    a %= MOD;\n    b %= MOD;\n  }\n  for (; i < l; i++) {\n    b += a += data.charCodeAt(i);\n  }\n  a %= MOD;\n  b %= MOD;\n  return a | b << 16;\n}\n\nmodule.exports = adler32;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/adler32.js\n ** module id = 184\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/adler32.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule dangerousStyleValue\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CSSProperty = __webpack_require__(68);\n\nvar isUnitlessNumber = CSSProperty.isUnitlessNumber;\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  var isNonNumeric = isNaN(value);\n  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {\n    return '' + value; // cast to string\n  }\n\n  if (typeof value === 'string') {\n    value = value.trim();\n  }\n  return value + 'px';\n}\n\nmodule.exports = dangerousStyleValue;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/dangerousStyleValue.js\n ** module id = 185\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/dangerousStyleValue.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule deprecated\n */\n\n'use strict';\n\nvar assign = __webpack_require__(3);\nvar warning = __webpack_require__(4);\n\n/**\n * This will log a single deprecation notice per function and forward the call\n * on to the new API.\n *\n * @param {string} fnName The name of the function\n * @param {string} newModule The module that fn will exist in\n * @param {string} newPackage The module that fn will exist in\n * @param {*} ctx The context this forwarded call should run in\n * @param {function} fn The function to forward on to\n * @return {function} The function that will warn once and then call fn\n */\nfunction deprecated(fnName, newModule, newPackage, ctx, fn) {\n  var warned = false;\n  if (process.env.NODE_ENV !== 'production') {\n    var newFn = function () {\n      process.env.NODE_ENV !== 'production' ? warning(warned,\n      // Require examples in this string must be split to prevent React's\n      // build tools from mistaking them for real requires.\n      // Otherwise the build tools will attempt to build a '%s' module.\n      'React.%s is deprecated. Please use %s.%s from require' + '(\\'%s\\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;\n      warned = true;\n      return fn.apply(ctx, arguments);\n    };\n    // We need to make sure all properties of the original fn are copied over.\n    // In particular, this is needed to support PropTypes\n    return assign(newFn, fn);\n  }\n\n  return fn;\n}\n\nmodule.exports = deprecated;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/deprecated.js\n ** module id = 186\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/deprecated.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenChildren\n */\n\n'use strict';\n\nvar traverseAllChildren = __webpack_require__(58);\nvar warning = __webpack_require__(4);\n\n/**\n * @param {function} traverseContext Context passed through traversal.\n * @param {?ReactComponent} child React child component.\n * @param {!string} name String name of key path to child.\n */\nfunction flattenSingleChildIntoContext(traverseContext, child, name) {\n  // We found a component instance.\n  var result = traverseContext;\n  var keyUnique = result[name] === undefined;\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;\n  }\n  if (keyUnique && child != null) {\n    result[name] = child;\n  }\n}\n\n/**\n * Flattens children that are typically specified as `props.children`. Any null\n * children will not be included in the resulting object.\n * @return {!object} flattened children keyed by name.\n */\nfunction flattenChildren(children) {\n  if (children == null) {\n    return children;\n  }\n  var result = {};\n  traverseAllChildren(children, flattenSingleChildIntoContext, result);\n  return result;\n}\n\nmodule.exports = flattenChildren;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/flattenChildren.js\n ** module id = 187\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/flattenChildren.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventKey\n * @typechecks static-only\n */\n\n'use strict';\n\nvar getEventCharCode = __webpack_require__(50);\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  'Esc': 'Escape',\n  'Spacebar': ' ',\n  'Left': 'ArrowLeft',\n  'Up': 'ArrowUp',\n  'Right': 'ArrowRight',\n  'Down': 'ArrowDown',\n  'Del': 'Delete',\n  'Win': 'OS',\n  'Menu': 'ContextMenu',\n  'Apps': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'MozPrintableKey': 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  8: 'Backspace',\n  9: 'Tab',\n  12: 'Clear',\n  13: 'Enter',\n  16: 'Shift',\n  17: 'Control',\n  18: 'Alt',\n  19: 'Pause',\n  20: 'CapsLock',\n  27: 'Escape',\n  32: ' ',\n  33: 'PageUp',\n  34: 'PageDown',\n  35: 'End',\n  36: 'Home',\n  37: 'ArrowLeft',\n  38: 'ArrowUp',\n  39: 'ArrowRight',\n  40: 'ArrowDown',\n  45: 'Insert',\n  46: 'Delete',\n  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',\n  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',\n  144: 'NumLock',\n  145: 'ScrollLock',\n  224: 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\nmodule.exports = getEventKey;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventKey.js\n ** module id = 188\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventKey.js?")},function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getNodeForCharacterOffset\n */\n\n'use strict';\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === 3) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\nmodule.exports = getNodeForCharacterOffset;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getNodeForCharacterOffset.js\n ** module id = 189\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getNodeForCharacterOffset.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule onlyChild\n */\n'use strict';\n\nvar ReactElement = __webpack_require__(7);\n\nvar invariant = __webpack_require__(2);\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection. The current implementation of this\n * function assumes that a single child gets passed without a wrapper, but the\n * purpose of this helper function is to abstract away the particular structure\n * of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactComponent} The first and only `ReactComponent` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;\n  return children;\n}\n\nmodule.exports = onlyChild;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/onlyChild.js\n ** module id = 190\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/onlyChild.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule quoteAttributeValueForBrowser\n */\n\n'use strict';\n\nvar escapeTextContentForBrowser = __webpack_require__(32);\n\n/**\n * Escapes attribute value to prevent scripting attacks.\n *\n * @param {*} value Value to escape.\n * @return {string} An escaped string.\n */\nfunction quoteAttributeValueForBrowser(value) {\n  return '\"' + escapeTextContentForBrowser(value) + '\"';\n}\n\nmodule.exports = quoteAttributeValueForBrowser;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/quoteAttributeValueForBrowser.js\n ** module id = 191\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/quoteAttributeValueForBrowser.js?")},function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule renderSubtreeIntoContainer\n*/\n\n'use strict';\n\nvar ReactMount = __webpack_require__(6);\n\nmodule.exports = ReactMount.renderSubtreeIntoContainer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/renderSubtreeIntoContainer.js\n ** module id = 192\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/renderSubtreeIntoContainer.js?")},function(module,exports,__webpack_require__){eval("'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = applyMiddleware;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _compose = __webpack_require__(98);\n\nvar _compose2 = _interopRequireDefault(_compose);\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (next) {\n    return function (reducer, initialState) {\n      var store = next(reducer, initialState);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/applyMiddleware.js\n ** module id = 193\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/applyMiddleware.js?");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nexports.__esModule = true;\nexports['default'] = bindActionCreators;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _utilsMapValues = __webpack_require__(100);\n\nvar _utilsMapValues2 = _interopRequireDefault(_utilsMapValues);\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null || actionCreators === undefined) {\n    // eslint-disable-line no-eq-null\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  return _utilsMapValues2['default'](actionCreators, function (actionCreator) {\n    return bindActionCreator(actionCreator, dispatch);\n  });\n}\n\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/bindActionCreators.js\n ** module id = 194\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/bindActionCreators.js?")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\nexports.__esModule = true;\nexports['default'] = combineReducers;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _createStore = __webpack_require__(96);\n\nvar _utilsIsPlainObject = __webpack_require__(99);\n\nvar _utilsIsPlainObject2 = _interopRequireDefault(_utilsIsPlainObject);\n\nvar _utilsMapValues = __webpack_require__(100);\n\nvar _utilsMapValues2 = _interopRequireDefault(_utilsMapValues);\n\nvar _utilsPick = __webpack_require__(196);\n\nvar _utilsPick2 = _interopRequireDefault(_utilsPick);\n\n/* eslint-disable no-console */\n\nfunction getErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Reducer \"' + key + '\" returned undefined handling ' + actionName + '. ' + 'To ignore an action, you must explicitly return the previous state.';\n}\n\nfunction verifyStateShape(inputState, outputState, action) {\n  var reducerKeys = Object.keys(outputState);\n  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    console.error('Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.');\n    return;\n  }\n\n  if (!_utilsIsPlainObject2['default'](inputState)) {\n    console.error('The ' + argumentName + ' has unexpected type of \"' + ({}).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"'));\n    return;\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return reducerKeys.indexOf(key) < 0;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    console.error('Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.'));\n  }\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\nfunction combineReducers(reducers) {\n  var finalReducers = _utilsPick2['default'](reducers, function (val) {\n    return typeof val === 'function';\n  });\n  var sanityError;\n\n  Object.keys(finalReducers).forEach(function (key) {\n    var reducer = finalReducers[key];\n    if (!sanityError && typeof reducer(undefined, { type: _createStore.ActionTypes.INIT }) === 'undefined') {\n      sanityError = new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (!sanityError && typeof reducer(undefined, { type: type }) === 'undefined') {\n      sanityError = new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');\n    }\n  });\n\n  var defaultState = _utilsMapValues2['default'](finalReducers, function () {\n    return undefined;\n  });\n\n  return function combination(state, action) {\n    if (state === undefined) state = defaultState;\n\n    if (sanityError) {\n      throw sanityError;\n    }\n    var finalState = _utilsMapValues2['default'](finalReducers, function (reducer, key) {\n      var newState = reducer(state[key], action);\n      if (typeof newState === 'undefined') {\n        throw new Error(getErrorMessage(key, action));\n      }\n      return newState;\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      verifyStateShape(state, finalState, action);\n    }\n\n    return finalState;\n  };\n}\n\nmodule.exports = exports['default'];\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/combineReducers.js\n ** module id = 195\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/combineReducers.js?")},function(module,exports){eval('/**\n * Picks key-value pairs from an object where values satisfy a predicate.\n *\n * @param {Object} obj The object to pick from.\n * @param {Function} fn The predicate the values must satisfy to be copied.\n * @returns {Object} The object with the values that satisfied the predicate.\n */\n"use strict";\n\nexports.__esModule = true;\nexports["default"] = pick;\n\nfunction pick(obj, fn) {\n  return Object.keys(obj).reduce(function (result, key) {\n    if (fn(obj[key])) {\n      result[key] = obj[key];\n    }\n    return result;\n  }, {});\n}\n\nmodule.exports = exports["default"];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/redux/lib/utils/pick.js\n ** module id = 196\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/redux/lib/utils/pick.js?')},function(module,exports,__webpack_require__){eval("'use strict';\nvar ansiRegex = __webpack_require__(104)();\n\nmodule.exports = function (str) {\n	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/strip-ansi/index.js\n ** module id = 197\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/strip-ansi/index.js?")},function(module,exports,__webpack_require__){eval('/*\r\n	MIT License http://www.opensource.org/licenses/mit-license.php\r\n	Author Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n	memoize = function(fn) {\r\n		var memo;\r\n		return function () {\r\n			if (typeof memo === "undefined") memo = fn.apply(this, arguments);\r\n			return memo;\r\n		};\r\n	},\r\n	isOldIE = memoize(function() {\r\n		return /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n	}),\r\n	getHeadElement = memoize(function () {\r\n		return document.head || document.getElementsByTagName("head")[0];\r\n	}),\r\n	singletonElement = null,\r\n	singletonCounter = 0,\r\n	styleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n	if(false) {\r\n		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\r\n	}\r\n\r\n	options = options || {};\r\n	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n	// tags it will allow on a page\r\n	if (typeof options.singleton === "undefined") options.singleton = isOldIE();\r\n\r\n	// By default, add <style> tags to the bottom of <head>.\r\n	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";\r\n\r\n	var styles = listToStyles(list);\r\n	addStylesToDom(styles, options);\r\n\r\n	return function update(newList) {\r\n		var mayRemove = [];\r\n		for(var i = 0; i < styles.length; i++) {\r\n			var item = styles[i];\r\n			var domStyle = stylesInDom[item.id];\r\n			domStyle.refs--;\r\n			mayRemove.push(domStyle);\r\n		}\r\n		if(newList) {\r\n			var newStyles = listToStyles(newList);\r\n			addStylesToDom(newStyles, options);\r\n		}\r\n		for(var i = 0; i < mayRemove.length; i++) {\r\n			var domStyle = mayRemove[i];\r\n			if(domStyle.refs === 0) {\r\n				for(var j = 0; j < domStyle.parts.length; j++)\r\n					domStyle.parts[j]();\r\n				delete stylesInDom[domStyle.id];\r\n			}\r\n		}\r\n	};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n	for(var i = 0; i < styles.length; i++) {\r\n		var item = styles[i];\r\n		var domStyle = stylesInDom[item.id];\r\n		if(domStyle) {\r\n			domStyle.refs++;\r\n			for(var j = 0; j < domStyle.parts.length; j++) {\r\n				domStyle.parts[j](item.parts[j]);\r\n			}\r\n			for(; j < item.parts.length; j++) {\r\n				domStyle.parts.push(addStyle(item.parts[j], options));\r\n			}\r\n		} else {\r\n			var parts = [];\r\n			for(var j = 0; j < item.parts.length; j++) {\r\n				parts.push(addStyle(item.parts[j], options));\r\n			}\r\n			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n		}\r\n	}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n	var styles = [];\r\n	var newStyles = {};\r\n	for(var i = 0; i < list.length; i++) {\r\n		var item = list[i];\r\n		var id = item[0];\r\n		var css = item[1];\r\n		var media = item[2];\r\n		var sourceMap = item[3];\r\n		var part = {css: css, media: media, sourceMap: sourceMap};\r\n		if(!newStyles[id])\r\n			styles.push(newStyles[id] = {id: id, parts: [part]});\r\n		else\r\n			newStyles[id].parts.push(part);\r\n	}\r\n	return styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n	var head = getHeadElement();\r\n	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n	if (options.insertAt === "top") {\r\n		if(!lastStyleElementInsertedAtTop) {\r\n			head.insertBefore(styleElement, head.firstChild);\r\n		} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n		} else {\r\n			head.appendChild(styleElement);\r\n		}\r\n		styleElementsInsertedAtTop.push(styleElement);\r\n	} else if (options.insertAt === "bottom") {\r\n		head.appendChild(styleElement);\r\n	} else {\r\n		throw new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\r\n	}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n	styleElement.parentNode.removeChild(styleElement);\r\n	var idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n	if(idx >= 0) {\r\n		styleElementsInsertedAtTop.splice(idx, 1);\r\n	}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n	var styleElement = document.createElement("style");\r\n	styleElement.type = "text/css";\r\n	insertStyleElement(options, styleElement);\r\n	return styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n	var linkElement = document.createElement("link");\r\n	linkElement.rel = "stylesheet";\r\n	insertStyleElement(options, linkElement);\r\n	return linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n	var styleElement, update, remove;\r\n\r\n	if (options.singleton) {\r\n		var styleIndex = singletonCounter++;\r\n		styleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n	} else if(obj.sourceMap &&\r\n		typeof URL === "function" &&\r\n		typeof URL.createObjectURL === "function" &&\r\n		typeof URL.revokeObjectURL === "function" &&\r\n		typeof Blob === "function" &&\r\n		typeof btoa === "function") {\r\n		styleElement = createLinkElement(options);\r\n		update = updateLink.bind(null, styleElement);\r\n		remove = function() {\r\n			removeStyleElement(styleElement);\r\n			if(styleElement.href)\r\n				URL.revokeObjectURL(styleElement.href);\r\n		};\r\n	} else {\r\n		styleElement = createStyleElement(options);\r\n		update = applyToTag.bind(null, styleElement);\r\n		remove = function() {\r\n			removeStyleElement(styleElement);\r\n		};\r\n	}\r\n\r\n	update(obj);\r\n\r\n	return function updateStyle(newObj) {\r\n		if(newObj) {\r\n			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n				return;\r\n			update(obj = newObj);\r\n		} else {\r\n			remove();\r\n		}\r\n	};\r\n}\r\n\r\nvar replaceText = (function () {\r\n	var textStore = [];\r\n\r\n	return function (index, replacement) {\r\n		textStore[index] = replacement;\r\n		return textStore.filter(Boolean).join(\'\\n\');\r\n	};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n	var css = remove ? "" : obj.css;\r\n\r\n	if (styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = replaceText(index, css);\r\n	} else {\r\n		var cssNode = document.createTextNode(css);\r\n		var childNodes = styleElement.childNodes;\r\n		if (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n		if (childNodes.length) {\r\n			styleElement.insertBefore(cssNode, childNodes[index]);\r\n		} else {\r\n			styleElement.appendChild(cssNode);\r\n		}\r\n	}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n	var css = obj.css;\r\n	var media = obj.media;\r\n\r\n	if(media) {\r\n		styleElement.setAttribute("media", media)\r\n	}\r\n\r\n	if(styleElement.styleSheet) {\r\n		styleElement.styleSheet.cssText = css;\r\n	} else {\r\n		while(styleElement.firstChild) {\r\n			styleElement.removeChild(styleElement.firstChild);\r\n		}\r\n		styleElement.appendChild(document.createTextNode(css));\r\n	}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n	var css = obj.css;\r\n	var sourceMap = obj.sourceMap;\r\n\r\n	if(sourceMap) {\r\n		// http://stackoverflow.com/a/26603875\r\n		css += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\r\n	}\r\n\r\n	var blob = new Blob([css], { type: "text/css" });\r\n\r\n	var oldSrc = linkElement.href;\r\n\r\n	linkElement.href = URL.createObjectURL(blob);\r\n\r\n	if(oldSrc)\r\n		URL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 198\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(39);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(198)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(true) {\n	// When the styles change, update the <style> tags\n	if(!content.locals) {\n		module.hot.accept(39, function() {\n			var newContent = __webpack_require__(39);\n			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n			update(newContent);\n		});\n	}\n	// When the module is disposed, remove the <style> tags\n	module.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/scss/main.scss\n ** module id = 199\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./app/scss/main.scss?")},function(module,exports,__webpack_require__){eval("/*eslint-env browser*/\n\nvar clientOverlay = document.createElement('div');\nvar styles = {\n  background: 'rgba(0,0,0,0.85)',\n  color: '#E8E8E8',\n  lineHeight: '1.2',\n  whiteSpace: 'pre',\n  fontFamily: 'Menlo, Consolas, monospace',\n  fontSize: '13px',\n  position: 'fixed',\n  zIndex: 9999,\n  padding: '10px',\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  overflow: 'auto'\n};\nfor (var key in styles) {\n  clientOverlay.style[key] = styles[key];\n}\n\nvar ansiHTML = __webpack_require__(103);\nvar colors = {\n  reset: ['transparent', 'transparent'],\n  black: '181818',\n  red: 'E36049',\n  green: 'B3CB74',\n  yellow: 'FFD080',\n  blue: '7CAFC2',\n  magenta: '7FACCA',\n  cyan: 'C3C2EF',\n  lightgrey: 'EBE7E3',\n  darkgrey: '6D7891'\n};\nansiHTML.setColors(colors);\n\nvar Entities = __webpack_require__(131).AllHtmlEntities;\nvar entities = new Entities();\n\nexports.showProblems =\nfunction showProblems(type, lines) {\n  clientOverlay.innerHTML = '';\n  lines.forEach(function(msg) {\n    msg = ansiHTML(entities.encode(msg));\n    var div = document.createElement('div');\n    div.style.marginBottom = '26px';\n    div.innerHTML = problemType(type) + ' in ' + msg;\n    clientOverlay.appendChild(div);\n  });\n  if (document.body) {\n    document.body.appendChild(clientOverlay);\n  }\n};\n\nexports.clear =\nfunction clear() {\n  if (document.body && clientOverlay.parentNode) {\n    document.body.removeChild(clientOverlay);\n  }\n};\n\nvar problemColors = {\n  errors: colors.red,\n  warnings: colors.yellow\n};\n\nfunction problemType (type) {\n  var color = problemColors[type] || colors.red;\n  return (\n    '<span style=\"background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px\">' +\n      type.slice(0, -1).toUpperCase() +\n    '</span>'\n  );\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-hot-middleware/client-overlay.js\n ** module id = 200\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-hot-middleware/client-overlay.js?")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {/*eslint-env browser*/\n/*global __resourceQuery*/\n\nvar options = {\n  path: "/__webpack_hmr",\n  timeout: 20 * 1000,\n  overlay: true,\n  reload: false,\n  log: true,\n  warn: true\n};\nif (false) {\n  var querystring = require(\'querystring\');\n  var overrides = querystring.parse(__resourceQuery.slice(1));\n  if (overrides.path) options.path = overrides.path;\n  if (overrides.timeout) options.timeout = overrides.timeout;\n  if (overrides.overlay) options.overlay = overrides.overlay !== \'false\';\n  if (overrides.reload) options.reload = overrides.reload !== \'false\';\n  if (overrides.noInfo && overrides.noInfo !== \'false\') {\n    options.log = false;\n  }\n  if (overrides.quiet && overrides.quiet !== \'false\') {\n    options.log = false;\n    options.warn = false;\n  }\n}\n\nif (typeof window === \'undefined\') {\n  // do nothing\n} else if (typeof window.EventSource === \'undefined\') {\n  console.warn(\n    "webpack-hot-middleware\'s client requires EventSource to work. " +\n    "You should include a polyfill if you want to support this browser: " +\n    "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools"\n  );\n} else {\n  connect(window.EventSource);\n}\n\nfunction connect(EventSource) {\n  var source = new EventSource(options.path);\n  var lastActivity = new Date();\n\n  source.onopen = handleOnline;\n  source.onmessage = handleMessage;\n  source.onerror = handleDisconnect;\n\n  var timer = setInterval(function() {\n    if ((new Date() - lastActivity) > options.timeout) {\n      handleDisconnect();\n    }\n  }, options.timeout / 2);\n\n  function handleOnline() {\n    if (options.log) console.log("[HMR] connected");\n    lastActivity = new Date();\n  }\n\n  function handleMessage(event) {\n    lastActivity = new Date();\n    if (event.data == "\\uD83D\\uDC93") {\n      return;\n    }\n    try {\n      processMessage(JSON.parse(event.data));\n    } catch (ex) {\n      if (options.warn) {\n        console.warn("Invalid HMR message: " + event.data + "\\n" + ex);\n      }\n    }\n  }\n\n  function handleDisconnect() {\n    clearInterval(timer);\n    source.close();\n    setTimeout(function() { connect(EventSource); }, options.timeout);\n  }\n\n}\n\nvar reporter;\n// the reporter needs to be a singleton on the page\n// in case the client is being used by mutliple bundles\n// we only want to report once.\n// all the errors will go to all clients\nvar singletonKey = \'__webpack_hot_middleware_reporter__\';\nif (typeof window !== \'undefined\' && !window[singletonKey]) {\n  reporter = window[singletonKey] = createReporter();\n}\n\nfunction createReporter() {\n  var strip = __webpack_require__(197);\n\n  var overlay;\n  if (typeof document !== \'undefined\' && options.overlay) {\n    overlay = __webpack_require__(200);\n  }\n\n  return {\n    problems: function(type, obj) {\n      if (options.warn) {\n        console.warn("[HMR] bundle has " + type + ":");\n        obj[type].forEach(function(msg) {\n          console.warn("[HMR] " + strip(msg));\n        });\n      }\n      if (overlay && type !== \'warnings\') overlay.showProblems(type, obj[type]);\n    },\n    success: function() {\n      if (overlay) overlay.clear();\n    },\n    useCustomOverlay: function(customOverlay) {\n      overlay = customOverlay;\n    }\n  };\n}\n\nvar processUpdate = __webpack_require__(202);\n\nvar customHandler;\nfunction processMessage(obj) {\n  if (obj.action == "building") {\n    if (options.log) console.log("[HMR] bundle rebuilding");\n  } else if (obj.action == "built") {\n    if (options.log) {\n      console.log(\n        "[HMR] bundle " + (obj.name ? obj.name + " " : "") +\n        "rebuilt in " + obj.time + "ms"\n      );\n    }\n    if (obj.errors.length > 0) {\n      if (reporter) reporter.problems(\'errors\', obj);\n    } else {\n      if (reporter) {\n        if (obj.warnings.length > 0) reporter.problems(\'warnings\', obj);\n        reporter.success();\n      }\n\n      processUpdate(obj.hash, obj.modules, options);\n    }\n  } else if (customHandler) {\n    customHandler(obj);\n  }\n}\n\nif (module) {\n  module.exports = {\n    subscribe: function subscribe(handler) {\n      customHandler = handler;\n    },\n    useCustomOverlay: function useCustomOverlay(customOverlay) {\n      if (reporter) reporter.useCustomOverlay(customOverlay);\n    }\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(102)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-hot-middleware/client.js\n ** module id = 201\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-hot-middleware/client.js?')},function(module,exports,__webpack_require__){eval('/**\n * Based heavily on https://github.com/webpack/webpack/blob/\n *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js\n * Original copyright Tobias Koppers @sokra (MIT license)\n */\n\n/* global window __webpack_hash__ */\n\nif (false) {\n  throw new Error("[HMR] Hot Module Replacement is disabled.");\n}\n\nvar hmrDocsUrl = "http://webpack.github.io/docs/hot-module-replacement-with-webpack.html"; // eslint-disable-line max-len\n\nvar lastHash;\nvar failureStatuses = { abort: 1, fail: 1 };\nvar applyOptions = { ignoreUnaccepted: true };\n\nfunction upToDate(hash) {\n  if (hash) lastHash = hash;\n  return lastHash == __webpack_require__.h();\n}\n\nmodule.exports = function(hash, moduleMap, options) {\n  var reload = options.reload;\n  if (!upToDate(hash) && module.hot.status() == "idle") {\n    if (options.log) console.log("[HMR] Checking for updates on the server...");\n    check();\n  }\n\n  function check() {\n    var cb = function(err, updatedModules) {\n      if (err) return handleError(err);\n\n      if(!updatedModules) {\n        if (options.warn) {\n          console.warn("[HMR] Cannot find update (Full reload needed)");\n          console.warn("[HMR] (Probably because of restarting the server)");\n        }\n        performReload();\n        return null;\n      }\n\n      var applyCallback = function(applyErr, renewedModules) {\n        if (applyErr) return handleError(applyErr);\n\n        if (!upToDate()) check();\n\n        logUpdates(updatedModules, renewedModules);\n      };\n\n      var applyResult = module.hot.apply(applyOptions, applyCallback);\n      // webpack 2 promise\n      if (applyResult && applyResult.then) {\n        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`\n        applyResult.then(function(outdatedModules) {\n          applyCallback(null, outdatedModules);\n        });\n        applyResult.catch(applyCallback);\n      }\n\n    };\n\n    var result = module.hot.check(false, cb);\n    // webpack 2 promise\n    if (result && result.then) {\n        result.then(function(updatedModules) {\n            cb(null, updatedModules);\n        });\n        result.catch(cb);\n    }\n  }\n\n  function logUpdates(updatedModules, renewedModules) {\n    var unacceptedModules = updatedModules.filter(function(moduleId) {\n      return renewedModules && renewedModules.indexOf(moduleId) < 0;\n    });\n\n    if(unacceptedModules.length > 0) {\n      if (options.warn) {\n        console.warn(\n          "[HMR] The following modules couldn\'t be hot updated: " +\n          "(Full reload needed)\\n" +\n          "This is usually because the modules which have changed " +\n          "(and their parents) do not know how to hot reload themselves. " +\n          "See " + hmrDocsUrl + " for more details."\n        );\n        unacceptedModules.forEach(function(moduleId) {\n          console.warn("[HMR]  - " + moduleMap[moduleId]);\n        });\n      }\n      performReload();\n      return;\n    }\n\n    if (options.log) {\n      if(!renewedModules || renewedModules.length === 0) {\n        console.log("[HMR] Nothing hot updated.");\n      } else {\n        console.log("[HMR] Updated modules:");\n        renewedModules.forEach(function(moduleId) {\n          console.log("[HMR]  - " + moduleMap[moduleId]);\n        });\n      }\n\n      if (upToDate()) {\n        console.log("[HMR] App is up to date.");\n      }\n    }\n  }\n\n  function handleError(err) {\n    if (module.hot.status() in failureStatuses) {\n      if (options.warn) {\n        console.warn("[HMR] Cannot check for update (Full reload needed)");\n        console.warn("[HMR] " + err.stack || err.message);\n      }\n      performReload();\n      return;\n    }\n    if (options.warn) {\n      console.warn("[HMR] Update check failed: " + err.stack || err.message);\n    }\n  }\n\n  function performReload() {\n    if (reload) {\n      if (options.warn) console.warn("[HMR] Reloading page");\n      window.location.reload();\n    }\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-hot-middleware/process-update.js\n ** module id = 202\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-hot-middleware/process-update.js?')}]);